<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ShareHub]]></title>
  <subtitle><![CDATA[悲观的意志,乐观的头脑]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.xiaohansong.com/"/>
  <updated>2017-03-17T15:12:07.516Z</updated>
  <id>http://blog.xiaohansong.com/</id>
  
  <author>
    <name><![CDATA[肖汉松]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[代码生成利器：IDEA 强大的 Live Templates]]></title>
    <link href="http://blog.xiaohansong.com/2017/03/17/idea-live-templates/"/>
    <id>http://blog.xiaohansong.com/2017/03/17/idea-live-templates/</id>
    <published>2017-03-17T15:08:30.000Z</published>
    <updated>2017-03-17T15:12:07.516Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Java 开发过程经常需要编写有固定格式的代码，例如说声明一个私有变量，<code>logger</code>或者<code>bean</code>等等。对于这种小范围的代码生成，我们可以利用 IDEA 提供的 <code>Live Templates</code>功能。刚开始觉得它只是一个简单的<code>Code Snippet</code>，后来发现它支持变量函数配置，可以支持很复杂的代码生成。下面我来介绍一下<code>Live Templates</code>的用法。</p>
<h2 id="u57FA_u672C_u4F7F_u7528"><a href="#u57FA_u672C_u4F7F_u7528" class="headerlink" title="基本使用"></a>基本使用</h2><p>IDEA 自带很多常用的动态模板，在 Java 代码中输入<code>fori</code>，回车就会出现<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span><span class="comment">; i &lt; ; i++) &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/live01.gif" alt="fori"><br>按<code>Tab</code>可以在各个空白处跳转，手动填值。</p>
<h2 id="u81EA_u5B9A_u4E49_Template"><a href="#u81EA_u5B9A_u4E49_Template" class="headerlink" title="自定义 Template"></a>自定义 Template</h2><p>官方自带模板毕竟不能满足我们个人编码风格的需要，<code>Live Templates</code>提供了变量函数的方式供我们自定义。</p>
<h3 id="u7B80_u5355_u7528_u6CD5"><a href="#u7B80_u5355_u7528_u6CD5" class="headerlink" title="简单用法"></a>简单用法</h3><p>新增自定义模板，首先需要填写触发单词（即 Abbreviation），描述是可选的，然后定义模板的上下文，点击<code>define</code>选择<code>Java</code>，这样在编辑 Java 的时候就会触发当前模板，定义完上下文之后，就可以填写模板了。</p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/live02.gif" alt="new template"><br>下面列举几个我常用的简单模板<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">==========</span><br><span class="line">&lt;out&gt;</span><br><span class="line">----------</span><br><span class="line">System.out.println($END$)</span><br><span class="line">==========</span><br><span class="line"><span class="header">&lt;pfs&gt;</span><br><span class="line">----------</span></span><br><span class="line"><span class="header">private final static String $varName$  = "$var$";`</span><br><span class="line">==========</span></span><br><span class="line"><span class="header">&lt;privateField&gt;</span><br><span class="line">----------</span></span><br><span class="line">/**</span><br><span class="line"><span class="code"> * $COMMENT$</span></span><br><span class="line"><span class="code"> */</span></span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line"><span class="header">private $TYPE$ $NAME$;</span><br><span class="line">==========</span></span><br><span class="line"><span class="header">&lt;main&gt;</span><br><span class="line">----------</span></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"><span class="code">     $END$</span></span><br><span class="line"><span class="header">&#125;</span><br><span class="line">==========</span></span><br></pre></td></tr></table></figure></p>
<p>模板支持变量的定义，使用<code>$$</code>包围的字符表示一个变量。<code>$END$</code>是一个特殊的预定义变量，表示光标最后跳转的位置。每个变量的位置都可以跳转过去。</p>
<h3 id="u9AD8_u7EA7_u7528_u6CD5"><a href="#u9AD8_u7EA7_u7528_u6CD5" class="headerlink" title="高级用法"></a>高级用法</h3><p>如果你用过 vim 的<code>Code Sinppet</code>插件，你会发现模板里面是可以执行函数的，强大的 <code>Live Templates</code>当然也支持，而且 IDEA 能够感知代码的语义，例如说当前编辑的函数的参数。但这一点就能够让我们玩出花来。我们从易到难来研究模板函数的功能。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/live04.gif" alt="variables function"><br>前面我们提到的变量可以绑定函数，配置方式如上图所示。</p>
<h4 id="u5FEB_u901F_u58F0_u660E_u53D8_u91CF"><a href="#u5FEB_u901F_u58F0_u660E_u53D8_u91CF" class="headerlink" title="快速声明变量"></a>快速声明变量</h4><p>声明变量是一个常用的操作，特别是需要声明变量需要加注解，注释的时候，这些代码写起来就很枯燥。下面是我定义的模板：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;osgiRef&gt;</span><br><span class="line">----------</span><br><span class="line">/**</span><br><span class="line"> * <span class="variable">$END</span>$</span><br><span class="line"> */</span><br><span class="line">@OsgiReference</span><br><span class="line">@Setter</span><br><span class="line">private <span class="variable">$TYPE</span>$ <span class="variable">$NAME</span>$;</span><br></pre></td></tr></table></figure></p>
<p>乍一看这个模板跟我上面定义的<code>privateField</code>差不多，唯一的不同在于我给这些变量绑定了函数。</p>
<ol>
<li><code>clipboard()</code>：返回当前粘贴板的字符串</li>
<li><code>decapitalize()</code>：将输入的字符串首字母变为小写</li>
</ol>
<p>下面我们演示一下，我们先拷贝当前类名，然后输入<code>osgiRef</code><br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/live03.gif" alt="osgiRef"></p>
<h4 id="u5FEB_u901F_u58F0_u660E_logger"><a href="#u5FEB_u901F_u58F0_u660E_logger" class="headerlink" title="快速声明 logger"></a>快速声明 logger</h4><p>声明 logger 也是一个常用的操作，上面我们是利用了粘贴函数来快速声明变量，现在我们来利用另一个函数<code>className()</code>，顾名思义，它的作用就是返回当前类名。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="header">&lt;logger&gt;</span><br><span class="line">----------</span></span><br><span class="line">/** logger <span class="strong">*/</span><br><span class="line">private static final Logger LOGGER = LoggerFactory.getLogger($CLASS$.class);</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/live05.gif" alt="logger"></p>
<h4 id="u6700_u5F3A_u5927_u7684_groovyScript_28_29"><a href="#u6700_u5F3A_u5927_u7684_groovyScript_28_29" class="headerlink" title="最强大的 groovyScript()"></a>最强大的 groovyScript()</h4><p>如果说上面用到的函数提供的能力有限，不够灵活，那么<code>groovyScript()</code>提供了一切你想要的能力，它支持执行 Groovy 脚本处理输入，然后输出处理后的字符串。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">groovyScript(<span class="string">"code"</span>, ...)</span><br><span class="line"></span><br><span class="line">|<span class="string">  code   </span>|<span class="string">   一段Groovy代码或者Groovy脚本代码绝对路径    </span>|</span><br><span class="line">|<span class="string">  ...    </span>|<span class="string">   可选入参，这些参数会绑定到`_1, _2, _3, ..._n`, 在 Groovy 代码中使用。</span>|</span><br></pre></td></tr></table></figure></p>
<p>下面我们来看一下它的实际应用。</p>
<h5 id="u5FEB_u901F_bean__u914D_u7F6E"><a href="#u5FEB_u901F_bean__u914D_u7F6E" class="headerlink" title="快速 bean 配置"></a>快速 bean 配置</h5><p>新增一个服务都要在 Spring 中注册一个 bean，一般这个配置无非就是将指明<code>id</code>和<code>class</code>，由于我们是在 xml 中配置，所以不能利用<code>className()</code>函数，但是我们可以利用<code>clipboard()</code>函数获取到类的全引用，在 IDEA 中我们直接右键类名，点击<code>Copy Reference</code>就行。然后执行 groovy 脚本获取类名。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="header">&lt;bean&gt;</span><br><span class="line">----------</span></span><br><span class="line">&lt;bean id="$id$" class="$REF$" /&gt;</span><br></pre></td></tr></table></figure>
<p><code>id</code>绑定<code>decapitalize(groovyScript(&quot;_1.tokenize(&#39;.&#39;)[-1]&quot;, clipboard()))</code>，首先取<code>clipboard()</code>的值得到类的全引用，然后执行 groovy 代码<code>_1.tokenize(&#39;.&#39;)[-1]</code>（按<code>.</code>分割为字符串数组，然后取最后一个即可得到类名，然后用<code>decapitalize()</code>将首字母小写即可得到<code>id</code>。</p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/live06.gif" alt="bean"></p>
<h5 id="u5FEB_u901F_u6253_u5370_u5F53_u524D_u4E0A_u4E0B_u6587_u4FE1_u606F"><a href="#u5FEB_u901F_u6253_u5370_u5F53_u524D_u4E0A_u4E0B_u6587_u4FE1_u606F" class="headerlink" title="快速打印当前上下文信息"></a>快速打印当前上下文信息</h5><p>打印错误日志的时候需要打印当前上下文信息的，例如说入参，有时候入参很多的时候，写起来很痛苦，好在有模板函数<code>methodParameters()</code>，返回当前函数参数的列表，当然这个列表我们不能直接使用，需要结合<code>groovyScript</code>对它进行转化。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;printContext&gt;</span><br><span class="line">---------------</span><br><span class="line">LogUtil.<span class="variable">$TYPE</span>$(LOGGER, <span class="string">"$MSG$ "</span> + <span class="variable">$params</span>$);</span><br></pre></td></tr></table></figure></p>
<p>将<code>params</code>绑定到<code>groovyScript(&quot;&#39;\&quot;&#39; + _1.collect { it + &#39; = [\&quot; + &#39; + it + &#39; + \&quot;]&#39;}.join(&#39;, &#39;) + &#39;\&quot;&#39;&quot;, methodParameters())</code>，就能够自动将当前函数的参数格式化后输出。</p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/live07.gif" alt="printContext"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>上面我们简单介绍了常用的模板函数，其实 IDEA 还有很多其它模板函数，具体参考<a href="https://www.jetbrains.com/help/idea/2016.3/creating-and-editing-template-variables.html" target="_blank" rel="external">Creating and Editing Template Variables</a>。IDEA 是一个很强大的工具，善用工具能够极大的提高工作效率，将精力投入到关键的事情上，而不是将时间浪费在编写重复代码上面。一些更高级的用法还有待大家去发掘。最后推广一波我写的代码生成插件<a href="https://github.com/x-hansong/CodeMaker" target="_blank" rel="external">CodeMaker</a>，好好利用也能节省很多重复编写代码的时间。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Java 开发过程经常需要编写有固定格式的代码，例如说声明一个私有变量，<code>logger</co]]>
    </summary>
    
      <category term="idea" scheme="http://blog.xiaohansong.com/tags/idea/"/>
    
      <category term="编程实践" scheme="http://blog.xiaohansong.com/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IDEA代码生成插件CodeMaker]]></title>
    <link href="http://blog.xiaohansong.com/2017/02/03/codemaker/"/>
    <id>http://blog.xiaohansong.com/2017/02/03/codemaker/</id>
    <published>2017-02-03T12:11:34.000Z</published>
    <updated>2017-03-17T15:11:59.741Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Java 开发过程中经常会遇到编写重复代码的事情，例如说：编写领域类和持久类的时候，大部分时候它们的变量名称，类型是一样的，在编写领域类的时候常常要重复写类似的代码。类似的问题太多，却没找到可以支持自定义代码模板的插件，只能自己动手，丰衣足食，开发了一个 IDEA 的代码生成插件，通过 Velocity 支持自定义代码模板来生成代码。</p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/codemaker.gif" alt="demonstration"></p>
<p><strong>项目地址</strong>：<a href="https://github.com/x-hansong/CodeMaker" target="_blank" rel="external">CodeMaker</a></p>
<h2 id="u4E3B_u8981_u529F_u80FD"><a href="#u4E3B_u8981_u529F_u80FD" class="headerlink" title="主要功能"></a>主要功能</h2><ol>
<li>支持增加自定义代码模板（Velocity）</li>
<li>支持选择多个类作为代码模板的上下文</li>
</ol>
<h2 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h2><p>下载插件：<a href="https://github.com/x-hansong/CodeMaker/releases/download/1.0/CodeMaker.zip" target="_blank" rel="external">CodeMaker.zip</a></p>
<ol>
<li>打开设置，选择“Plugin”</li>
<li>在右边的框中点击“Install plugin from disk”</li>
<li>选择上面下载的“CodeMaker.zip”</li>
<li>点击“Apply”，然后重启 IDEA。</li>
</ol>
<h2 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h2><p>在 Java 类编辑界面右键“Generate”，选择对应模板即可自动生成代码到当前类的包，大部分情况下生成的代码已经解决了百分之八十的问题，只需稍作修改，移动到合适的包中，就能快速完成代码编写。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/codemaker0.png" alt="codemaker0"></p>
<p>如果代码模板需要除了当前类之外的类作为上下文，可以通过类选择框进行选择。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/codemaker1.png" alt="codemaker1"></p>
<p>目前自带的两个模板：</p>
<ol>
<li><strong>Model</strong>：根据当前类生成一个与其拥有类似属性的类，用于自动生成持久类对应的领域类（在持久类拥有超过10个属性的情况下，能够节省大量时间）。</li>
<li><strong>Converter</strong>：该模板需要两个类作为输入的上下文，用于自动生成领域类与持久类的转化类。</li>
</ol>
<p>上面两个模板是我自己工作中常用的模板，仅供大家参考，自带的模板可能满足不了大家的需求，<strong>所以插件支持自定义新的代码模板</strong>。</p>
<h2 id="u6A21_u677F_u914D_u7F6E"><a href="#u6A21_u677F_u914D_u7F6E" class="headerlink" title="模板配置"></a>模板配置</h2><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/codemaker3.png" alt="codemaker3"></p>
<ol>
<li><strong>增加模板</strong>：点击“Add Template”后，填写相关配置（都不能为空），点击保存后即可生效，无需重启。（感谢<code>khotyn</code>提醒）</li>
<li><strong>删除模板</strong>：点击“Delete Template”就能将该模板删除</li>
</ol>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/codemaker2.png" alt="codemaker2"></p>
<ol>
<li><strong>Template Name</strong>：在生成菜单中显示的名称，英文命名</li>
<li><strong>Class Number</strong>：该模板需要的输入上下文类的数量，例如：如果为 1，,将当前的类作为输入：<code>$class0</code>；如果为 2，需要用户再选择一个类作为输入：<code>$class0, $class1</code>。</li>
<li><strong>Class Name</strong>：生成的类的名称，支持通过 Velocity 进行配置，上下文为跟代码模板的相同。</li>
</ol>
<h2 id="u6A21_u677F_u4E0A_u4E0B_u6587"><a href="#u6A21_u677F_u4E0A_u4E0B_u6587" class="headerlink" title="模板上下文"></a>模板上下文</h2><p>模板上下文包含了以下变量：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">########################################################################################</span></span><br><span class="line"><span class="preprocessor">##</span></span><br><span class="line"><span class="preprocessor">## Common variables:</span></span><br><span class="line"><span class="preprocessor">##  $YEAR - yyyy</span></span><br><span class="line"><span class="preprocessor">##  $TIME - yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="preprocessor">##  $USER - user.name</span></span><br><span class="line"><span class="preprocessor">##</span></span><br><span class="line"><span class="preprocessor">## Available variables:</span></span><br><span class="line"><span class="preprocessor">##  $class0 - the context class</span></span><br><span class="line"><span class="preprocessor">##  $class1 - the selected class, like $class2, $class2</span></span><br><span class="line"><span class="preprocessor">##  $ClassName - generate by the config of "Class Name", the generated class name</span></span><br><span class="line"><span class="preprocessor">##</span></span><br><span class="line"><span class="preprocessor">## Class Entry Structure:</span></span><br><span class="line"><span class="preprocessor">##  $class0.className - the class Name</span></span><br><span class="line"><span class="preprocessor">##  $class0.packageName - the packageName</span></span><br><span class="line"><span class="preprocessor">##  $class0.importList - the list of imported classes name</span></span><br><span class="line"><span class="preprocessor">##  $class0.fields - the list of the class fields</span></span><br><span class="line"><span class="preprocessor">##          - type: the field type</span></span><br><span class="line"><span class="preprocessor">##          - name: the field name</span></span><br><span class="line"><span class="preprocessor">##          - modifier: the field modifier, like "private"</span></span><br><span class="line"><span class="preprocessor">##  $class0.methods - the list of class methods</span></span><br><span class="line"><span class="preprocessor">##          - name: the method name</span></span><br><span class="line"><span class="preprocessor">##          - modifier: the method modifier, like "private static"</span></span><br><span class="line"><span class="preprocessor">##          - returnType: the method returnType</span></span><br><span class="line"><span class="preprocessor">##          - params: the method params, like "(String name)"</span></span><br><span class="line"><span class="preprocessor">##</span></span><br><span class="line"><span class="preprocessor">########################################################################################</span></span><br></pre></td></tr></table></figure>
<p>具体用法可参考自带的代码模板，通过模板上下文提供的定制能力，可以让每个用户都定制自己的风格的代码模板。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Java 开发过程中经常会遇到编写重复代码的事情，例如说：编写领域类和持久类的时候，大部分时候它们的变量]]>
    </summary>
    
      <category term="idea-plugin" scheme="http://blog.xiaohansong.com/tags/idea-plugin/"/>
    
      <category term="编程实践" scheme="http://blog.xiaohansong.com/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016 我的校招经历与经验]]></title>
    <link href="http://blog.xiaohansong.com/2016/11/25/Recruitment-experience/"/>
    <id>http://blog.xiaohansong.com/2016/11/25/Recruitment-experience/</id>
    <published>2016-11-25T13:56:57.000Z</published>
    <updated>2016-11-25T14:02:02.297Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>我的校招今年结束得比较早，主要是因为拿的都是 9 月初提前批的 offer。今年的校招我拿了网易，阿里的 offer，而且都不是批发价。网易内推比较早，发 offer 也早，所以是我第一个拿到的 offer。不过我最想去的是阿里，所以在阿里给我发了 offer 之后，我就没有再参加腾讯，百度的面试了。想想还是总结一下找工作的经验，让大家参考一下，希望有所帮助。</p>
<h2 id="u6821_u62DB_u7ECF_u5386"><a href="#u6821_u62DB_u7ECF_u5386" class="headerlink" title="校招经历"></a>校招经历</h2><p>我大一大二的时候基本什么都搞：ACM（只坚持了一个寒假），前端，安卓，PHP，Python，甚至还跟着院长研究过虚拟桌面传输框架 Spice 的源码。从大三开始我就已经决定好了找工作的方向：Java 开发，所以后面做项目都是围绕着 Java 展开。大三的寒假的时候刷 leecode，为笔试做准备。</p>
<p>到了内推的时候，第一个内推面试是阿里云，表现得不好，面试官的评价是基础扎实，但是缺乏亮点。后来我想了一下，确实之前做的项目没什么亮点，不过还好阿里实习生的正式面试还有两个月时间给我准备，所以当时我就开始准备做 <a href="https://github.com/x-hansong/RedisHttpSession" target="_blank" rel="external">RedisHttpSession</a> 这个开源项目，用 Redis 来做共享 Session，这个项目在我后面的阿里实习生面试我自己感觉还是有用的。</p>
<p>第二个内推的是腾讯的安全部门，结果面试官是做 C/C++，所以面试官只能问我基础的东西，因为我做的都是 Java 的项目，他也不感兴趣。结果就是我的基础不扎实，因为我把大部分时间用来准备 Java 的 JVM，并发等问题上，所以过不了也正常。</p>
<p>后来又投了英特尔，结果面试官问我熟不熟悉 Python，我说用 Python 做过爬虫，然后就把我录用，成了我第一个拿到的实习 offer，不过面试这么水其实也不是很想去。</p>
<p>内推到这基本就结束了，后面就是正式的实习生招聘。</p>
<p>第一个是腾讯，结果面的又是 C/C++ 的安全岗，面试官问了很多基础的东西，像 TCP 的超时时间，一个 TCP 连接需要消耗的资源，如何评估机器的最大连接数等，这方面我接触的不多，所以又挂了。</p>
<p>第二个是网易游戏，面的是运营开发，刚好是 Java 岗，一面问了 Java 的基础，二面问了做项目遇到的问题，怎么解决的。等了一个星期以为挂了，后面突然打电话说我过了。拿了第二个实习 offer。</p>
<p>最后是阿里，内推最早，正式招聘最晚。一面一开始就问一些开放性问题，答的不好，犯得毛病就是一开始就陷入技术实现无法自拔，结果答非所问。然后面试官觉得开放性问题问了也白问就开始问我 Java 基础，还好我 Java 基础比较扎实，他越问越深入，从语法问到 JVM 实现，其中穿插问一些算法数据结构，操作系统，数据库的问题，基本都答上来了。最后问了我做的 <a href="https://github.com/x-hansong/RedisHttpSession" target="_blank" rel="external">RedisHttpSession</a>，针对这个项目问了一些实际的问题：共享 session 会不会带来安全问题等。整个面试持续了 1 个小时，问了很多问题。一面完了感觉还是有希望的，前面的开放性问题虽然答的不好，但后面的基础和项目答的还不错。果然不久就有二面了。到了二面，面试官问了一些项目的问题，还问了我对软件工程的看法，因为我的专业就是软件工程。最后是 HR 面，HR 是个大叔，当时我以为还是技术面，一开始他问我项目遇到的难题是怎么解决的，我跟他扯了一堆技术细节。后面他问了一些生活学习上的问题，我才意识到是 HR 面，总之跟 HR 聊的挺开心的，整个过程他都是笑眯眯的。晚上很快就收到了实习 offer，特别开心，然后就拒了其他 offer。</p>
<p>就这样，我来到了杭州的蚂蚁金服，也就是支付宝实习。实习的经历有很多可以讲，但是篇幅所限就不细说了。总的经验就是：<strong>要多思考并且让别人看到你的思考</strong>。</p>
<p>怎么理解？多思考就是做一件事情不是说做完就算了，而是要思考怎样做到更好，反省自己的问题；让别人看到你的思考就是说要让你的主管同事们看到你的思考，例如说你可以把你思考的东西写在周报上，或者跟你的师兄进行讨论等。</p>
<p>实习期间网易的内推很早就开始，于是我就参加了跨境电商的 Java 面，前两面相当顺利，所以给我加了总监面，总监面问得有点压力。值得一提的是网易的笑招组（没有打错）很有意思，发的通知都特别调皮，在杭州 G20 过后给我发了 offer。</p>
<p>最后是阿里的转正面试，其实转正面试主要是考核你在短短两三个月的实习中的成长，对于做业务系统需求的实习生来说，最重要莫过于你对业务的理解有多深，对于项目的业务意义有多清楚，以及实现过程遇到问题的解决方式。简单来说就是讲清楚，并且要从更高的维度开始讲。我当时跟 P9 的面试官讲我做的项目，是从整个大的主业务慢慢讲到自己做的项目，将我做的改动的业务意义讲得很清楚，于是他也听得津津有味，一连听我讲了两个项目，对我的评价也很好。也就是说也许你做的改动特别小，可能就是个增删改查，但是一旦你能想清楚你所做的改动对于整个业务的意义，此时它就不是一个简单的东西，而是有特定业务意义。如果你停留在做增删改查的层次，那么面试官绝对不会满意的。要想清楚业务的意义除了自己思考之外，一定要求助于对业务最熟悉的那个人，让他帮你理清思路。</p>
<p>我的整个校招经历基本就讲完了，拿了支付宝 offer 之后就没有继续面其他公司了，直接跑来继续实习了。在支付宝工作，技术上的成长是特别快的。</p>
<h2 id="u6821_u62DB_u7ECF_u9A8C"><a href="#u6821_u62DB_u7ECF_u9A8C" class="headerlink" title="校招经验"></a>校招经验</h2><p>下面总结一下我的校招经验，供大家参考。</p>
<h3 id="u91CD_u89C6_u627E_u5B9E_u4E60"><a href="#u91CD_u89C6_u627E_u5B9E_u4E60" class="headerlink" title="重视找实习"></a>重视找实习</h3><p>一般每年3月份开始也就是春招的时候很多大公司就会开始招实习生了。在我看来，找实习就是校招的开始，而不是说等到6,7月份的秋招。为什么这么说？因为 BAT 今年校招的趋势就是优先招实习生，其次是内推，正式校招进来的很少。主要原因就是校招名额少了，以前可能正式校招会招不少人，但以后的趋势就是实习生，内推，想要正式校招进来会很难。所以说，能进 BAT 实习基本上一只脚就进 BAT 了，即使不能转正，有 BAT 实习经历也很好找工作。</p>
<p>说这么多无非就是强调准备实习面试的重要性，千万不要以为实习水水，等到秋招再努力，到时候就晚了。所以我的第一条经验就是<strong>重视找实习</strong></p>
<h2 id="u6253_u597D_u57FA_u7840"><a href="#u6253_u597D_u57FA_u7840" class="headerlink" title="打好基础"></a>打好基础</h2><p>打好基础，怎么强调都不过分。面试三方看运气，七分看实力。基础起码占你实力的百分之五十。什么是基础？就是计算机的专业课。</p>
<p>大部分应届生是没有什么牛逼的项目经历的（包括我），所以大部分面试官对于校招最看重的就是基础，经常会问到就是快排，画 UML 图等。不要以为这些很简单，事实上一个快排就能刷了很多人。</p>
<p>专业课包括：</p>
<ol>
<li>算法与数据结构</li>
<li>操作系统</li>
<li>编译原理</li>
<li>计算机组成</li>
<li>C/C++</li>
<li>计算机网络</li>
<li>设计模式</li>
<li>UML</li>
<li>软件测试</li>
<li>IT 项目管理</li>
</ol>
<p>软件测试和 IT 项目管理偏工程应用，对面试帮助不大，在学的时候也觉得没什么用，但其实真正工作了才知道它们的重要性。</p>
<p>上面每一门课的知识太多，就算是我也记不了那么多。但是面试就像考试，总有重点可以划。我的经验是去网上搜一下面经，多篇面经综合起来就可以看出哪些知识是重点。当然，考试只看重点也很难考高分，最好的方法自然是平时多努力，临考前抱抱佛脚。</p>
<p>我就不重复划重点了，网上已经有很多面经了，基础打好了，再根据实际情况重点突破，例如安卓要看看安卓源码，Java 要看看 JDK 源码等。</p>
<h3 id="u591A_u505A_u9879_u76EE"><a href="#u591A_u505A_u9879_u76EE" class="headerlink" title="多做项目"></a>多做项目</h3><p>学习编程的捷径只有一个：就是<strong>多动手写代码</strong>。看一千遍《算法导论》，不如动手做一道课后题。其实道理很简单，但是做起来很难，除非你自己对编程有兴趣，否则做项目对你来说就跟做作业一样痛苦。但是如果想要找一份编程的工作，总是要付出的。付出不是说看看书，背背题就行，而是要动手写代码，学以致用，否则永远都是纸上谈兵，别人一问就露陷了。</p>
<p>做项目也不是说随便水水，做出一个能用的东西就好，而是要精益求精，想想怎么能做得更好。很多时候面试官不按套路出牌问你一些实际问题，其实就是想考验你平时做项目有没有思考更多东西，而不是满足于实现功能。这些东西来源于平时的积累，所以平时做项目认真点，面试的时候底气就足一点。</p>
<p>项目的来源可以是课程的大作业，自己想做的东西（像我就做过刷课爬虫），老师的项目，学校申报的项目。只要你想做，总是有东西可以实践的。不要羡慕别人跟了某个牛逼的老师做项目，别人主动去找机会了，你自己不去争取，能怪谁？所以，找项目做一定要主动。</p>
<h3 id="u9762_u8BD5_u5FC3_u6001"><a href="#u9762_u8BD5_u5FC3_u6001" class="headerlink" title="面试心态"></a>面试心态</h3><p>心态对于面试表现是很重要的，第一次面试肯定会紧张，这种东西需要通过多参加面试解决。其次，准备越充分，面试就越不紧张，因为他问的东西你都能答上来，自然就不会紧张了。最后，对于失败要有乐观的态度，我第一次内推阿里失败的时候，内推我的师兄跟我说：<strong>面试过不了只是说明这个岗位不适合你，并不是说你的能力不行</strong>。所以要用良好的心态去对待面试，面试有运气的成分，此处不留爷，自有留爷处。让自己随时做好准备，总能找到合适的工作。</p>
<p><strong>在没有坑之前，先让自己成为萝卜。</strong></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>其实要找一份合适的工作是不容易的，但是让自己做好准备，从心里重视找实习，平时打好基础，多做项目多思考，在面试过程中调整心态，好工作就是水到渠成的事情。最后推荐我写的一篇文章：<a href="http://blog.xiaohansong.com/2016/01/16/kownledge-Management/">程序员的知识管理</a>，希望对大家整理自己的知识有所帮助。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>我的校招今年结束得比较早，主要是因为拿的都是 9 月初提前批的 offer。今年的校招我拿了网易，阿里的]]>
    </summary>
    
      <category term="校招" scheme="http://blog.xiaohansong.com/tags/%E6%A0%A1%E6%8B%9B/"/>
    
      <category term="随想" scheme="http://blog.xiaohansong.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图解 Paxos 一致性协议]]></title>
    <link href="http://blog.xiaohansong.com/2016/09/30/Paxos/"/>
    <id>http://blog.xiaohansong.com/2016/09/30/Paxos/</id>
    <published>2016-09-30T02:17:52.000Z</published>
    <updated>2016-09-30T02:30:14.206Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Paxos 一致性协议可以说是一致性协议研究的起点，也以难以理解闻名。其实协议本身并没有多难理解，它的难理解性主要体现在：为何如此设计协议以及如何证明其正确性。本文尝试通过流程图来说明协议的内容以及基本应用过程，不涉及如何证明其正确性。</p>
<h2 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h2><p>Paxos 可以分为两种：</p>
<ul>
<li><strong>Single-Decree Paxos</strong>：决策单个 Value</li>
<li><strong>Multi-Paxos</strong>：连续决策多个 Value，并且保证每个节点上的顺序完全一致，多 Paxos 往往是同事运行多个单 Paxos 协议共同执行的结果。</li>
</ul>
<p>本文只关注单 Paxos 的原理，理解了单 Paxos，多 Paxos 也就不难理解了。</p>
<h3 id="Paxos__u534F_u8BAE_u4E2D_u7684_u4E09_u79CD_u89D2_u8272"><a href="#Paxos__u534F_u8BAE_u4E2D_u7684_u4E09_u79CD_u89D2_u8272" class="headerlink" title="Paxos 协议中的三种角色"></a>Paxos 协议中的三种角色</h3><ul>
<li><strong>倡议者（Proposer）</strong>：倡议者可以提出提议（数值或者操作命令）以供投票表决</li>
<li><strong>接受者（Acceptor）</strong>：接受者可以对倡议者提出的提议进行投票表决，提议有超半数的接受者投票即被选中</li>
<li><strong>学习者（Learner）</strong>：学习者无投票权，只是从接受者那里获知哪个提议被选中</li>
</ul>
<p>在协议中，每个节点可以同时扮演以上多个角色。</p>
<h3 id="Paxos__u7684_u7279_u70B9"><a href="#Paxos__u7684_u7279_u70B9" class="headerlink" title="Paxos 的特点"></a>Paxos 的特点</h3><ul>
<li>一个或多个节点可以提出提议</li>
<li>系统必须针对所有提案中的某个提案达成一致（超过半数的接受者选中）</li>
<li>最多只能对一个确定的提议达成一致</li>
<li>只要超半数的节点存活且可互相通信，整个系统一定能达成一致状态，即选择一个确定的提议</li>
</ul>
<h2 id="u534F_u8BAE_u56FE_u793A"><a href="#u534F_u8BAE_u56FE_u793A" class="headerlink" title="协议图示"></a>协议图示</h2><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/Paxos.png" alt="Paxos"><br>通过上面的流程，如果有多个节点同时提出各自的提议，Paxos 就可以保证从中选出一个唯一确定的值，保证分布式系统的一致性。</p>
<h2 id="u5B9E_u4F8B"><a href="#u5B9E_u4F8B" class="headerlink" title="实例"></a>实例</h2><p>下面我们通过例子来理解 Paxos 的实际应用过程。</p>
<p>假设现在有五个节点的分布式系统，此时 A 节点打算提议 X 值，E 节点打算提议 Y 值，其他节点没有提议。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/Paxos-1.png" alt="Paxos-1"></p>
<p>假设现在 A 节点广播它的提议（也会发送给自己），由于网络延迟的原因，只有 A，B，C 节点收到了。注意即使 A，E 节点的提议同时到达某个节点，它也必然有个先后处理的顺序，这里的“同时”不是真正意义上的“同时”。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/Paxos-2.png" alt="Paxos-2"></p>
<p>A，B，C接收提议之后，由于这是第一个它们接收到的提议，acceptedProposal 和 acceptedValue 都为空。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/Paxos-3.png" alt="Paxos-3"></p>
<p>由于 A 节点已经收到超半数的节点响应，且返回的 acceptedValue 都为空，也就是说它可以用 X 作为提议的值来发生 Accept 请求，A，B，C接收到请求之后，将 acceptedValue 更新为 X。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/Paxos-4.png" alt="Paxos-4"></p>
<p>A，B，C 会发生 minProposal 给 A，A 检查发现没有大于 1 的 minProposal 出现，此时 X 已经被选中。等等，我们是不是忘了D，E节点？它们的 acceptedValue 并不是 X，系统还处于不一致状态。至此，Paxos 过程还没有结束，我们继续看。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/Paxos-5.png" alt="Paxos-5"></p>
<p>此时 E 节点选择 Proposal ID 为 2 发送 Prepare 请求，结果就和上面不一样了，因为 C 节点已经接受了 A 节点的提议，它不会三心二意，所以就告诉 E 节点它的选择，E 节点也很绅士，既然 C 选择了 A 的提议，那我也选它吧。于是，E 发起 Accept 请求，使用 X 作为提议值，至此，整个分布式系统达成了一致，大家都选择了 X。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/Paxos-6.png" alt="Paxos-6"></p>
<p>上面是 Paxos 的一个简单应用过程，其他复杂的场景也可以根据流程图慢慢推导，这里只是抛砖引玉。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Paxos 一致性协议可以说是一致性协议研究的起点，也以难以理解闻名。其实协议本身并没有多难理解，它的难]]>
    </summary>
    
      <category term="Paxos" scheme="http://blog.xiaohansong.com/tags/Paxos/"/>
    
      <category term="一致性协议" scheme="http://blog.xiaohansong.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Zookeeper ZAB 协议分析]]></title>
    <link href="http://blog.xiaohansong.com/2016/08/25/zab/"/>
    <id>http://blog.xiaohansong.com/2016/08/25/zab/</id>
    <published>2016-08-25T15:53:11.000Z</published>
    <updated>2016-09-30T02:21:31.232Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>ZAB 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p>
<h2 id="Atomic_broadcast_protocol"><a href="#Atomic_broadcast_protocol" class="headerlink" title="Atomic broadcast protocol"></a>Atomic broadcast protocol</h2><p>ZAB 是 Zookeeper 原子广播协议的简称，下面我们来讨论协议的内容，注意：理论与实现是有区别的，如果你对协议的理论不感兴趣，可以直接跳过看实现。</p>
<h3 id="u95EE_u9898_u7684_u63D0_u51FA"><a href="#u95EE_u9898_u7684_u63D0_u51FA" class="headerlink" title="问题的提出"></a>问题的提出</h3><p>Zookeeper 客户端会随机连接到 Zookeeper 集群的一个节点，如果是读请求，就直接从当前节点中读取数据；如果是写请求，那么节点就会向 leader 提交事务，leader 会广播事务，只要有超过半数节点写入成功，该写请求就会被提交（类 2PC 协议）。</p>
<p>那么问题来了：</p>
<ul>
<li>主从架构下，leader 崩溃，数据一致性怎么保证？</li>
<li>选举 leader 的时候，整个集群无法处理写请求的，如何快速进行 leader 选举？</li>
</ul>
<p>带着这两个问题，我们来看看 ZAB 协议是如何解决的。</p>
<h3 id="ZAB__u7684_u56DB_u4E2A_u9636_u6BB5"><a href="#ZAB__u7684_u56DB_u4E2A_u9636_u6BB5" class="headerlink" title="ZAB 的四个阶段"></a>ZAB 的四个阶段</h3><h4 id="u672F_u8BED_u89E3_u91CA"><a href="#u672F_u8BED_u89E3_u91CA" class="headerlink" title="术语解释"></a>术语解释</h4><ul>
<li><strong>quorum</strong>：集群中超过半数的节点集合</li>
</ul>
<p>ZAB 中的节点有三种状态</p>
<ul>
<li><strong>following</strong>：当前节点是跟随者，服从 leader 节点的命令</li>
<li><strong>leading</strong>：当前节点是 leader，负责协调事务</li>
<li><strong>election/looking</strong>：节点处于选举状态</li>
</ul>
<p><em>代码实现中多了一种：observing 状态，这是 Zookeeper 引入 Observer 之后加入的，Observer 不参与选举，是只读节点，跟 ZAB 协议没有关系</em></p>
<p>节点的持久状态</p>
<ul>
<li><strong>history</strong>：当前节点接收到事务提议的 log</li>
<li><strong>acceptedEpoch</strong>：follower 已经接受的 leader 更改年号的 NEWEPOCH 提议</li>
<li><strong>currentEpoch</strong>：当前所处的年代</li>
<li><strong>lastZxid</strong>：history 中最近接收到的提议的 zxid （最大的）</li>
</ul>
<blockquote>
<p>在 ZAB 协议的事务编号 Zxid 设计中，Zxid 是一个 64 位的数字，其中低 32 位是一个简单的单调递增的计数器，针对客户端每一个事务请求，计数器加 1；而高 32 位则代表 Leader 周期 epoch 的编号，每个当选产生一个新的 Leader 服务器，就会从这个 Leader 服务器上取出其本地日志中最大事务的ZXID，并从中读取 epoch 值，然后加 1，以此作为新的 epoch，并将低 32 位从 0 开始计数。</p>
<p>epoch：可以理解为当前集群所处的年代或者周期，每个 leader 就像皇帝，都有自己的年号，所以每次改朝换代，leader 变更之后，都会在前一个年代的基础上加 1。这样就算旧的 leader 崩溃恢复之后，也没有人听他的了，因为 follower 只听从当前年代的 leader 的命令。*</p>
</blockquote>
<h4 id="Phase_0_3A_Leader_election_uFF08_u9009_u4E3E_u9636_u6BB5_uFF09"><a href="#Phase_0_3A_Leader_election_uFF08_u9009_u4E3E_u9636_u6BB5_uFF09" class="headerlink" title="Phase 0: Leader election（选举阶段）"></a>Phase 0: Leader election（选举阶段）</h4><p>节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。只有到达 Phase 3 准 leader 才会成为真正的 leader。这一阶段的目的是就是为了选出一个准 leader，然后进入下一个阶段。</p>
<p>协议并没有规定详细的选举算法，后面我们会提到实现中使用的 Fast Leader Election。</p>
<h4 id="Phase_1_3A_Discovery_uFF08_u53D1_u73B0_u9636_u6BB5_uFF09"><a href="#Phase_1_3A_Discovery_uFF08_u53D1_u73B0_u9636_u6BB5_uFF09" class="headerlink" title="Phase 1: Discovery（发现阶段）"></a>Phase 1: Discovery（发现阶段）</h4><p>在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。这个一阶段的主要目的是发现当前大多数节点接收的最新提议，并且准 leader 生成新的 epoch，让 followers 接受，更新它们的 acceptedEpoch<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/phase1.png" alt="phase 1"><br>一个 follower 只会连接一个 leader，如果有一个节点 f 认为另一个 follower p 是 leader，f 在尝试连接 p 时会被拒绝，f 被拒绝之后，就会进入 Phase 0。</p>
<h4 id="Phase_2_3A_Synchronization_uFF08_u540C_u6B65_u9636_u6BB5_uFF09"><a href="#Phase_2_3A_Synchronization_uFF08_u540C_u6B65_u9636_u6BB5_uFF09" class="headerlink" title="Phase 2: Synchronization（同步阶段）"></a>Phase 2: Synchronization（同步阶段）</h4><p>同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。只有当 quorum 都同步完成，准 leader 才会成为真正的 leader。follower 只会接收 zxid 比自己的 lastZxid 大的提议。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/phase2.png" alt="phase 2"></p>
<h4 id="Phase_3_3A_Broadcast_uFF08_u5E7F_u64AD_u9636_u6BB5_uFF09"><a href="#Phase_3_3A_Broadcast_uFF08_u5E7F_u64AD_u9636_u6BB5_uFF09" class="headerlink" title="Phase 3: Broadcast（广播阶段）"></a>Phase 3: Broadcast（广播阶段）</h4><p>到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/phase3.png" alt="phase 3"><br>值得注意的是，ZAB 提交事务并不像 2PC 一样需要全部 follower 都 ACK，只需要得到 quorum （超过半数的节点）的 ACK 就可以了。</p>
<h2 id="u534F_u8BAE_u5B9E_u73B0"><a href="#u534F_u8BAE_u5B9E_u73B0" class="headerlink" title="协议实现"></a>协议实现</h2><p>协议的 Java 版本实现跟上面的定义有些不同，选举阶段使用的是 Fast Leader Election（FLE），它包含了 Phase 1 的发现职责。因为 FLE 会选举拥有最新提议历史的节点作为 leader，这样就省去了发现最新提议的步骤。实际的实现将 Phase 1 和 Phase 2 合并为 Recovery Phase（恢复阶段）。所以，ZAB 的实现只有三个阶段：</p>
<ul>
<li><strong>Fast Leader Election</strong></li>
<li><strong>Recovery Phase</strong></li>
<li><strong>Broadcast Phase</strong></li>
</ul>
<h3 id="Fast_Leader_Election"><a href="#Fast_Leader_Election" class="headerlink" title="Fast Leader Election"></a>Fast Leader Election</h3><p>前面提到 FLE 会选举拥有最新提议历史（lastZixd最大）的节点作为 leader，这样就省去了发现最新提议的步骤。这是基于拥有最新提议的节点也有最新提交记录的前提。</p>
<h4 id="u6210_u4E3A_leader__u7684_u6761_u4EF6"><a href="#u6210_u4E3A_leader__u7684_u6761_u4EF6" class="headerlink" title="成为 leader 的条件"></a>成为 leader 的条件</h4><ol>
<li>选<code>epoch</code>最大的</li>
<li><code>epoch</code>相等，选 zxid 最大的</li>
<li><code>epoch</code>和<code>zxid</code>都相等，选择<code>server id</code>最大的（就是我们配置<code>zoo.cfg</code>中的<code>myid</code>）</li>
</ol>
<p>节点在选举开始都默认投票给自己，当接收其他节点的选票时，会根据上面的条件更改自己的选票并重新发送选票给其他节点，当有一个节点的得票超过半数，该节点会设置自己的状态为 leading，其他节点会设置自己的状态为 following。</p>
<h4 id="u9009_u4E3E_u8FC7_u7A0B"><a href="#u9009_u4E3E_u8FC7_u7A0B" class="headerlink" title="选举过程"></a>选举过程</h4><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/FLE.png" alt="FLE"></p>
<h3 id="Recovery_Phase__uFF08_u6062_u590D_u9636_u6BB5_uFF09"><a href="#Recovery_Phase__uFF08_u6062_u590D_u9636_u6BB5_uFF09" class="headerlink" title="Recovery Phase  （恢复阶段）"></a>Recovery Phase  （恢复阶段）</h3><p>这一阶段 follower 发送它们的 lastZixd 给 leader，leader 根据 lastZixd 决定如何同步数据。这里的实现跟前面 Phase 2 有所不同：Follower 收到 TRUNC 指令会中止 L.lastCommittedZxid 之后的提议，收到 DIFF 指令会接收新的提议。</p>
<blockquote>
<p>history.lastCommittedZxid：最近被提交的提议的 zxid<br>history:oldThreshold：被认为已经太旧的已提交提议的 zxid</p>
</blockquote>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/recovery.png" alt="Recovery Phase"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>经过上面的分析，我们可以来回答开始提到的两个问题</p>
<ul>
<li><p>主从架构下，leader 崩溃，数据一致性怎么保证？</p>
<p>  leader 崩溃之后，集群会选出新的 leader，然后就会进入恢复阶段，新的 leader 具有所有已经提交的提议，因此它会保证让 followers 同步已提交的提议，丢弃未提交的提议（以 leader 的记录为准），这就保证了整个集群的数据一致性。</p>
</li>
<li><p>选举 leader 的时候，整个集群无法处理写请求的，如何快速进行 leader 选举？</p>
<p>  这是通过 Fast Leader Election 实现的，leader 的选举只需要超过半数的节点投票即可，这样不需要等待所有节点的选票，能够尽早选出 leader。</p>
</li>
</ul>
<p>这篇文章是根据我对 ZAB 协议的理解写成的，如果觉得有些细节没有讲清楚，可以看后面的参考资料，我主要是参考这篇<a href="http://www.tcs.hut.fi/Studies/T-79.5001/reports/2012-deSouzaMedeiros.pdf&amp;usg=AFQjCNG8TKh-JN5Csqoditj7hlOo5nbR6g" target="_blank" rel="external">论文</a>的。</p>
<p><em>参考资料</em><br><a href="http://www.tcs.hut.fi/Studies/T-79.5001/reports/2012-deSouzaMedeiros.pdf&amp;usg=AFQjCNG8TKh-JN5Csqoditj7hlOo5nbR6g" target="_blank" rel="external">ZooKeeper’s atomic broadcast protocol:Theory and practice</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>ZAB 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。在 Zoo]]>
    </summary>
    
      <category term="ZAB" scheme="http://blog.xiaohansong.com/tags/ZAB/"/>
    
      <category term="Zookeeper" scheme="http://blog.xiaohansong.com/tags/Zookeeper/"/>
    
      <category term="一致性协议" scheme="http://blog.xiaohansong.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="分布式" scheme="http://blog.xiaohansong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Zookeeper" scheme="http://blog.xiaohansong.com/categories/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ZooKeeper Watcher 和 AsyncCallback 的区别与实现]]></title>
    <link href="http://blog.xiaohansong.com/2016/08/22/zookeeper-watch-async/"/>
    <id>http://blog.xiaohansong.com/2016/08/22/zookeeper-watch-async/</id>
    <published>2016-08-22T14:15:08.000Z</published>
    <updated>2016-08-26T13:57:15.595Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>初学 Zookeeper 会发现客户端有两种回调方式： Watcher 和 AsyncCallback，而 Zookeeper 的使用是离不开这两种方式的，搞清楚它们之间的区别与实现显得尤为重要。本文将围绕下面几个方面展开</p>
<ul>
<li>Watcher 和 AsyncCallback 的区别</li>
<li>Watcher 的回调实现</li>
<li>AsyncCallback 的回调实现</li>
<li>IO 与事件处理</li>
</ul>
<h2 id="Watcher__u548C_AsyncCallback__u7684_u533A_u522B"><a href="#Watcher__u548C_AsyncCallback__u7684_u533A_u522B" class="headerlink" title="Watcher 和 AsyncCallback 的区别"></a>Watcher 和 AsyncCallback 的区别</h2><p>我们先通过一个例子来感受一下：</p>
<pre><code>zooKeeper.getData(root, new Watcher() {
            public void process(WatchedEvent event) {

            }
        }, new AsyncCallback.DataCallback() {
            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {

            }
        }, null);
</code></pre><p>可以看到，<code>getData</code>方法可以同时设置两个回调：Watcher 和 AsyncCallback，同样是回调，它们的区别是什么呢？要解决这个问题，我们就得从这两个接口的功能入手。</p>
<ul>
<li><code>Watcher</code>：<code>Watcher</code>是用于监听节点，session 状态的，比如<code>getData</code>对数据节点<code>a</code>设置了<code>watcher</code>，那么当<code>a</code>的数据内容发生改变时，客户端会收到<code>NodeDataChanged</code>通知，然后进行<code>watcher</code>的回调。</li>
<li><code>AsyncCallback</code>:<code>AsyncCallback</code>是在以异步方式使用 ZooKeeper API 时，用于处理返回结果的。例如：<code>getData</code>同步调用的版本是：<code>byte[] getData(String path, boolean watch,Stat stat)</code>，异步调用的版本是：<code>void getData(String path,Watcher watcher,AsyncCallback.DataCallback cb,Object ctx)</code>，可以看到，前者是直接返回获取的结果，后者是通过<code>AsyncCallback</code>回调处理结果的。</li>
</ul>
<h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p>Watcher 主要是通过<code>ClientWatchManager</code>进行管理的。下面是 Watcher 相关类图</p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/WatcherClass.png" alt="WatcherClass"></p>
<p>添加 Watcher 的流程如下：</p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/regist_watch.png" alt="添加Watcher"></p>
<h3 id="Watcher__u7684_u7C7B_u578B"><a href="#Watcher__u7684_u7C7B_u578B" class="headerlink" title="Watcher 的类型"></a>Watcher 的类型</h3><p><code>ClientWatchManager</code>中有四种<code>Watcher</code></p>
<ul>
<li><code>defaultWatcher</code>：创建<code>Zookeeper</code>连接时传入的<code>Watcher</code>，用于监听 session 状态</li>
<li><code>dataWatches</code>：存放<code>getData</code>传入的<code>Watcher</code></li>
<li><code>existWatches</code>：存放<code>exists</code>传入的<code>Watcher</code>，如果节点已存在，则<code>Watcher</code>会被添加到<code>dataWatches</code></li>
<li><code>childWatches</code>：存放<code>getChildren</code>传入的<code>Watcher</code></li>
</ul>
<p>从代码上可以发现，监听器是存在<code>HashMap</code>中的，<code>key</code>是节点名称<code>path</code>，<code>value</code>是<code>Set&lt;Watcher&gt;</code></p>
<pre><code>private final Map&lt;String, Set&lt;Watcher&gt;&gt; dataWatches =
        new HashMap&lt;String, Set&lt;Watcher&gt;&gt;();
private final Map&lt;String, Set&lt;Watcher&gt;&gt; existWatches =
        new HashMap&lt;String, Set&lt;Watcher&gt;&gt;();
private final Map&lt;String, Set&lt;Watcher&gt;&gt; childWatches =
        new HashMap&lt;String, Set&lt;Watcher&gt;&gt;();

private volatile Watcher defaultWatcher;
</code></pre><h3 id="u901A_u77E5_u7684_u72B6_u6001_u7C7B_u578B_u4E0E_u4E8B_u4EF6_u7C7B_u578B"><a href="#u901A_u77E5_u7684_u72B6_u6001_u7C7B_u578B_u4E0E_u4E8B_u4EF6_u7C7B_u578B" class="headerlink" title="通知的状态类型与事件类型"></a>通知的状态类型与事件类型</h3><p>在<code>Watcher</code>接口中，已经定义了所有的状态类型和事件类型</p>
<ul>
<li><p>KeeperState.Disconnected(0)</p>
<p>  此时客户端处于断开连接状态，和ZK集群都没有建立连接。</p>
<ul>
<li><p>EventType.None(-1)</p>
<p>  触发条件：一般是在与服务器断开连接的时候，客户端会收到这个事件。</p>
</li>
</ul>
</li>
<li><p>KeeperState. SyncConnected(3)</p>
<p>  此时客户端处于连接状态</p>
<ul>
<li><p>EventType.None(-1)</p>
<p>  触发条件：客户端与服务器成功建立会话之后，会收到这个通知。</p>
</li>
<li><p>EventType. NodeCreated (1)</p>
<p>  触发条件：所关注的节点被创建。</p>
</li>
<li><p>EventType. NodeDeleted (2)</p>
<p>  触发条件：所关注的节点被删除。</p>
</li>
<li><p>EventType. NodeDataChanged (3)</p>
<p>  触发条件：所关注的节点的内容有更新。注意，这个地方说的内容是指数据的版本<code>号dataVersion</code>。因此，即使使用相同的数据内容来更新，还是会收到这个事件通知的。无论如何，调用了更新接口，就一定会更新<code>dataVersion</code>的。</p>
</li>
<li><p>EventType. NodeChildrenChanged (4)</p>
<p>  触发条件：所关注的节点的子节点有变化。这里说的变化是指子节点的个数和组成，具体到子节点内容的变化是不会通知的。</p>
</li>
</ul>
</li>
<li><p>KeeperState. AuthFailed(4)</p>
<p>  认证失败</p>
<ul>
<li>EventType.None(-1)</li>
</ul>
</li>
<li><p>KeeperState. Expired(-112)</p>
<p>  session 超时</p>
<ul>
<li>EventType.None(-1)</li>
</ul>
</li>
</ul>
<h3 id="materialize__u65B9_u6CD5"><a href="#materialize__u65B9_u6CD5" class="headerlink" title="materialize 方法"></a>materialize 方法</h3><p><code>ClientWatchManager</code>只有一个方法，那就是<code>materialize</code>，它根据事件类型<code>type</code>和<code>path</code>返回监听该节点的特定类型的<code>Watcher</code>。</p>
<pre><code>public Set&lt;Watcher&gt; materialize(Watcher.Event.KeeperState state,
    Watcher.Event.EventType type, String path);
</code></pre><p>核心逻辑如下：</p>
<ol>
<li><code>type == None</code>:返回所有<code>Watcher</code>，也就是说所有的<code>Watcher</code>都会被触发。如果<code>disableAutoWatchReset == true</code>且当前<code>state != SyncConnected</code>，那么还会清空<code>Watcher</code>，意味着移除所有在节点上的<code>Watcher</code>。</li>
<li><code>type == NodeDataChanged | NodeCreated</code>:返回监听<code>path</code>节点的<code>dataWatches &amp; existWatches</code></li>
<li><code>type == NodeChildrenChanged</code>:返回监听<code>path</code>节点的<code>childWatches</code></li>
<li><code>type == NodeDeleted</code>:返回监听<code>path</code>节点的<code>dataWatches | childWatches</code></li>
</ol>
<p>每次返回都会从<code>HashMap</code>中移除节点对应的<code>Watcher</code>，例如：<code>addTo(dataWatches.remove(clientPath), result);</code>，这就是为什么<code>Watcher</code>是一次性的原因（<code>defaultWatcher</code>除外）。值得注意的是，由于使用的是<code>HashSet</code>存储<code>Watcher</code>，重复添加同一个实例的<code>Watcher</code>也只会被触发一次。</p>
<h2 id="AsyncCallback"><a href="#AsyncCallback" class="headerlink" title="AsyncCallback"></a>AsyncCallback</h2><p>Zookeeper 的<code>exists</code>,<code>getData</code>,<code>getChildren</code>方法都有异步的版本，它们与同步方法的区别仅仅在于是否等待响应，底层发送都是通过<code>sendThread</code>异步发送的。下面我们用一幅图来说明：</p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/async.png" alt=""><br>上面的图展示了同步/异步调用<code>getData</code>的流程，其他方法也是类似的。</p>
<h2 id="IO__u4E0E_u4E8B_u4EF6_u5904_u7406"><a href="#IO__u4E0E_u4E8B_u4EF6_u5904_u7406" class="headerlink" title="IO 与事件处理"></a>IO 与事件处理</h2><p>Zookeeper 客户端会启动两个常驻线程</p>
<ul>
<li><code>SendThread</code>：负责 IO 操作，包括发送，接受响应，发送 ping 等。</li>
<li><code>EventThread</code>：负责处理事件，执行回调函数。</li>
</ul>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/event.png" alt=""></p>
<h3 id="readResponse"><a href="#readResponse" class="headerlink" title="readResponse"></a>readResponse</h3><p><code>readResponse</code>是<code>SendThread</code>处理响应的核心函数，核心逻辑如下：</p>
<ol>
<li>接受服务器的响应，并反序列化出<code>ReplyHeader</code>： 有一个单独的线程<code>SendThread</code>，负责接收服务器端的响应。假设接受到的服务器传递过来的字节流是<code>incomingBuffer</code>，那么就将这个<code>incomingBuffer</code>反序列化为<code>ReplyHeader</code>。</li>
<li><p>判断响应类型：判断<code>ReplyHeader</code>是<code>Watcher</code>响应还是<code>AsyncCallback</code>响应：<code>ReplyHeader.getXid()</code>存储了响应类型。</p>
<ol>
<li>如果是<code>Watcher</code>类型响应：从<code>ReplyHeader</code>中创建<code>WatchedEvent</code>，<code>WatchedEvent</code>里面存储了节点的路径，然后去<code>WatcherManager</code>中找到和这个节点相关联的所有<code>Watcher</code>，将他们写入到<code>EventThread</code>的<code>waitingEvents</code>中。</li>
<li>如果是<code>AsyncCallback</code>类型响应：从<code>ReplyHeader</code>中读取<code>response</code>，这个<code>response</code>描述了是<code>Exists，setData，getData，getChildren，create.....</code>中的哪一个异步回调。从<code>pendingQueue</code>中拿到<code>Packet</code>，<code>Packet</code>中的<code>cb</code>存储了<code>AsyncCallback</code>，也就是异步 API 的结果回调。最后将<code>Packet</code>写入到<code>EventThread</code>的<code>waitingEvents</code>中。</li>
</ol>
</li>
</ol>
<h3 id="processEvent"><a href="#processEvent" class="headerlink" title="processEvent"></a>processEvent</h3><p><code>processEvent</code>是<code>EventThread</code>处理事件核心函数，核心逻辑如下：</p>
<ol>
<li>如果<code>event instanceof WatcherSetEventPair</code>，取出<code>pair</code>中的<code>Watchers</code>，逐个调用<code>watcher.process(pair.event)</code></li>
<li>否则<code>event</code>为<code>AsyncCallback</code>，根据<code>p.response</code>判断为哪种响应类型，执行响应的回调<code>processResult</code>。</li>
</ol>
<p>可见，<code>Watcher</code>和<code>AsyncCallback</code>都是由<code>EventThread</code>处理的，通过<code>processEvent</code>进行区分处理。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>Zookeeper 客户端中<code>Watcher</code>和<code>AsyncCallback</code>都是异步回调的方式，但它们回调的时机是不一样的，前者是由服务器发送事件触发客户端回调，后者是在执行了请求后得到响应后客户端主动触发的。它们的共同点在于都需要在获取了服务器响应之后，由<code>SendThread</code>写入<code>EventThread</code>的<code>waitingEvents</code>中，然后由<code>EventThread</code>逐个从事件队列中获取并处理。</p>
<p><em>参考资料</em><br><a href="http://www.cnblogs.com/francisYoung/p/5225703.html" target="_blank" rel="external">ZooKeeper个人笔记客户端watcher和AsycCallback回调</a><br><a href="http://nileader.blog.51cto.com/1381108/954670" target="_blank" rel="external">【ZooKeeper Notes 13】ZooKeeper Watcher的事件通知类型</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>初学 Zookeeper 会发现客户端有两种回调方式： Watcher 和 AsyncCallback，]]>
    </summary>
    
      <category term="Zookeeper" scheme="http://blog.xiaohansong.com/tags/Zookeeper/"/>
    
      <category term="分布式" scheme="http://blog.xiaohansong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Zookeeper" scheme="http://blog.xiaohansong.com/categories/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ThreadLocal 内存泄露的实例分析]]></title>
    <link href="http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/"/>
    <id>http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/</id>
    <published>2016-08-09T14:10:04.000Z</published>
    <updated>2016-08-26T13:56:55.101Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>之前写了一篇<a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/">深入分析 ThreadLocal 内存泄漏问题</a>是从理论上分析<code>ThreadLocal</code>的内存泄漏问题，这一篇文章我们来分析一下实际的内存泄漏案例。分析问题的过程比结果更重要，理论结合实际才能彻底分析出内存泄漏的原因。</p>
<h2 id="u6848_u4F8B_u4E0E_u5206_u6790"><a href="#u6848_u4F8B_u4E0E_u5206_u6790" class="headerlink" title="案例与分析"></a>案例与分析</h2><h3 id="u95EE_u9898_u80CC_u666F"><a href="#u95EE_u9898_u80CC_u666F" class="headerlink" title="问题背景"></a>问题背景</h3><p>在 Tomcat 中，下面的代码都在 webapp 内，会导致<code>WebappClassLoader</code>泄漏，无法被回收。</p>
<pre><code>public class MyCounter {
        private int count = 0;

        public void increment() {
                count++;
        }

        public int getCount() {
                return count;
        }
}

public class MyThreadLocal extends ThreadLocal&lt;MyCounter&gt; {
}

public class LeakingServlet extends HttpServlet {
        private static MyThreadLocal myThreadLocal = new MyThreadLocal();

        protected void doGet(HttpServletRequest request,
                        HttpServletResponse response) throws ServletException, IOException {

                MyCounter counter = myThreadLocal.get();
                if (counter == null) {
                        counter = new MyCounter();
                        myThreadLocal.set(counter);
                }

                response.getWriter().println(
                                &quot;The current thread served this servlet &quot; + counter.getCount()
                                                + &quot; times&quot;);
                counter.increment();
        }
}
</code></pre><p>上面的代码中，只要<code>LeakingServlet</code>被调用过一次，且执行它的线程没有停止，就会导致<code>WebappClassLoader</code>泄漏。每次你 reload 一下应用，就会多一份<code>WebappClassLoader</code>实例，最后导致 PermGen <code>OutOfMemoryException</code>。</p>
<h3 id="u89E3_u51B3_u95EE_u9898"><a href="#u89E3_u51B3_u95EE_u9898" class="headerlink" title="解决问题"></a>解决问题</h3><p>现在我们来思考一下：为什么上面的<code>ThreadLocal</code>子类会导致内存泄漏？</p>
<h4 id="WebappClassLoader"><a href="#WebappClassLoader" class="headerlink" title="WebappClassLoader"></a>WebappClassLoader</h4><p>首先，我们要搞清楚<code>WebappClassLoader</code>是什么鬼？</p>
<blockquote>
<p>对于运行在 Java EE容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。</p>
</blockquote>
<p>也就是说<code>WebappClassLoader</code>是 Tomcat 加载 webapp 的自定义类加载器，每个 webapp 的类加载器都是不一样的，这是为了隔离不同应用加载的类。</p>
<p>那么<code>WebappClassLoader</code>的特性跟内存泄漏有什么关系呢？目前还看不出来，但是它的一个很重要的特点值得我们注意：每个 webapp 都会自己的<code>WebappClassLoader</code>，这跟 Java 核心的类加载器不一样。</p>
<p>我们知道：导致<code>WebappClassLoader</code>泄漏必然是因为它被别的对象强引用了，那么我们可以尝试画出它们的引用关系图。等等！类加载器的作用到底是啥？为什么会被强引用？</p>
<h4 id="u7C7B_u7684_u751F_u547D_u5468_u671F_u4E0E_u7C7B_u52A0_u8F7D_u5668"><a href="#u7C7B_u7684_u751F_u547D_u5468_u671F_u4E0E_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="类的生命周期与类加载器"></a>类的生命周期与类加载器</h4><p>要解决上面的问题，我们得去研究一下类的生命周期和类加载器的关系。这个问题说起来又是一篇文章，参考我做的笔记<a href="http://wiki.xiaohansong.com/java/class_lifecycle.html" target="_blank" rel="external">类的生命周期</a>。</p>
<p>跟我们这个案例相关的主要是类的卸载：</p>
<p>在类使用完之后，如果满足下面的情况，类就会被卸载：</p>
<ol>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的<code>ClassLoader</code>已经被回收。</li>
<li>该类对应的<code>java.lang.Class</code>对象没有任何地方被引用，没有在任何地方通过反射访问该类的方法。</li>
</ol>
<p>如果以上三个条件全部满足，JVM 就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，Java 类的整个生命周期就结束了。</p>
<p>由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机自带的类加载器包括根类加载器、扩展类加载器和系统类加载器。Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。</p>
<p><strong>由用户自定义的类加载器加载的类是可以被卸载的。</strong></p>
<p>注意上面这句话，<code>WebappClassLoader</code>如果泄漏了，意味着它加载的类都无法被卸载，这就解释了为什么上面的代码会导致 PermGen <code>OutOfMemoryException</code>。</p>
<p>关键点看下面这幅图<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/111825528931093.png" alt=""></p>
<p>我们可以发现：类加载器对象跟它加载的 Class 对象是双向关联的。这意味着，Class 对象可能就是强引用<code>WebappClassLoader</code>，导致它泄漏的元凶。</p>
<h3 id="u5F15_u7528_u5173_u7CFB_u56FE"><a href="#u5F15_u7528_u5173_u7CFB_u56FE" class="headerlink" title="引用关系图"></a>引用关系图</h3><p>理解类加载器与类的生命周期的关系之后，我们可以开始画引用关系图了。（图中的<code>LeakingServlet.class</code>与<code>myThreadLocal</code>引用画的不严谨，主要是想表达<code>myThreadLocal</code>是类变量的意思）<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/leak_1.png" alt="leak_1"></p>
<p>下面，我们根据上面的图来分析<code>WebappClassLoader</code>泄漏的原因。</p>
<ol>
<li><code>LeakingServlet</code>持有<code>static</code>的<code>MyThreadLocal</code>，导致<code>myThreadLocal</code>的生命周期跟<code>LeakingServlet</code>类的生命周期一样长。意味着<code>myThreadLocal</code>不会被回收，弱引用形同虚设，所以当前线程无法通过<code>ThreadLocalMap</code>的防护措施清除<code>counter</code>的强引用（见<a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/">深入分析 ThreadLocal 内存泄漏问题</a>）。</li>
<li>强引用链：<code>thread -&gt; threadLocalMap -&gt; counter -&gt; MyCounter.class -&gt; WebappClassLocader</code>，导致<code>WebappClassLoader</code>泄漏。</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>内存泄漏是很难发现的问题，往往由于多方面原因造成。<code>ThreadLocal</code>由于它与线程绑定的生命周期成为了内存泄漏的常客，稍有不慎就酿成大祸。</p>
<p>本文只是对一个特定案例的分析，若能以此举一反三，那便是极好的。最后我留另一个类似的案例供读者分析。</p>
<p><em>本文的案例来自于 Tomcat 的 Wiki <a href="https://wiki.apache.org/tomcat/MemoryLeakProtection" target="_blank" rel="external">MemoryLeakProtection</a></em></p>
<h2 id="u8BFE_u540E_u9898"><a href="#u8BFE_u540E_u9898" class="headerlink" title="课后题"></a>课后题</h2><p>假设我们有一个定义在 Tomcat Common Classpath 下的类（例如说在 <code>tomcat/lib</code> 目录下）</p>
<pre><code>public class ThreadScopedHolder {
        private final static ThreadLocal&lt;Object&gt; threadLocal = new ThreadLocal&lt;Object&gt;();

        public static void saveInHolder(Object o) {
                threadLocal.set(o);
        }

        public static Object getFromHolder() {
                return threadLocal.get();
        }
}
</code></pre><p>两个在 webapp 的类：</p>
<pre><code>public class MyCounter {
        private int count = 0;

        public void increment() {
                count++;
        }

        public int getCount() {
                return count;
        }
}
public class LeakingServlet extends HttpServlet {

        protected void doGet(HttpServletRequest request,
                        HttpServletResponse response) throws ServletException, IOException {

                MyCounter counter = (MyCounter)ThreadScopedHolder.getFromHolder();
                if (counter == null) {
                        counter = new MyCounter();
                        ThreadScopedHolder.saveInHolder(counter);
                }

                response.getWriter().println(
                                &quot;The current thread served this servlet &quot; + counter.getCount()
                                                + &quot; times&quot;);
                counter.increment();
        }
}
</code></pre><h3 id="u63D0_u793A"><a href="#u63D0_u793A" class="headerlink" title="提示"></a>提示</h3><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/leak_2.png" alt="leak_2"></p>
<p><strong>欢迎大家批评指正，留言交流。</strong></p>
<p><em>参考文章</em><br><a href="http://www.tuicool.com/articles/6BJJzin" target="_blank" rel="external">ClassLoader内存溢出-从tomcat的reload说起</a><br><a href="http://blog.csdn.net/u010723709/article/details/50291315" target="_blank" rel="external">类加载器内存泄露与tomcat自定义加载器</a><br><a href="http://wiki.xiaohansong.com/java/class_lifecycle.html" target="_blank" rel="external">类的生命周期</a><br><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/">深入分析 ThreadLocal 内存泄漏问题</a><br><a href="http://lengyun3566.iteye.com/blog/1683972" target="_blank" rel="external">Tomcat源码解读系列（四）——Tomcat类加载机制概述</a><br><a href="https://wiki.apache.org/tomcat/MemoryLeakProtection" target="_blank" rel="external">MemoryLeakProtection</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>之前写了一篇<a href="http://blog.xiaohansong.com/2016/08/0]]>
    </summary>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="http://blog.xiaohansong.com/tags/ThreadLocal/"/>
    
      <category term="并发" scheme="http://blog.xiaohansong.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入分析 ThreadLocal 内存泄漏问题]]></title>
    <link href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/"/>
    <id>http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/</id>
    <published>2016-08-06T12:12:16.000Z</published>
    <updated>2016-08-26T13:57:07.109Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>ThreadLocal</code> 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。但是如果滥用 <code>ThreadLocal</code>，就可能会导致内存泄漏。下面，我们将围绕三个方面来分析 <code>ThreadLocal</code> 内存泄漏的问题</p>
<ul>
<li><code>ThreadLocal</code> 实现原理</li>
<li><code>ThreadLocal</code>为什么会内存泄漏</li>
<li><code>ThreadLocal</code> 最佳实践</li>
</ul>
<h2 id="ThreadLocal__u5B9E_u73B0_u539F_u7406"><a href="#ThreadLocal__u5B9E_u73B0_u539F_u7406" class="headerlink" title="ThreadLocal 实现原理"></a>ThreadLocal 实现原理</h2><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/threadlocal.jpg" alt="ThreadLocal"><br><code>ThreadLocal</code>的实现是这样的：每个<code>Thread</code> 维护一个 <code>ThreadLocalMap</code> 映射表，这个映射表的 <code>key</code> 是 <code>ThreadLocal</code> 实例本身，<code>value</code> 是真正需要存储的 <code>Object</code>。</p>
<p>也就是说 <code>ThreadLocal</code> 本身并不存储值，它只是作为一个 <code>key</code> 来让线程从 <code>ThreadLocalMap</code> 获取 <code>value</code>。值得注意的是图中的虚线，表示 <code>ThreadLocalMap</code> 是使用 <code>ThreadLocal</code> 的弱引用作为 <code>Key</code> 的，弱引用的对象在 GC 时会被回收。</p>
<h2 id="ThreadLocal_u4E3A_u4EC0_u4E48_u4F1A_u5185_u5B58_u6CC4_u6F0F"><a href="#ThreadLocal_u4E3A_u4EC0_u4E48_u4F1A_u5185_u5B58_u6CC4_u6F0F" class="headerlink" title="ThreadLocal为什么会内存泄漏"></a><code>ThreadLocal</code>为什么会内存泄漏</h2><p><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有外部强引用来引用它，那么系统 GC 的时候，这个<code>ThreadLocal</code>势必会被回收，这样一来，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就没有办法访问这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>，如果当前线程再迟迟不结束的话，这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄漏。</p>
<p>其实，<code>ThreadLocalMap</code>的设计中已经考虑到这种情况，也加上了一些防护措施：在<code>ThreadLocal</code>的<code>get()</code>,<code>set()</code>,<code>remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。</p>
<p>但是这些被动的预防措施并不能保证不会内存泄漏：</p>
<ul>
<li>使用<code>static</code>的<code>ThreadLocal</code>，延长了<code>ThreadLocal</code>的生命周期，可能导致的内存泄漏（参考<a href="http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/">ThreadLocal 内存泄露的实例分析</a>）。</li>
<li>分配使用了<code>ThreadLocal</code>又不再调用<code>get()</code>,<code>set()</code>,<code>remove()</code>方法，那么就会导致内存泄漏。</li>
</ul>
<h3 id="u4E3A_u4EC0_u4E48_u4F7F_u7528_u5F31_u5F15_u7528"><a href="#u4E3A_u4EC0_u4E48_u4F7F_u7528_u5F31_u5F15_u7528" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h3><p>从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析<code>ThreadLocal</code>使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？</p>
<p>我们先来看看官方文档的说法：</p>
<blockquote>
<p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了应对非常大和长时间的用途，哈希表使用弱引用的 key。</p>
</blockquote>
<p>下面我们分两种情况讨论：</p>
<ul>
<li><strong>key 使用强引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>不会被回收，导致<code>Entry</code>内存泄漏。</li>
<li><strong>key 使用弱引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，由于<code>ThreadLocalMap</code>持有<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>,<code>get</code>，<code>remove</code>的时候会被清除。</li>
</ul>
<p>比较两种情况，我们可以发现：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果都没有手动删除对应<code>key</code>，都会导致内存泄漏，但是使用弱引用可以多一层保障：<strong>弱引用<code>ThreadLocal</code>不会内存泄漏，对应的<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>,<code>get</code>,<code>remove</code>的时候会被清除</strong>。</p>
<p>因此，<code>ThreadLocal</code>内存泄漏的根源是：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果没有手动删除对应<code>key</code>就会导致内存泄漏，而不是因为弱引用。</p>
<h2 id="ThreadLocal__u6700_u4F73_u5B9E_u8DF5"><a href="#ThreadLocal__u6700_u4F73_u5B9E_u8DF5" class="headerlink" title="ThreadLocal 最佳实践"></a>ThreadLocal 最佳实践</h2><p>综合上面的分析，我们可以理解<code>ThreadLocal</code>内存泄漏的前因后果，那么怎么避免内存泄漏呢？</p>
<ul>
<li>每次使用完<code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据。</li>
</ul>
<p>在使用线程池的情况下，没有及时清理<code>ThreadLocal</code>，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用<code>ThreadLocal</code>就跟加锁完要解锁一样，用完就清理。</p>
<p><em>参考文章</em><br><a href="http://qifuguang.me/2015/09/02/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83%5D%E8%A7%A3%E5%AF%86ThreadLocal/" target="_blank" rel="external">Java并发包学习七 解密ThreadLocal</a><br><a href="http://www.cnblogs.com/onlywujun/p/3524675.html" target="_blank" rel="external">ThreadLocal可能引起的内存泄露</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>ThreadLocal</code> 的作用是提供线程内的局部变量，这种变量在线程的生命周期]]>
    </summary>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="http://blog.xiaohansong.com/tags/ThreadLocal/"/>
    
      <category term="并发" scheme="http://blog.xiaohansong.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Getty】Java NIO框架设计与实现]]></title>
    <link href="http://blog.xiaohansong.com/2016/07/30/getty/"/>
    <id>http://blog.xiaohansong.com/2016/07/30/getty/</id>
    <published>2016-07-30T02:42:23.000Z</published>
    <updated>2016-07-30T03:14:39.521Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/x-hansong/Getty" target="_blank" rel="external">Getty</a>是我为了学习 Java NIO 所写的一个 NIO 框架，实现过程中参考了 Netty 的设计，同时使用 Groovy 来实现。虽然只是玩具，但是麻雀虽小，五脏俱全，在实现过程中，不仅熟悉了 NIO 的使用，还借鉴了很多 Netty 的设计思想，提升了自己的编码和设计能力。</p>
<p>至于为什么用 Groovy 来写，因为我刚学了 Groovy，正好拿来练手，加上 Groovy 是兼容 Java 的，所以只是语法上的差别，底层实现还是基于 Java API的。</p>
<p>Getty 的核心代码行数不超过 500 行，一方面得益于 Groovy 简洁的语法，另一方面是因为我只实现了核心的逻辑，最复杂的其实是解码器实现。脚手架容易搭，摩天大楼哪有那么容易盖，但用来学习 NIO 足以。</p>
<h2 id="u7EBF_u7A0B_u6A21_u578B"><a href="#u7EBF_u7A0B_u6A21_u578B" class="headerlink" title="线程模型"></a>线程模型</h2><p>Getty 使用的是 Reactor 多线程模型<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/getty-1.png" alt="reactor"></p>
<ol>
<li>有专门一个 NIO 线程- Acceptor 线程用于监听服务端，接收客户端的 TCP 连接请求，然后将连接分配给工作线程，由工作线程来监听读写事件。</li>
<li>网络 IO 操作-读/写等由多个工作线程负责，由这些工作线程负责消息的读取、解码、编码和发送。</li>
<li>1 个工作线程可以同时处理N条链路，但是 1 个链路只对应 1 个工作线程，防止发生并发操作问题。</li>
</ol>
<h2 id="u4E8B_u4EF6_u9A71_u52A8_u6A21_u578B"><a href="#u4E8B_u4EF6_u9A71_u52A8_u6A21_u578B" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h2><p>整个服务端的流程处理，建立于事件机制上。在 [接受连接－＞读－＞业务处理－＞写 －＞关闭连接 ]这个过程中，触发器将触发相应事件，由事件处理器对相应事件分别响应，完成服务器端的业务处理。</p>
<h3 id="u4E8B_u4EF6_u5B9A_u4E49"><a href="#u4E8B_u4EF6_u5B9A_u4E49" class="headerlink" title="事件定义"></a>事件定义</h3><ol>
<li><code>onRead</code>：当客户端发来数据，并已被工作线程正确读取时，触发该事件 。该事件通知各事件处理器可以对客户端发来的数据进行实际处理了。</li>
<li><code>onWrite</code>：当客户端可以开始接受服务端发送数据时触发该事件，通过该事件，我们可以向客户端发送响应数据。（当前的实现中并未使用写事件）</li>
<li><code>onClosed</code>：当客户端与服务器断开连接时触发该事件。</li>
</ol>
<h3 id="u4E8B_u4EF6_u56DE_u8C03_u673A_u5236_u7684_u5B9E_u73B0"><a href="#u4E8B_u4EF6_u56DE_u8C03_u673A_u5236_u7684_u5B9E_u73B0" class="headerlink" title="事件回调机制的实现"></a>事件回调机制的实现</h3><p>在这个模型中，事件采用广播方式，也就是所有注册的事件处理器都能获得事件通知。这样可以将不同性质的业务处理，分别用不同的处理器实现，使每个处理器的功能尽可能单一。</p>
<p>如下图：整个事件模型由监听器、事件适配器、事件触发器（HandlerChain，PipeLine）、事件处理器组成。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/getty-2.png" alt="event"></p>
<ul>
<li><p><code>ServerListener</code>：这是一个事件接口，定义需监听的服务器事件</p>
<pre><code>interface ServerListener extends Serializable{
    /**
     * 可读事件回调
     * @param request
     */
    void onRead(ctx)
    /**
     * 可写事件回调
     * @param request
     * @param response
     */
    void onWrite(ctx)
    /**
     * 连接关闭回调
     * @param request
     */
    void onClosed(ctx)
}
</code></pre></li>
<li><p><code>EventAdapter</code>：对 Serverlistener 接口实现一个适配器 (EventAdapter)，这样的好处是最终的事件处理器可以只处理所关心的事件。</p>
<pre><code>class EventAdapter implements ServerListener {
    //下个处理器的引用
    protected next
    void onRead(Object ctx) {
    }
    void onWrite(Object ctx) {
    }
    void onClosed(Object ctx) {
    }
}
</code></pre></li>
<li><p><code>Notifier</code>：用于在适当的时候通过触发服务器事件，通知在册的事件处理器对事件做出响应。</p>
<pre><code>interface Notifier extends Serializable{
    /**
     * 触发所有可读事件回调
     */
    void fireOnRead(ctx)
    /**
     * 触发所有可写事件回调
     */
    void fireOnWrite(ctx)
    /**
     * 触发所有连接关闭事件回调
     */
    void fireOnClosed(ctx)
}
</code></pre></li>
<li><p><code>HandlerChain</code>：实现了<code>Notifier</code>接口，维持有序的事件处理器链条，每次从第一个处理器开始触发。</p>
<pre><code>class HandlerChain implements Notifier{
    EventAdapter head
    EventAdapter tail
    /**
     * 添加处理器到执行链的最后
     * @param handler
     */
    void addLast(handler) {
        if (tail != null) {
            tail.next = handler
            tail = tail.next
        } else {
            head = handler
            tail = head
        }
    }
    void fireOnRead(ctx) {
        head.onRead(ctx)
    }
    void fireOnWrite(ctx) {
        head.onWrite(ctx)
    }
    void fireOnClosed(ctx) {
        head.onClosed(ctx)
    }
}
</code></pre></li>
<li><p><code>PipeLine</code>：实现了<code>Notifier</code>接口，作为事件总线，维持一个事件链的列表。</p>
<pre><code>class PipeLine implements Notifier{
    static logger = LoggerFactory.getLogger(PipeLine.name)
    //监听器队列
    def listOfChain = []
    PipeLine(){}
    /**
     * 添加监听器到监听队列中
     * @param chain
     */
    void addChain(chain) {
        synchronized (listOfChain) {
            if (!listOfChain.contains(chain)) {
                listOfChain.add(chain)
            }
        }
    }
    /**
     * 触发所有可读事件回调
     */
    void fireOnRead(ctx) {
        logger.debug(&quot;fireOnRead&quot;)
        listOfChain.each { chain -&gt;
            chain.fireOnRead(ctx)
        }
    }
    /**
     * 触发所有可写事件回调
     */
    void fireOnWrite(ctx) {
        listOfChain.each { chain -&gt;
            chain.fireOnWrite(ctx)
        }
    }
    /**
     * 触发所有连接关闭事件回调
     */
    void fireOnClosed(ctx) {
        listOfChain.each { chain -&gt;
            chain.fireOnClosed(ctx)
        }
    }
}
</code></pre></li>
</ul>
<h3 id="u4E8B_u4EF6_u5904_u7406_u6D41_u7A0B"><a href="#u4E8B_u4EF6_u5904_u7406_u6D41_u7A0B" class="headerlink" title="事件处理流程"></a>事件处理流程</h3><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/getty-3.png" alt="编程模型"><br>事件处理采用职责链模式，每个处理器处理完数据之后会决定是否继续执行下一个处理器。如果处理器不将任务交给线程池处理，那么整个处理流程都在同一个线程中处理。而且每个连接都有单独的<code>PipeLine</code>，工作线程可以在多个连接上下文切换，但是一个连接上下文只会被一个线程处理。</p>
<h2 id="u6838_u5FC3_u7C7B"><a href="#u6838_u5FC3_u7C7B" class="headerlink" title="核心类"></a>核心类</h2><h3 id="ConnectionCtx"><a href="#ConnectionCtx" class="headerlink" title="ConnectionCtx"></a>ConnectionCtx</h3><p>连接上下文<code>ConnectionCtx</code></p>
<pre><code>class ConnectionCtx {
    /**socket连接*/
    SocketChannel channel
    /**用于携带额外参数*/
    Object attachment
    /**处理当前连接的工作线程*/
    Worker worker
    /**连接超时时间*/
    Long timeout
    /**每个连接拥有自己的pipeline*/
    PipeLine pipeLine
}
</code></pre><h3 id="NioServer"><a href="#NioServer" class="headerlink" title="NioServer"></a>NioServer</h3><p>主线程负责监听端口，持有工作线程的引用（使用轮转法分配连接），每次有连接到来时，将连接放入工作线程的连接队列，并唤醒线程<code>selector.wakeup()</code>（线程可能阻塞在<code>selector</code>上）。</p>
<pre><code>class NioServer extends Thread {
    /**服务端的套接字通道*/
    ServerSocketChannel ssc
    /**选择器*/
    Selector selector
    /**事件总线*/
    PipeLine pipeLine
    /**工作线程列表*/
    def workers = []
    /**当前工作线程索引*/
    int index
}
</code></pre><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>工作线程，负责注册server传递过来的socket连接。主要监听读事件，管理socket，处理写操作。</p>
<pre><code>class Worker extends Thread {
    /**选择器*/
    Selector selector
    /**读缓冲区*/
    ByteBuffer buffer
    /**主线程分配的连接队列*/
    def queue = []
    /**存储按超时时间从小到大的连接*/
    TreeMap&lt;Long, ConnectionCtx&gt; ctxTreeMap

    void run() {
        while (true) {
            selector.select()
            //注册主线程发送过来的连接
            registerCtx()
            //关闭超时的连接
            closeTimeoutCtx()
            //处理事件
            dispatchEvent()
        }
    }
}
</code></pre><h2 id="u8FD0_u884C_u4E00_u4E2A_u7B80_u5355_u7684_Web__u670D_u52A1_u5668"><a href="#u8FD0_u884C_u4E00_u4E2A_u7B80_u5355_u7684_Web__u670D_u52A1_u5668" class="headerlink" title="运行一个简单的 Web 服务器"></a>运行一个简单的 Web 服务器</h2><p>我实现了一系列处理<code>HTTP</code>请求的处理器，具体实现看代码。</p>
<ul>
<li><code>LineBasedDecoder</code>：行解码器，按行解析数据</li>
<li><code>HttpRequestDecoder</code>：HTTP请求解析，目前只支持GET请求</li>
<li><code>HttpRequestHandler</code>：Http 请求处理器，目前只支持GET方法</li>
<li><code>HttpResponseHandler</code>：Http响应处理器</li>
</ul>
<p>下面是写在<code>test</code>中的例子</p>
<pre><code>class WebServerTest {
    static void main(args) {
        def pipeLine = new PipeLine()

        def readChain = new HandlerChain()
        readChain.addLast(new LineBasedDecoder())
        readChain.addLast(new HttpRequestDecoder())
        readChain.addLast(new HttpRequestHandler())
        readChain.addLast(new HttpResponseHandler())

        def closeChain = new HandlerChain()
        closeChain.addLast(new ClosedHandler())

        pipeLine.addChain(readChain)
        pipeLine.addChain(closeChain)

        NioServer nioServer = new NioServer(pipeLine)
        nioServer.start()
    }
}
</code></pre><p>另外，还可以使用配置文件<code>getty.properties</code>设置程序的运行参数。</p>
<pre><code>#用于拼接消息时使用的二进制数组的缓存区
common_buffer_size=1024
#工作线程读取tcp数据的缓存大小
worker_rcv_buffer_size=1024
#监听的端口
port=4399
#工作线程的数量
worker_num=1
#连接超时自动断开时间
timeout=900
#根目录
root=.
</code></pre><h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p><a href="https://github.com/x-hansong/Getty" target="_blank" rel="external">Getty</a>是我造的第二个小轮子，第一个是<a href="https://github.com/x-hansong/RedisHttpSession" target="_blank" rel="external">RedisHttpSession</a>。都说不要重复造轮子。这话我是认同的，但是掌握一门技术最好的方法就是实践，在没有合适项目可以使用新技术的时候，造一个简单的轮子是不错的实践手段。</p>
<p><a href="https://github.com/x-hansong/Getty" target="_blank" rel="external">Getty</a> 的缺点或者说还可以优化的点：</p>
<ol>
<li>线程的使用直接用了<code>Thread</code>类，看起来有点low。等以后水平提升了再来抽象一下。</li>
<li>目前只有读事件是异步的，写事件是同步的。未来将写事件也改为异步的。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/x-hansong/Getty" target=]]>
    </summary>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/tags/Java/"/>
    
      <category term="NIO" scheme="http://blog.xiaohansong.com/tags/NIO/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 线程池框架核心代码分析]]></title>
    <link href="http://blog.xiaohansong.com/2016/07/12/java-executor/"/>
    <id>http://blog.xiaohansong.com/2016/07/12/java-executor/</id>
    <published>2016-07-11T16:13:44.000Z</published>
    <updated>2016-08-26T13:57:53.074Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>多线程编程中，为每个任务分配一个线程是不现实的，线程创建的开销和资源消耗都是很高的。线程池应运而生，成为我们管理线程的利器。Java 通过<code>Executor</code>接口，提供了一种标准的方法将任务的提交过程和执行过程解耦开来，并用<code>Runnable</code>表示任务。</p>
<p>下面，我们来分析一下 Java 线程池框架的实现<code>ThreadPoolExecutor</code>。</p>
<p><em>下面的分析基于JDK1.7</em></p>
<h2 id="u751F_u547D_u5468_u671F"><a href="#u751F_u547D_u5468_u671F" class="headerlink" title="生命周期"></a>生命周期</h2><p><code>ThreadPoolExecutor</code>中，使用<code>CAPACITY</code>的高3位来表示运行状态，分别是：</p>
<ol>
<li>RUNNING：接收新任务，并且处理任务队列中的任务</li>
<li>SHUTDOWN：不接收新任务，但是处理任务队列的任务</li>
<li>STOP：不接收新任务，不处理任务队列，同时中断所有进行中的任务</li>
<li>TIDYING：所有任务已经被终止，工作线程数量为 0，到达该状态会执行<code>terminated()</code></li>
<li>TERMINATED：<code>terminated()</code>执行完毕</li>
</ol>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/executor_lifecycle.png" alt="状态转换图"><br><code>ThreadPoolExecutor</code>中用原子类来表示状态位</p>
<pre><code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
</code></pre><h2 id="u7EBF_u7A0B_u6C60_u6A21_u578B"><a href="#u7EBF_u7A0B_u6C60_u6A21_u578B" class="headerlink" title="线程池模型"></a>线程池模型</h2><h3 id="u6838_u5FC3_u53C2_u6570"><a href="#u6838_u5FC3_u53C2_u6570" class="headerlink" title="核心参数"></a>核心参数</h3><ul>
<li><code>corePoolSize</code>：最小存活的工作线程数量（如果设置<code>allowCoreThreadTimeOut</code>，那么该值为 0）</li>
<li><code>maximumPoolSize</code>：最大的线程数量，受限于<code>CAPACITY</code></li>
<li><code>keepAliveTime</code>：对应线程的存活时间，时间单位由TimeUnit指定</li>
<li><code>workQueue</code>：工作队列，存储待执行的任务</li>
<li><code>RejectExecutionHandler</code>：拒绝策略，线程池满后会触发</li>
</ul>
<p><strong>线程池的最大容量</strong>：<code>CAPACITY</code>中的前三位用作标志位，也就是说工作线程的最大容量为<code>(2^29)-1</code></p>
<h3 id="u56DB_u79CD_u6A21_u578B"><a href="#u56DB_u79CD_u6A21_u578B" class="headerlink" title="四种模型"></a>四种模型</h3><ul>
<li><code>CachedThreadPool</code>：一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，当需求增加时，则可以添加新的线程，线程池的规模不存在任何的限制。</li>
<li><code>FixedThreadPool</code>：一个固定大小的线程池，提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的大小将不再变化。</li>
<li><code>SingleThreadPool</code>：一个单线程的线程池，它只有一个工作线程来执行任务，可以确保按照任务在队列中的顺序来串行执行，如果这个线程异常结束将创建一个新的线程来执行任务。</li>
<li><code>ScheduledThreadPool</code>：一个固定大小的线程池，并且以延迟或者定时的方式来执行任务，类似于Timer。</li>
</ul>
<h2 id="u6267_u884C_u4EFB_u52A1_execute"><a href="#u6267_u884C_u4EFB_u52A1_execute" class="headerlink" title="执行任务 execute"></a>执行任务 execute</h2><p>核心逻辑：</p>
<ol>
<li>当前线程数量 &lt; <code>corePoolSize</code>，直接开启新的核心线程执行任务<code>addWorker(command, true)</code></li>
<li><p>当前线程数量 &gt;= <code>corePoolSize</code>，且任务加入工作队列成功</p>
<ol>
<li>检查线程池当前状态是否处于<code>RUNNING</code></li>
<li>如果否，则拒绝该任务</li>
<li>如果是，判断当前线程数量是否为 0，如果为 0，就增加一个工作线程。</li>
</ol>
</li>
<li>开启普通线程执行任务<code>addWorker(command, false)</code>，开启失败就拒绝该任务</li>
</ol>
<p>从上面的分析可以总结出线程池运行的四个阶段：</p>
<ol>
<li><code>poolSize &lt; corePoolSize</code> 且队列为空，此时会新建线程来处理提交的任务</li>
<li><code>poolSize == corePoolSize</code>，此时提交的任务进入工作队列，工作线程从队列中获取任务执行，此时队列不为空且未满。</li>
<li><code>poolSize == corePoolSize</code>，并且队列已满，此时也会新建线程来处理提交的任务，但是<code>poolSize &lt; maxPoolSize</code></li>
<li><code>poolSize == maxPoolSize</code>，并且队列已满，此时会触发拒绝策略</li>
</ol>
<h2 id="u62D2_u7EDD_u7B56_u7565"><a href="#u62D2_u7EDD_u7B56_u7565" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>前面我们提到任务无法执行会被拒绝，<code>RejectedExecutionHandler</code>是处理被拒绝任务的接口。下面是四种拒绝策略。</p>
<ul>
<li><code>AbortPolicy</code>：默认策略，终止任务，抛出RejectedException</li>
<li><code>CallerRunsPolicy</code>：在调用者线程执行当前任务，不抛异常</li>
<li><code>DiscardPolicy</code>： 抛弃策略，直接丢弃任务，不抛异常</li>
<li><code>DiscardOldersPolicy</code>：抛弃最老的任务，执行当前任务，不抛异常</li>
</ul>
<h2 id="u7EBF_u7A0B_u6C60_u4E2D_u7684_Worker"><a href="#u7EBF_u7A0B_u6C60_u4E2D_u7684_Worker" class="headerlink" title="线程池中的 Worker"></a>线程池中的 Worker</h2><p><code>Worker</code>继承了<code>AbstractQueuedSynchronizer</code>和<code>Runnable</code>，前者给<code>Worker</code>提供锁的功能，后者执行工作线程的主要方法<code>runWorker(Worker w)</code>（从任务队列捞任务执行）。Worker 引用存在<code>workers</code>集合里面，用<code>mainLock</code>守护。</p>
<pre><code>private final ReentrantLock mainLock = new ReentrantLock();
private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();
</code></pre><h3 id="u6838_u5FC3_u51FD_u6570_runWorker"><a href="#u6838_u5FC3_u51FD_u6570_runWorker" class="headerlink" title="核心函数 runWorker"></a>核心函数 runWorker</h3><p>下面是简化的逻辑，注意：每个工作线程的<code>run</code>都执行下面的函数</p>
<pre><code>final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    while (task != null || (task = getTask()) != null) {
        w.lock();
        beforeExecute(wt, task);
        task.run();
        afterExecute(task, thrown);
        w.unlock();
    }
    processWorkerExit(w, completedAbruptly);
}
</code></pre><ol>
<li>从<code>getTask()</code>中获取任务</li>
<li>锁住 worker</li>
<li>执行<code>beforeExecute(wt, task)</code>，这是<code>ThreadPoolExecutor</code>提供给子类的扩展方法</li>
<li>运行任务，如果该worker有配置了首次任务，则先执行首次任务且只执行一次。</li>
<li>执行<code>afterExecute(task, thrown);</code></li>
<li>解锁 worker</li>
<li>如果获取到的任务为 null，关闭 worker</li>
</ol>
<h2 id="u83B7_u53D6_u4EFB_u52A1_getTask"><a href="#u83B7_u53D6_u4EFB_u52A1_getTask" class="headerlink" title="获取任务 getTask"></a>获取任务 getTask</h2><p>线程池内部的任务队列是一个阻塞队列，具体实现在构造时传入。</p>
<pre><code>private final BlockingQueue&lt;Runnable&gt; workQueue;
</code></pre><p><code>getTask()</code>从任务队列中获取任务，支持阻塞和超时等待任务，四种情况会导致返回<code>null</code>，让<code>worker</code>关闭。</p>
<ol>
<li>现有的线程数量超过最大线程数量</li>
<li>线程池处于<code>STOP</code>状态</li>
<li>线程池处于<code>SHUTDOWN</code>状态且工作队列为空</li>
<li>线程等待任务超时，且线程数量超过保留线程数量</li>
</ol>
<p>核心逻辑：根据<code>timed</code>在阻塞队列上超时等待或者阻塞等待任务，等待任务超时会导致工作线程被关闭。</p>
<pre><code>timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;
Runnable r = timed ?
    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
    workQueue.take();
</code></pre><p>在以下两种情况下等待任务会超时：</p>
<ol>
<li>允许核心线程等待超时，即<code>allowCoreThreadTimeOut(true)</code></li>
<li>当前线程是普通线程，此时<code>wc &gt; corePoolSize</code></li>
</ol>
<p>工作队列使用的是<code>BlockingQueue</code>，这里就不展开了，后面再写一篇详细的分析。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>ThreadPoolExecutor</code>基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。</li>
<li><code>Executors</code>提供了四种基于<code>ThreadPoolExecutor</code>构造线程池模型的方法，除此之外，我们还可以直接继承<code>ThreadPoolExecutor</code>，重写<code>beforeExecute</code>和<code>afterExecute</code>方法来定制线程池任务执行过程。</li>
<li>使用有界队列还是无界队列需要根据具体情况考虑，工作队列的大小和线程的数量也是需要好好考虑的。</li>
<li>拒绝策略推荐使用<code>CallerRunsPolicy</code>，该策略不会抛弃任务，也不会抛出异常，而是将任务回退到调用者线程中执行。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>多线程编程中，为每个任务分配一个线程是不现实的，线程创建的开销和资源消耗都是很高的。线程池应运而生，成为]]>
    </summary>
    
      <category term="Executor" scheme="http://blog.xiaohansong.com/tags/Executor/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/tags/Java/"/>
    
      <category term="并发" scheme="http://blog.xiaohansong.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RedisHttpSession 的设计与实现]]></title>
    <link href="http://blog.xiaohansong.com/2016/05/15/RedisHttpSession/"/>
    <id>http://blog.xiaohansong.com/2016/05/15/RedisHttpSession/</id>
    <published>2016-05-15T02:49:39.000Z</published>
    <updated>2016-08-13T14:37:59.220Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/x-hansong/RedisHttpSession" target="_blank" rel="external">RedisHttpSession</a> 是我的一个 Java 开源项目，通过将 Session 存储在 Redis 中实现多服务器间共享 Session，同时这一过程是完全透明的。主要用于支持 RESTfuls API。下面我将对其核心类进行分析，阐述它的设计以及实现细节。</p>
<h2 id="RedisHttpSession"><a href="#RedisHttpSession" class="headerlink" title="RedisHttpSession"></a>RedisHttpSession</h2><p>这个类实现了<code>HttpSession</code>接口，用于替换默认的<code>HttpSession</code>实现。<code>RedisHttpSession</code>将<code>HttpSession</code>的接口方法重写了一遍，将<code>HttpSession</code>的属性存储到了 Redis 中。</p>
<p>每个<code>RedisHttpSession</code>都有一个 UUID 与之对应，该字段加上<code>session:</code>前缀作为存储在 Redis 中的键值。例如：</p>
<pre><code>localhost:63679&gt; keys *
1) &quot;session:fd9ec3cf-fb9b-4672-ade6-67a810e7db9f&quot;
2) &quot;session:cbaa057c-85a4-475d-b399-38c320e85dcc&quot;
3) &quot;session:13e030f5-de3d-458f-8d25-fd5643c40ff0&quot;
4) &quot;session:262596b3-3d13-4df1-8328-714153c1ae83&quot;
5) &quot;session:0b7d04c6-eaac-4eed-a9aa-8366f25f04f0&quot;
</code></pre><p>同时，<code>RedisHttpSession</code>中的属性是直接序列化成字节数组存储在 Redis 中的，存储在对应键中的哈希表里面。例如：</p>
<pre><code>localhost:63679&gt; hgetall session:fd9ec3cf-fb9b-4672-ade6-67a810e7db9f
1) &quot;lastAccessedTime&quot;
2) &quot;\xac\xed\x00\x05sr\x00\x0ejava.lang.Long;\x8b\xe4\x90\xcc\x8f#\xdf\x02\x00\x01J\x00\x05valuexr\x00\x10java.lang.Number\x86\xac\x95\x1d\x0b\x94\xe0\x8b\x02\x00\x00xp\x00\x00\x01T\x91\x03\&quot;\xec&quot;
3) &quot;maxInactiveInterval&quot;
4) &quot;\xac\xed\x00\x05sr\x00\x11java.lang.Integer\x12\xe2\xa0\xa4\xf7\x81\x878\x02\x00\x01I\x00\x05valuexr\x00\x10java.lang.Number\x86\xac\x95\x1d\x0b\x94\xe0\x8b\x02\x00\x00xp\x00\x00\a\b&quot;
5) &quot;creationTime&quot;
6) &quot;\xac\xed\x00\x05sr\x00\x0ejava.lang.Long;\x8b\xe4\x90\xcc\x8f#\xdf\x02\x00\x01J\x00\x05valuexr\x00\x10java.lang.Number\x86\xac\x95\x1d\x0b\x94\xe0\x8b\x02\x00\x00xp\x00\x00\x01T\x91\x03\&quot;\xb4&quot;
</code></pre><p>另外，Session 的自动过期是通过 Redis 设置键的过期时间实现的。</p>
<h2 id="RedisHttpSessionProxy"><a href="#RedisHttpSessionProxy" class="headerlink" title="RedisHttpSessionProxy"></a>RedisHttpSessionProxy</h2><p><code>RedisHttpSessionProxy</code>是<code>RedisHttpSession</code>的代理类，使用了 JDK 的动态代理。为什么要引入代理？这是基于下面的考虑做出的设计。</p>
<ol>
<li>由于 Session 存储在 Redis 中，在执行每个<code>RedisHttpSession</code>的接口方法之前都需要检查 Redis 连接是否可用。</li>
<li>访问一个已经被注销的 Session 需要抛出异常。</li>
<li>每次访问 Session 需要刷新过期时间和最后访问时间。</li>
</ol>
<p>基于上面的考虑，对于每个<code>RedisHttpSession</code>的接口方法，我们都需要进行重复的操作，因此使用动态代理对每个接口方法进行增强是最合适的。代码如下：</p>
<pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    RedisHttpSession session = (RedisHttpSession) originalObj;
    //check redis connection
    RedisConnection connection = session.getRedisConnection();
    if (!connection.isConnected()){
        connection.close();
        session.setRedisConnection(repository.getRedisConnection());
    }
    //For every methods of interface, check it valid or not
    if (session.isInvalidated()){
        throw new IllegalStateException(&quot;The HttpSession has already be invalidated.&quot;);
    } else {
        Object result =  method.invoke(originalObj, args);
        //if not invalidate method, refresh expireTime and lastAccessedTime;
        if (!method.getName().equals(&quot;invalidate&quot;)) {
            session.refresh();
            session.setLastAccessedTime(System.currentTimeMillis());
        }
        return result;
    }
}
</code></pre><h2 id="RedisHttpSessionFilter"><a href="#RedisHttpSessionFilter" class="headerlink" title="RedisHttpSessionFilter"></a>RedisHttpSessionFilter</h2><p><code>RedisHttpSessionFilter</code>作为过滤器，将请求和响应替换成<code>RedisSessionRequestWrapper</code>和<code>RedisSessionResponseWrapper</code>，利用了装饰器模式动态的给请求和响应进行增强：</p>
<ol>
<li><code>RedisSessionRequestWrapper</code>：重写了<code>getSession</code>，替换默认的<code>HttpSession</code>实现为<code>RedisHttpSession</code>。</li>
<li><code>RedisSessionResponseWrapper</code>：在响应的头部中加入<code>x-auth-token</code>字段，作为 Session 的 ID。客户端之后的请求都需要附带该字段，以便服务端识别对应的 Session。</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p><a href="https://github.com/x-hansong/RedisHttpSession" target="_blank" rel="external">RedisHttpSession</a> 利用 Filter 将请求的 Session 替换成 <code>RedisHttpSession</code>，在过滤阶段偷梁换柱，在之后对 Session 的操作都无需关心其内部实现，整个过程都是透明的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/x-hansong/RedisHttpSessi]]>
    </summary>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/tags/Java/"/>
    
      <category term="Session" scheme="http://blog.xiaohansong.com/tags/Session/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[三言两语：JVM 字节码执行实例分析]]></title>
    <link href="http://blog.xiaohansong.com/2016/04/26/java-bytecode/"/>
    <id>http://blog.xiaohansong.com/2016/04/26/java-bytecode/</id>
    <published>2016-04-26T03:11:29.000Z</published>
    <updated>2016-04-27T02:35:01.141Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>最近在看《Java 虚拟机规范》和《深入理解JVM虚拟机》，对于字节码的执行有了进一步的了解。字节码就像是汇编语言，是 JVM 的指令集。下面我们先对 JVM 执行引擎做一下简单介绍，然后根据实例分析 JVM 字节码的执行过程。包括：</p>
<ol>
<li>for 循环字节码分析</li>
<li>try-catch-finally 字节码分析</li>
</ol>
<h2 id="u8FD0_u884C_u65F6_u6808_u5E27_u7ED3_u6784"><a href="#u8FD0_u884C_u65F6_u6808_u5E27_u7ED3_u6784" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<p>在编译程序员代码的时候，栈帧中局部变量表和操作数栈的大小已经确定了，并且写入到方法表中的 <code>Code</code> 属性中。</p>
<p>在活动线程中，只有位于栈顶的栈帧才是有效的， 称为当前栈帧，与这个栈帧关联的方法称为当前方法。执行引擎运行的所有字节码指令只对当前栈帧进行操作。</p>
<h3 id="u5C40_u90E8_u53D8_u91CF_u8868"><a href="#u5C40_u90E8_u53D8_u91CF_u8868" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表的容量以变量槽（slot）为最小单位，每个 slot 保证能放下 32 位内的数据类型。虚拟机通过索引定位的方式使用局部变量表，索引值从 0 开始。值得注意的是，对于实例方法，局部变量表中第 0 位索引的 slot 默认是 <code>this</code>引用；静态方法则不是。而且为了节约内存，slot 是可以重用的。</p>
<h3 id="u64CD_u4F5C_u6570_u6808"><a href="#u64CD_u4F5C_u6570_u6808" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈的元素可以是任意的 Java 数据类型。当一个方法开始时，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈入栈操作。</p>
<h2 id="u5B9E_u4F8B_u5206_u6790"><a href="#u5B9E_u4F8B_u5206_u6790" class="headerlink" title="实例分析"></a>实例分析</h2><p>下面分析的字节码指令主要是对局部变量表和操作栈的读写。</p>
<h3 id="for__u5FAA_u73AF_u5B57_u8282_u7801_u5206_u6790"><a href="#for__u5FAA_u73AF_u5B57_u8282_u7801_u5206_u6790" class="headerlink" title="for 循环字节码分析"></a>for 循环字节码分析</h3><pre><code>void spin() {
    int i;
    for (i = 0; i &lt; 100; i++) {
        ; // Loop body is empty
    }
}
</code></pre><p>上面是一个空循环的代码，编译后的字节码如下：</p>
<pre><code>Method void spin()
    0 iconst_0 // Push int constant 0
    1 istore_1 // Store into local variable 1 (i=0)
    2 goto 8 // First time through don’t increment
    5 iinc 1 1 // Increment local variable 1 by 1 (i++)
    8 iload_1 // Push local variable 1 (i)
    9 bipush 100 // Push int constant 100
    11 if_icmplt 5 // Compare and loop if less than (i &lt; 100)
    14 return // Return void when done
</code></pre><p>相信大家看到上面的代码都是一脸懵逼，即使有注释还是不知道字节码到底做了什么操作。下面我就图解每一条指令，帮助理解。上面的代码都是对局部变量表和操作数栈的操作，所以我们的关注点就在这两个区域上。（栈是自顶向下的）</p>
<pre><code>0 iconst_0 //把常量0放入栈
+--------+--------+
| local  | stack  |
+-----------------+
|        |   0    |
+-----------------+
|        |        |
+--------+--------+

1 istore_1 //把栈顶的元素出栈，存到局部变量表索引为1的位置
+--------+--------+
| local  | stack  |
+-----------------+
|   0    |        |
+-----------------+
|        |        |
+--------+--------+

2 goto 8 //跳转到第8条指令

8 iload_1 //把局部变量表中索引为1的变量入栈
+--------+--------+
| local  | stack  |
+-----------------+
|   0    |   0    |
+-----------------+
|        |        |
+--------+--------+

9 bipush 100 //把100入栈
+--------+--------+
| local  | stack  |
+-----------------+
|   0    |   0    |
+-----------------+
|        |  100   |
+--------+--------+

11 if_icmplt 5 //出栈两个元素v1，v2，比较它们的值，当且仅当v1 &lt; v2，跳转到指令5
+--------+--------+
| local  | stack  |
+-----------------+
|   0    |        |
+-----------------+
|        |        |
+--------+--------+

5 iinc 1 1 //自增局部变量表中索引为1的值
+--------+--------+
| local  | stack  |
+-----------------+
|   1    |        |
+-----------------+
|        |        |
+--------+--------+

//进行下次循环直到指令11不满足，到达指令14
14 return //清空栈，执行引擎把控制权交换给调用者。
+--------+--------+
| local  | stack  |
+-----------------+
|   100  |        |
+-----------------+
|        |        |
+--------+--------+
</code></pre><p>以上就是<code>for</code>循环字节码执行的过程。可以发现，所有指令都是围绕者局部变量表和操作数栈在操作。</p>
<blockquote>
<p><strong>解惑</strong><br>指令<code>iconst_0</code>,<code>iload_1</code>的命名解读<br>第一个<code>i</code>代表这是对int数据类型进行的操作<br><code>const</code>,<code>load</code>是操作码<br><code>0</code>,<code>1</code>是隐含的操作数<br>上面的两个指令等价于<code>iconst 0</code>,<code>iload 1</code><br><em>详细的字节码解释查阅《JVM 虚拟机规范》</em></p>
</blockquote>
<h3 id="try-catch-finally__u5B57_u8282_u7801_u5206_u6790"><a href="#try-catch-finally__u5B57_u8282_u7801_u5206_u6790" class="headerlink" title="try-catch-finally 字节码分析"></a>try-catch-finally 字节码分析</h3><pre><code>static int inc(){
    int x;
    try {
        x = 1;
        return x;
    } catch (Exception e){
        x = 2;
        return x;
    } finally {
        x = 3;
    }
}
</code></pre><p>下面是它的字节码，这次我就不画图了，里面的命令跟上面的类似。</p>
<pre><code>static int inc();
descriptor: ()I
flags: ACC_STATIC
Code:
  stack=1, locals=4, args_size=0
     0: iconst_1  //try 块中的 x = 1;
     1: istore_0  //保存栈顶元素到局部变量表中索引为 0 的 slot 中
     2: iload_0   //加载局部变量表中索引为 0 的值到栈中
     3: istore_1  //保存栈顶元素到局部变量表中索引为 1 的 slot 中
     4: iconst_3  //finally 块中的 x = 3;
     5: istore_0  //保存栈顶元素到局部变量表中索引为 0 的 slot 中，x 的值存在这里。
     6: iload_1  //加载局部变量表中索引为 1 的值到栈中
     7: ireturn  //返回栈顶元素，即 x = 1;正常情况下函数运行到这里就结束了，如果出现异常根据异常表跳转到指定的位置
     8: astore_1 //给 catch 块中定义的 Exception e 赋值，存储在 slot1 中。
     9: iconst_2 //catch 块中的 x = 2;
    10: istore_0
    11: iload_0
    12: istore_2
    13: iconst_3 //finally 块中的 x = 3;
    14: istore_0
    15: iload_2
    16: ireturn //此时返回的是 slot2 中的值，即 x = 2
    17: astore_3 //如果出现不属于 java.lang.Exception 及其子类的异常，才会根据异常表中的规则跳转到这里。
    18: iconst_3 //finally 块中的 x = 3;
    19: istore_0
    20: aload_3 //将异常加载到栈顶，
    21: athrow //抛出栈顶的异常
  Exception table:
     from    to  target type
         0     4     8   Class java/lang/Exception
         0     4    17   any
         8    13    17   any
</code></pre><ol>
<li>字节码中 0 ~ 4 行将整数 1 赋值为变量 x，x 存储在 slot0 中，并且将 x 的值拷贝一份放到 slot1。如果没有出现异常，继续走到 5 ~ 7 行，将 x 赋值为 3，然后读取 slot1 中的值到栈顶，最后<code>ireturn</code>返回栈顶的值，方法结束。</li>
<li>如果出现异常，PC 寄存器指针转到第 8 行，第 8 ~ 16 行所做的事情就是将 2 赋值给 x，然后保存 x 的拷贝，最后将 x 赋值为 3。方法返回前将 x 的拷贝 2 读取到栈顶。</li>
<li>如果在 0 ~ 4，8 ~ 13 行中出现其他异常，则跳转到第 17 行执行，先同样执行<code>finally</code>块中的<code>x = 3</code>，最后抛出异常，方法结束。</li>
</ol>
<p>可以看到，Java 的异常处理是通过异常表的方式来决定代码执行的路径。而<code>finally</code>的实现是通过在每个路径的最后加入<code>finally</code>块中的字节码实现的。</p>
<p><em>参考资料</em><br>《Java 虚拟机规范》<br>《深入理解JVM虚拟机》</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>最近在看《Java 虚拟机规范》和《深入理解JVM虚拟机》，对于字节码的执行有了进一步的了解。字节码就像]]>
    </summary>
    
      <category term="JVM" scheme="http://blog.xiaohansong.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/tags/Java/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译】JVM 进行线程同步背后的原理]]></title>
    <link href="http://blog.xiaohansong.com/2016/04/23/JVM-Synchronized/"/>
    <id>http://blog.xiaohansong.com/2016/04/23/JVM-Synchronized/</id>
    <published>2016-04-23T02:50:37.000Z</published>
    <updated>2016-08-26T13:57:41.590Z</updated>
    <content type="html"><![CDATA[<p><em>本文翻译自<a href="http://www.javaworld.com/article/2076971/java-concurrency/how-the-java-virtual-machine-performs-thread-synchronization.html" target="_blank" rel="external">How the Java virtual machine performs thread synchronization</a>，内容略有删改</em></p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>所有的 Java 程序都会被翻译为包含字节码的 class 文件，字节码是 JVM 的机器语言。这篇文章将阐述 JVM 是如何处理线程同步以及相关的字节码。</p>
<h2 id="u7EBF_u7A0B_u548C_u5171_u4EAB_u6570_u636E"><a href="#u7EBF_u7A0B_u548C_u5171_u4EAB_u6570_u636E" class="headerlink" title="线程和共享数据"></a>线程和共享数据</h2><p>Java 的一个优点就是在语言层面支持多线程，这种支持集中在协调多线程对数据的访问上。</p>
<p>JVM 将运行时数据划分为几个区域：一个或多个栈，一个堆，一个方法区。</p>
<p>在 JVM 中，每个线程拥有一个栈，其他线程无法访问，里面的数据包括：局部变量，函数参数，线程调用的方法的返回值。栈里面的数据只包含原生数据类型和对象引用。在 JVM 中，不可能将实际对象的拷贝放入栈。所有对象都在堆里面。</p>
<p>JVM 只有一个堆，所有线程都共享它。堆中只包含对象，把单独的原生类型或者对象引用放入堆也是不可能的，除非它们是对象的一部分。数组也在堆中，包括原生类型的数组，因为在 Java 中，数组也是对象。</p>
<p>除了栈和堆，另一个存放数据的区域就是方法区了，它包含程序中使用到的所有类（静态）变量。方法区类似于栈，也只包含原生类型和对象引用，但是又跟栈不同，方法区中类变量是线程共享的。</p>
<h2 id="u5BF9_u8C61_u9501_u548C_u7C7B_u9501"><a href="#u5BF9_u8C61_u9501_u548C_u7C7B_u9501" class="headerlink" title="对象锁和类锁"></a>对象锁和类锁</h2><p>正如前面所说，JVM 中的两个区域包含线程共享的数据，分别是：</p>
<ol>
<li><strong>堆</strong>：包含所有对象</li>
<li><strong>方法区</strong>：包含所有类变量</li>
</ol>
<p>如果多个线程需要同时使用同一个对象或者类变量，它们对数据的访问必须被恰当地控制。否则，程序会产生不可预测的行为。</p>
<p>为了协调多个线程对共享数据的访问，JVM 给每个对象和类关联了一个锁。锁就像是任意时间点只有一个线程能够拥有的特权。如果一个线程想要锁住一个特定的对象或者类，它需要向 JVM 请求锁。线程向 JVM 请求锁之后，可能很快就拿到，或者过一会就拿到，也可能永远拿不到。当线程不需要锁之后，它把锁还给 JVM。如果其他线程需要这个锁，JVM 会交给该线程。</p>
<p>类锁的实现其实跟对象锁是一样的。当 JVM 加载类文件的时候，它会创建一个对应类<code>java.lang.Class</code>对象。当你锁住一个类的时候，你实际上是锁住了这个类的<code>Class</code>对象。</p>
<p>线程访问对象实例或者类变量的时候不需要获取锁。但是如果一个线程获取了一个锁，其他线程不能访问被锁住的数据，直到拥有锁的线程释放它。</p>
<h2 id="u7BA1_u7A0B"><a href="#u7BA1_u7A0B" class="headerlink" title="管程"></a>管程</h2><p>JVM 使用锁和管程协作。管程监视一段代码，保证一个时间点内只有一个线程能执行这段代码。</p>
<p>每个管程与一个对象引用关联。当线程到达管程监视代码段的第一条指令时，线程必须获取关联对象的锁。线程不能执行这段代码直到它得到了锁。一旦它得到了锁，线程可以进入被保护的代码段。</p>
<p>当线程离开被保护的代码块，不管是如何离开的，它都会释放关联对象的锁。</p>
<h2 id="u591A_u6B21_u9501_u5B9A"><a href="#u591A_u6B21_u9501_u5B9A" class="headerlink" title="多次锁定"></a>多次锁定</h2><p>一个线程被允许锁定一个对象多次。对于每个对象，JVM 维护了一个锁的计数器。没有被锁的对象计数为 0。当一个线程第一次获取锁，计数器自增变为 1。每次这个线程（已经得到锁的线程）请求同一个对象的锁，计数器都会自增。每次线程释放锁，计数器都会自减。当计数器变为 0 时，锁才被释放，可以给别的线程使用。</p>
<h2 id="u540C_u6B65_u5757"><a href="#u540C_u6B65_u5757" class="headerlink" title="同步块"></a>同步块</h2><p>在 Java 语言的术语中，协调多个线程访问共享数据被称为<strong>同步（synchronization）</strong>。Java 提供了两种内建的方式来同步对数据的访问：</p>
<ol>
<li>同步语句</li>
<li>同步方法</li>
</ol>
<h3 id="u540C_u6B65_u8BED_u53E5"><a href="#u540C_u6B65_u8BED_u53E5" class="headerlink" title="同步语句"></a>同步语句</h3><p>为了创建同步语句，你需要使用<code>synchronized</code>关键字，括号里面是同步的对象引用，如下所示：</p>
<pre><code>class KitchenSync {
    private int[] intArray = new int[10];
    void reverseOrder() {
        synchronized (this) {
            int halfWay = intArray.length / 2;
            for (int i = 0; i &lt; halfWay; ++i) {
                int upperIndex = intArray.length - 1 - i;
                int save = intArray[upperIndex];
                intArray[upperIndex] = intArray[i];
                intArray[i] = save;
            }
        }
    }
}
</code></pre><p>在上面的例子中，被同步块包含的语句不会被执行，直到线程得到<code>this</code>引用的对象锁。如果不是锁住<code>this</code>引用，而是锁住其他对象，在线程执行同步块语句之前，它需要获得该对象的锁。</p>
<p>有两个字节码<code>monitorenter</code>和<code>monitorexit</code>，被用来<strong>同步方法中的同步块</strong>。</p>
<table>
<thead>
<tr>
<th>字节码</th>
<th>操作数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>monitorenter</td>
<td>无</td>
<td>取出对象引用，请求与对象引用关联的锁</td>
</tr>
<tr>
<td>monitorexit</td>
<td>无</td>
<td>取出对象引用，释放与对象引用关联的锁</td>
</tr>
</tbody>
</table>
<p>当<code>monitorenter</code>被 JVM 执行时，它请求栈顶对象引用关联的锁。如果该线程已经拥有该对象的锁，计数器自增。每次<code>monitorexit</code>被执行，计数器自减。当计数器变为 0 时，该锁被释放。</p>
<p><strong>注意：</strong>当同步块中抛出异常时，<code>catch</code>语句保证对象锁被释放。不管同步块是如何退出的，JVM 保证线程会释放锁。</p>
<h3 id="u540C_u6B65_u65B9_u6CD5"><a href="#u540C_u6B65_u65B9_u6CD5" class="headerlink" title="同步方法"></a>同步方法</h3><p>为了同步整个方法，你只需要在方法声明前面加上<code>synchronized</code>关键字。</p>
<pre><code>class HeatSync {
    private int[] intArray = new int[10];
    synchronized void reverseOrder() {
        int halfWay = intArray.length / 2;
        for (int i = 0; i &lt; halfWay; ++i) {
            int upperIndex = intArray.length - 1 - i;
            int save = intArray[upperIndex];
            intArray[upperIndex] = intArray[i];
            intArray[i] = save;
        }
    }
}
</code></pre><p>JVM 不会使用特殊的字节码来调用同步方法。当 JVM 解析方法的符号引用时，它会判断方法是不是同步的。如果是，JVM 要求线程在调用之前请求锁。对于实例方法，JVM 要求得到该实例对象的锁。对于类方法，JVM 要求得到类锁。在同步方法完成之后，不管它是正常返回还是抛出异常，锁都会被释放。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>本文翻译自<a href="http://www.javaworld.com/article/2076971/java-concurrency/how-the-java-virtual-machine-performs-thread-synchronization.]]>
    </summary>
    
      <category term="synchronized" scheme="http://blog.xiaohansong.com/tags/synchronized/"/>
    
      <category term="并发" scheme="http://blog.xiaohansong.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[三言两语：SQL 连接（join）]]></title>
    <link href="http://blog.xiaohansong.com/2016/04/14/sql-join/"/>
    <id>http://blog.xiaohansong.com/2016/04/14/sql-join/</id>
    <published>2016-04-14T13:52:59.000Z</published>
    <updated>2016-04-23T02:57:58.464Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文将从连接的理论和语法讲起，结合具体的例子，详细分析 SQL 连接。</p>
<p>之前对数据库的连接操作似懂非懂，大概知道是什么东西，但是面试笔试的时候被虐成渣，讲不清连接到底是什么。吃一堑，长一智。这就是所谓的似懂非懂， 只是单纯的看书是没用的，只有亲自动手做实验才能彻底理解什么是连接。</p>
<h2 id="u8FDE_u63A5_u7C7B_u578B_u4E0E_u6761_u4EF6"><a href="#u8FDE_u63A5_u7C7B_u578B_u4E0E_u6761_u4EF6" class="headerlink" title="连接类型与条件"></a>连接类型与条件</h2><p>SQL 中每一种连接操作都包括一个连接类型和连接条件。</p>
<h3 id="u8FDE_u63A5_u7C7B_u578B"><a href="#u8FDE_u63A5_u7C7B_u578B" class="headerlink" title="连接类型"></a>连接类型</h3><p>连接类型决定了如何处理连接条件不匹配的记录。</p>
<table>
<thead>
<tr>
<th>连接类型</th>
<th>返回结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>inner join</td>
<td>只包含左右表中满足连接条件的记录</td>
</tr>
<tr>
<td>left outer join</td>
<td>在内连接的基础上，加入左表中不与右表匹配的记录，剩余字段赋值为null</td>
</tr>
<tr>
<td>right outer join</td>
<td>在内连接的基础上，加入右表中不与左表匹配的记录，剩余字段赋值为null</td>
</tr>
<tr>
<td>full outer join</td>
<td>左外连接和右外连接的组合。</td>
</tr>
<tr>
<td>cross join</td>
<td>等价于没有连接条件的内连接（即产生笛卡尔乘积）</td>
</tr>
</tbody>
</table>
<p>关键字 inner 和 outer 是可选的，因为根据连接类型的其余内容我们可以判断出连接是内连接和外连接。简单来说就是：除了单独的<code>join</code>是内连接，其他都是外连接。</p>
<p>对外连接来说，连接条件是<strong>必须的</strong>；但对内连接来说，连接条件是<strong>可选的</strong>（如果省略，将产生笛卡尔积）。</p>
<h3 id="u8FDE_u63A5_u6761_u4EF6"><a href="#u8FDE_u63A5_u6761_u4EF6" class="headerlink" title="连接条件"></a>连接条件</h3><p>连接条件决定两个表中哪些记录互相匹配以及连接结果中出现哪些属性。</p>
<table>
<thead>
<tr>
<th>连接条件</th>
<th>修饰位置</th>
<th>语义</th>
</tr>
</thead>
<tbody>
<tr>
<td>natural</td>
<td>连接类型之前</td>
<td>连接两个表之间的所有公共字段相等的记录，合并相同的列</td>
</tr>
<tr>
<td>on &lt;谓词&gt;</td>
<td>连接类型之后</td>
<td>连接符合谓词的记录，不合并相同的列</td>
</tr>
<tr>
<td>using(A1, A2,…,An)</td>
<td>连接类型之后</td>
<td>natural 语义的子集，只连接两个表中（A1,A2,..An)的公共字段，合并相同的列</td>
</tr>
</tbody>
</table>
<p>从上面的描述可以看到：连接操作是连接类型和连接条件的组合，只有在这个前提下才能真正的理解连接的功能。</p>
<h2 id="FQA"><a href="#FQA" class="headerlink" title="FQA"></a>FQA</h2><p>例子中使用到的表</p>
<p><strong>student</strong></p>
<pre><code>+----+--------+
| id | name   |
+----+--------+
|  1 | 张三   |
|  2 | 李四   |
|  3 | 王二   |
|  4 | 初一   |
|  5 | 初二   |
+----+--------+
</code></pre><p><strong>teacher</strong></p>
<pre><code>+----+-----------+
| id | name      |
+----+-----------+
|  1 | 王老师    |
|  2 | 李老师    |
|  3 | 张老师    |
|  4 | 肖老师    |
|  5 | NULL      |
|  6 | 陈老师    |
+----+-----------+
</code></pre><p><strong>course</strong></p>
<pre><code>+----+--------+------+
| id | cname  | tid  |
+----+--------+------+
|  1 | 数学   |    1 |
|  2 | 英语   |    2 |
|  3 | 语文   |    3 |
|  4 | 体育   |    1 |
|  5 | 物理   | NULL |
+----+--------+------+
</code></pre><p><strong>student_course</strong></p>
<pre><code>+-----+-----+
| sid | cid |
+-----+-----+
|   1 |   1 |
|   1 |   2 |
|   1 |   3 |
|   2 |   1 |
|   2 |   4 |
|   3 |   5 |
|   3 |   6 |
|   4 |   4 |
+-----+-----+
</code></pre><h3 id="u5185_u8FDE_u63A5_u4E4B_u540E_u7684_u7ED3_u679C_u96C6_u6570_u91CF_u662F_u591A_u5C11_uFF1F_u7B49_u4E8E_u5DE6_u8868_u6216_u8005_u53F3_u8868_u4E2D_u8BB0_u5F55_u7684_u6570_u91CF_u5417_uFF1F"><a href="#u5185_u8FDE_u63A5_u4E4B_u540E_u7684_u7ED3_u679C_u96C6_u6570_u91CF_u662F_u591A_u5C11_uFF1F_u7B49_u4E8E_u5DE6_u8868_u6216_u8005_u53F3_u8868_u4E2D_u8BB0_u5F55_u7684_u6570_u91CF_u5417_uFF1F" class="headerlink" title="内连接之后的结果集数量是多少？等于左表或者右表中记录的数量吗？"></a>内连接之后的结果集数量是多少？等于左表或者右表中记录的数量吗？</h3><p>内连接<code>teacher</code> <code>course</code>的结果</p>
<pre><code>select * from teacher inner join course on teacher.id = course.tid;
+----+-----------+----+--------+------+
| id | name      | id | cname  | tid  |
+----+-----------+----+--------+------+
|  1 | 王老师    |  1 | 数学   |    1 |
|  2 | 李老师    |  2 | 英语   |    2 |
|  3 | 张老师    |  3 | 语文   |    3 |
|  1 | 王老师    |  4 | 体育   |    1 |
+----+-----------+----+--------+------+
</code></pre><p>可以发现，王老师同时教数学和体育，因此左表中王老师匹配了右表中两条记录，物理没有老师教，所以没有出现在结果中。说明<strong>内连接的结果集数量等于左右表中匹配记录的数量</strong>。</p>
<h3 id="u5DE6_u8FDE_u63A5_u4E4B_u540E_u7684_u7ED3_u679C_u96C6_u6570_u91CF_u662F_u591A_u5C11_uFF1F_u7B49_u4E8E_u5DE6_u8868_u7684_u8BB0_u5F55_u6570_u91CF_u5417_uFF1F"><a href="#u5DE6_u8FDE_u63A5_u4E4B_u540E_u7684_u7ED3_u679C_u96C6_u6570_u91CF_u662F_u591A_u5C11_uFF1F_u7B49_u4E8E_u5DE6_u8868_u7684_u8BB0_u5F55_u6570_u91CF_u5417_uFF1F" class="headerlink" title="左连接之后的结果集数量是多少？等于左表的记录数量吗？"></a>左连接之后的结果集数量是多少？等于左表的记录数量吗？</h3><p>左连接<code>teacher</code> <code>course</code>的结果</p>
<pre><code>select * from teacher left join course on teacher.id = course.tid;
+----+-----------+------+--------+------+
| id | name      | id   | cname  | tid  |
+----+-----------+------+--------+------+
|  1 | 王老师    |    1 | 数学   |    1 |
|  2 | 李老师    |    2 | 英语   |    2 |
|  3 | 张老师    |    3 | 语文   |    3 |
|  1 | 王老师    |    4 | 体育   |    1 |
|  4 | 肖老师    | NULL | NULL   | NULL |
|  5 | NULL      | NULL | NULL   | NULL |
|  6 | 陈老师    | NULL | NULL   | NULL |
+----+-----------+------+--------+------+
</code></pre><p>可以看到，没有教授课程的老师也出现在结果中，对应的字段都为NULL。说明结果集的数量并不等于左表记录的数量，因为两个表直接不是一对一的关系。其数量应该等于<strong>内连接的结果集数量加上左表中不匹配的记录数量</strong>。</p>
<h3 id="Mysql__u4E2D_u4E0D_u652F_u6301full_outer_join"><a href="#Mysql__u4E2D_u4E0D_u652F_u6301full_outer_join" class="headerlink" title="Mysql 中不支持full outer join"></a>Mysql 中不支持<code>full outer join</code></h3><p>可以通过<code>union</code>操作模拟。</p>
<pre><code>SELECT * FROM teacher
LEFT JOIN course ON teacher.id = course.tid
UNION
SELECT * FROM teacher
RIGHT JOIN course ON teacher.id = course.id;

+------+-----------+------+--------+------+
| id   | name      | id   | cname  | tid  |
+------+-----------+------+--------+------+
|    1 | 王老师    |    1 | 数学   |    1 |
|    2 | 李老师    |    2 | 英语   |    2 |
|    3 | 张老师    |    3 | 语文   |    3 |
|    1 | 王老师    |    4 | 体育   |    1 |
|    4 | 肖老师    | NULL | NULL   | NULL |
|    5 | NULL      | NULL | NULL   | NULL |
|    6 | 陈老师    | NULL | NULL   | NULL |
|    4 | 肖老师    |    4 | 体育   |    1 |
|    5 | NULL      |    5 | 物理   | NULL |
+------+-----------+------+--------+------+
</code></pre><h3 id="u591A_u8868_u8FDE_u63A5_u95EE_u9898"><a href="#u591A_u8868_u8FDE_u63A5_u95EE_u9898" class="headerlink" title="多表连接问题"></a>多表连接问题</h3><p>考虑查出所有学生的课程的记录</p>
<pre><code>select * from student
left join student_course on student.id = student_course.sid
left join course on student_course.cid = course.id;

+----+--------+------+------+------+--------+------+
| id | name   | sid  | cid  | id   | cname  | tid  |
+----+--------+------+------+------+--------+------+
|  1 | 张三   |    1 |    1 |    1 | 数学   |    1 |
|  2 | 李四   |    2 |    1 |    1 | 数学   |    1 |
|  1 | 张三   |    1 |    2 |    2 | 英语   |    2 |
|  1 | 张三   |    1 |    3 |    3 | 语文   |    3 |
|  2 | 李四   |    2 |    4 |    4 | 体育   |    1 |
|  4 | 初一   |    4 |    4 |    4 | 体育   |    1 |
|  3 | 王二   |    3 |    5 |    5 | 物理   | NULL |
|  3 | 王二   |    3 |    6 | NULL | NULL   | NULL |
|  5 | 初二   | NULL | NULL | NULL | NULL   | NULL |
+----+--------+------+------+------+--------+------+
</code></pre><p>用学生表连接中间表，再连接课程表可以得到结果。连接操作是针对两个表之间的，所以上面的结果是从左到右，两两连接得到的。</p>
<p><strong>如果你有更多关于连接的问题，或者发现文章中的错误，欢迎留言交流</strong></p>
<p><em>参考资料</em><br>《数据库系统概念》</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文将从连接的理论和语法讲起，结合具体的例子，详细分析 SQL 连接。</p>
<p>之前对数据库的连接]]>
    </summary>
    
      <category term="MySQL" scheme="http://blog.xiaohansong.com/tags/MySQL/"/>
    
      <category term="join" scheme="http://blog.xiaohansong.com/tags/join/"/>
    
      <category term="数据库" scheme="http://blog.xiaohansong.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hiho 1289 403 Forbidden（微软编程题）]]></title>
    <link href="http://blog.xiaohansong.com/2016/04/09/forbidden/"/>
    <id>http://blog.xiaohansong.com/2016/04/09/forbidden/</id>
    <published>2016-04-09T08:10:40.000Z</published>
    <updated>2016-04-09T08:12:09.131Z</updated>
    <content type="html"><![CDATA[<h2 id="u9898_u610F"><a href="#u9898_u610F" class="headerlink" title="题意"></a>题意</h2><pre><code>allow 1.2.3.4/30
deny 1.1.1.1
allow 127.0.0.1
allow 123.234.12.23/3
deny 0.0.0.0/0
</code></pre><p>输入 ip 按顺序匹配规则，优先匹配前面的规则，如果没有规则可以匹配则视为合法。注意：掩码为 0 的时候表示匹配所有 ip。</p>
<h2 id="u601D_u8DEF"><a href="#u601D_u8DEF" class="headerlink" title="思路"></a>思路</h2><p>一开始做的时候用遍历匹配的方法，直接超时了。后来才想到用字典树的方法来做，这道题本质上是一道字典树变形。</p>
<h3 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h3><pre><code>class Node {
        byte flag;//0代表普通节点，1代表允许规则终点，2代表禁止规则终点
        int seq;//规则顺序
        Node[] next = new Node[2];

        Node(byte flag){
            this.flag = flag;
    }
}
</code></pre><h3 id="u5EFA_u6811"><a href="#u5EFA_u6811" class="headerlink" title="建树"></a>建树</h3><ol>
<li>seq 自增，记录规则的顺序</li>
<li>解析掩码：如果输入的 ip 没有 mask，则默认 <code>mask = 32</code></li>
<li>把ip地址转化为二进制形式</li>
<li>插入节点：如果该节点不存在，则新建；否则沿着节点往下走</li>
<li>设置节点的 flag 和 seq：后面的规则不能覆盖前面的规则，所以要查看当前节点是否为某规则的终点。</li>
</ol>
<p>代码如下：</p>
<pre><code>public void insert(String ip, byte flag) {
    seq++;
    int mask = 32;
    int index = ip.indexOf(&apos;/&apos;);
    //检测是否有掩码
    if (index != -1) {
        mask = Integer.parseInt(ip.substring(index + 1));
    } else {
        index = ip.length();
    }
     //把ip地址转化为二进制形式
    String binary = toBinary(ip.substring(0, index));

    char[] binarys = binary.toCharArray();

    Node node = root;

    for (int i = 0; i &lt; mask; i++) {
        int pos = binarys[i] - &apos;0&apos;;
        if (node.next[pos] == null){
            node.next[pos] = new Node((byte) 0);
        }
        node = node.next[pos];
    }
    //后面的规则不能覆盖前面的
    if (node.flag == 0){
        node.flag = flag;
    }
    if (node.seq == 0) {
        node.seq = seq;
    }
}
</code></pre><h3 id="u5339_u914D"><a href="#u5339_u914D" class="headerlink" title="匹配"></a>匹配</h3><ol>
<li>把ip地址转化为二进制形式</li>
<li>遍历字典树</li>
<li>如果当前节点为规则的终点，则需要比较该规则的顺序，seq 小的优先匹配</li>
<li>遍历完字典树之后，isAllow 的值就是该 ip 最先匹配到的规则所规定的权限</li>
</ol>
<p>代码如下：</p>
<pre><code>public boolean isAllow(String ip){
    String binary = toBinary(ip);
    char[] binarys = binary.toCharArray();

    Node node = root;
    int seq = Integer.MAX_VALUE;
    boolean isAllow = true;
    int i = 0;
    int pos = 0;
    while (node != null){
        //字典树最多会有33个节点，而ip的二进制最多只有32位
        //另一种避免判断的方法是在ip的二进制后面补一个0
        if (i &lt; binarys.length){
            pos = binarys[i] - &apos;0&apos;;
        }
        if (node.flag == 1){
            if (node.seq &lt; seq){
                isAllow = true;
                seq = node.seq;
            }
        } else if (node.flag == 2){
            if (node.seq &lt; seq){
                isAllow = false;
                seq = node.seq;
            }
        } else {
            //flag=0说明是普通节点，直接跳过即可。
        }
        node = node.next[pos];
        i++;
    }
    return isAllow;
}
</code></pre><p><em><a href="https://github.com/x-hansong/JavaCodes/blob/master/src/main/java/com/contest/Forbidden.java" target="_blank" rel="external">完整代码</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u9898_u610F"><a href="#u9898_u610F" class="headerlink" title="题意"></a>题意</h2><pre><code>allow 1.2.3.4/30
deny 1.1.1.1
allow 127.0.0.]]>
    </summary>
    
      <category term="Trie" scheme="http://blog.xiaohansong.com/tags/Trie/"/>
    
      <category term="字典树" scheme="http://blog.xiaohansong.com/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
      <category term="解题报告" scheme="http://blog.xiaohansong.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java String 对 null 对象的容错处理]]></title>
    <link href="http://blog.xiaohansong.com/2016/03/13/null-in-java-string/"/>
    <id>http://blog.xiaohansong.com/2016/03/13/null-in-java-string/</id>
    <published>2016-03-13T09:10:24.000Z</published>
    <updated>2016-04-26T03:40:32.990Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>最近在读《Thinking in Java》，看到这样一段话：</p>
<blockquote>
<p>Primitives that are fields in a class are automatically initialized to zero, as noted in the Everything Is an Object chapter. But the object references are initialized to null, and if you try to call methods for any of them, you’ll get an exception-a runtime error. Conveniently, you can still print a null reference without throwing an exception.<br>大意是：原生类型会被自动初始化为 0，但是对象引用会被初始化为 null，如果你尝试调用该对象的方法，就会抛出空指针异常。通常，你可以打印一个 null 对象而不会抛出异常。</p>
</blockquote>
<p>第一句相信大家都会容易理解，这是类型初始化的基础知识，但是第二句就让我很疑惑：为什么打印一个 null 对象不会抛出异常？带着这个疑问，我开始了解惑之旅。下面我将详细阐述我解决这个问题的思路，并且深入 JDK 源码找到问题的答案。</p>
<h2 id="u89E3_u51B3_u95EE_u9898_u7684_u8FC7_u7A0B"><a href="#u89E3_u51B3_u95EE_u9898_u7684_u8FC7_u7A0B" class="headerlink" title="解决问题的过程"></a>解决问题的过程</h2><p>可以发现，其实这个问题有几种情况，所以我们分类讨论各种情况，看最后能不能得到答案。</p>
<p>首先，我们把这个问题分解为三个小问题，逐一解决。</p>
<h3 id="u7B2C_u4E00_u4E2A_u95EE_u9898"><a href="#u7B2C_u4E00_u4E2A_u95EE_u9898" class="headerlink" title="第一个问题"></a>第一个问题</h3><p>直接打印 null 的 String 对象，会得到什么结果？</p>
<pre><code>String s = null;
System.out.print(s);
</code></pre><p>运行的结果是</p>
<pre><code>null
</code></pre><p>果然如书上说的没有抛出异常，而是打印了<code>null</code>。显然问题的线索在于<code>print</code>函数的源码中。我们找到<code>print</code>的源码：</p>
<pre><code>public void print(String s) {
    if (s == null) {
        s = &quot;null&quot;;
    }
    write(s);
}
</code></pre><p>看到源码才发现原来就只是加了一句判断而已，简单粗暴，可能你对 JDK 的简单实现有点失望了。放心，第一个问题只是开胃菜而已，大餐还在后面。</p>
<h3 id="u7B2C_u4E8C_u4E2A_u95EE_u9898"><a href="#u7B2C_u4E8C_u4E2A_u95EE_u9898" class="headerlink" title="第二个问题"></a>第二个问题</h3><p>打印一个 null 的非 String 对象，例如说 Integer：</p>
<pre><code>Integer i = null;
System.out.print(i);
</code></pre><p>运行的结果不出意料：</p>
<pre><code>null
</code></pre><p>我们再去看看<code>print</code>的源码：</p>
<pre><code>public void print(Object obj) {
    write(String.valueOf(obj));
}
</code></pre><p>有点不一样的了，看来秘密藏在<code>valueOf</code>里面。</p>
<pre><code>public static String valueOf(Object obj) {
    return (obj == null) ? &quot;null&quot; : obj.toString();
}
</code></pre><p>看到这里，我们终于发现了打印 null 对象不会抛出异常的秘密。<code>print</code>方法对 String 对象和非 String 对象分开进行处理。</p>
<ol>
<li><strong>String 对象</strong>：直接判断是否为 null，如果为 null 给 null 对象赋值为<code>&quot;null&quot;</code>。</li>
<li><strong>非 String 对象</strong>：通过调用<code>String.valueOf</code>方法，如果是 null 对象，就返回<code>&quot;null&quot;</code>，否则调用对象的<code>toString</code>方法。</li>
</ol>
<p>通过上面的处理，可以保证打印 null 对象不会出错。</p>
<p>到这里，本文就应该结束了。<br>什么？说好的大餐呢？上面还不够塞牙缝呢。<br>开玩笑啦。下面我们来探讨第三个问题。</p>
<h3 id="u7B2C_u4E09_u4E2A_u95EE_u9898_uFF08_u9690_u85CF_u7684_u5927_u9910_uFF09"><a href="#u7B2C_u4E09_u4E2A_u95EE_u9898_uFF08_u9690_u85CF_u7684_u5927_u9910_uFF09" class="headerlink" title="第三个问题（隐藏的大餐）"></a>第三个问题（隐藏的大餐）</h3><p>null 对象与字符串拼接会得到什么结果？</p>
<pre><code>String s = null;
s = s + &quot;!&quot;;
System.out.print(s);
</code></pre><p>结果可能你也猜到了：</p>
<pre><code>null!
</code></pre><p>为什么呢？跟踪代码运行可以发现，这回跟<code>print</code>没有什么关系。但是上面的代码就调用了<code>print</code>函数，不是它会是谁呢？<code>+</code>的嫌疑最大，但是<code>+</code>又不是函数，我们怎么看到它的源代码？这种情况，唯一的解释就是编译器动了手脚，天网恢恢，疏而不漏，找不到源代码，我们可以去看看编译器生成的字节码。</p>
<pre><code>L0
 LINENUMBER 27 L0
 ACONST_NULL
 ASTORE 1
L1
 LINENUMBER 28 L1
 NEW java/lang/StringBuilder
 DUP
 INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V
 ALOAD 1
 INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
 LDC &quot;!&quot;
 INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
 INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
 ASTORE 1
L2
 LINENUMBER 29 L2
 GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
 ALOAD 1
 INVOKEVIRTUAL java/io/PrintStream.print (Ljava/lang/String;)V
</code></pre><p>看了上面的字节码是不是一头雾水？这里我们就要扯开话题，来侃侃<code>+</code>字符串拼接的原理了。</p>
<p>编译器对字符串相加会进行优化，首先实例化一个<code>StringBuilder</code>，然后把相加的字符串按顺序<code>append</code>，最后调用<code>toString</code>返回一个<code>String</code>对象。不信你们看看上面的字节码是不是出现了<code>StringBuilder</code>。详细的解释参考这篇文章 <a href="http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/" target="_blank" rel="external">Java细节：字符串的拼接</a>。</p>
<pre><code>String s = &quot;a&quot; + &quot;b&quot;;
//等价于
StringBuilder sb = new StringBuilder();
sb.append(&quot;a&quot;);
sb.append(&quot;b&quot;);
String s = sb.toString();
</code></pre><p>再回到我们的问题，现在我们知道秘密在<code>StringBuilder.append</code>函数的源码中。</p>
<pre><code>//针对 String 对象
public AbstractStringBuilder append(String str) {
    if (str == null)
        return appendNull();
    int len = str.length();
    ensureCapacityInternal(count + len);
    str.getChars(0, len, value, count);
    count += len;
    return this;
}
//针对非 String 对象
public AbstractStringBuilder append(Object obj) {
    return append(String.valueOf(obj));
}

private AbstractStringBuilder appendNull() {
    int c = count;
    ensureCapacityInternal(c + 4);
    final char[] value = this.value;
    value[c++] = &apos;n&apos;;
    value[c++] = &apos;u&apos;;
    value[c++] = &apos;l&apos;;
    value[c++] = &apos;l&apos;;
    count = c;
    return this;
}
</code></pre><p>现在我们恍然大悟，<code>append</code>函数如果判断对象为 null，就会调用<code>appendNull</code>，填充<code>&quot;null&quot;</code>。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>上面我们讨论了三个问题，由此引出 Java 中 String 对 null 对象的容错处理。上面的例子没有覆盖所有的处理情况，算是抛砖引玉。</p>
<p>如何让程序中的 null 对象在我们的控制之中，是我们编程的时候需要时刻注意的事情。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>最近在读《Thinking in Java》，看到这样一段话：</p>
<blockquote>
<p>]]>
    </summary>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/tags/Java/"/>
    
      <category term="String" scheme="http://blog.xiaohansong.com/tags/String/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[访问 NULL 指针错误背后的原理]]></title>
    <link href="http://blog.xiaohansong.com/2016/02/18/dereference-null/"/>
    <id>http://blog.xiaohansong.com/2016/02/18/dereference-null/</id>
    <published>2016-02-18T14:50:43.000Z</published>
    <updated>2016-08-26T13:51:18.022Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>说到 NULL 指针大家都是谈之色变，第一印象就是 <code>NullPointerException</code>, <code>Segmentation fault</code> 之类的错误。NULL 指针大部分情况下会导致程序被终止。但是其实严格来说，访问空指针会产生不可预料的结果。只不过大部分情况是程序被终止。为什么呢？接下来让我们来探讨访问 NULL 指针错误背后的原理。</p>
<h2 id="NULL__u5728_u7F16_u8BD1_u5668_u4E2D_u7684_u5B9E_u73B0"><a href="#NULL__u5728_u7F16_u8BD1_u5668_u4E2D_u7684_u5B9E_u73B0" class="headerlink" title="NULL 在编译器中的实现"></a>NULL 在编译器中的实现</h2><p>首先，我们来看看 NULL 指针到底是什么？</p>
<blockquote>
<p>Null 是一个特殊指针值（或是一种对象引用）表示这个指针并不指向任何的对象。</p>
</blockquote>
<p>举一些例子，C/C++ 中的 <code>NULL</code>，Python 中的 <code>None</code> 等等。大部分 <code>NULL</code> 实现是用 <code>0</code> 代表 <code>NULL</code>，例如说 C/C++ 。实际上，NULL 的值并不重要，重要的是它代表的含义。例如说，JVM 规范并没有规定 NULL 的值，不同虚拟机实现可以自己定义 NULL 的值。</p>
<p>总之， NULL 的值取决编译器实现。</p>
<h2 id="u8BBF_u95EE_NULL__u6307_u9488_u7684_u8FC7_u7A0B"><a href="#u8BBF_u95EE_NULL__u6307_u9488_u7684_u8FC7_u7A0B" class="headerlink" title="访问 NULL 指针的过程"></a>访问 NULL 指针的过程</h2><p>C 语言中，NULL 的值是 0，即 <code>NULL == 0</code> 是成立的。我们前面说访问 NULL 指针的行为会产生不可预料的后果。但是在 Linux 系统中后果是确定的：访问空指针会产生 <code>Segmentation fault</code> 的错误。因此这里的“不可预料”指的是在不同系统产生的后果不一样。</p>
<p>让我们假设现在使用的是 C 语言，运行在 Linux 系统上，以此来分析访问 NULL 指针的过程。</p>
<ol>
<li>Linux 中，每个进程空间的 0x0 虚拟地址开始的线性区(memory region)都会被映射到一个用户态没有访问权限的页上。通过这样的映射，内核可以保证没有别的页会映射到这个区域。</li>
<li>编译器把空指针当做 <code>0</code> 对待，开心地让你去访问空指针。</li>
<li>缺页异常处理程序被调用，因为在 0x0 的页没有在物理内存里面。</li>
<li>缺页异常处理程序发现你没有访问的权限。</li>
<li>内核发送 <code>SIGSEGV</code> 信号给进程，该信号默认是让进程自杀。</li>
</ol>
<p>可以看到：不需要特定的编译器实现或者内核的支持，只需要让一个页映射到 0x0 的虚拟地址上，就完美的实现了检测空指针的错误。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>为了研究这个问题，我查了很多资料。空指针的问题涉及 Linux 内存管理的知识，主要参考了 Robert Love 大神对该 <a href="https://www.quora.com/What-actually-happens-when-dereferencing-a-NULL-pointer" target="_blank" rel="external">问题</a> 的回答和《深入理解Linux内核》。最大的感悟是带着问题去看内核的书，你会理解内核为什么要这么做，同时可以加深理解和记忆。</p>
<p>总之，空指针的实现取决于编译器的实现，访问空指针的后果取决于操作系统的实现。大部分系统类似于 Linux，会产生 <code>Segmentation fault</code> 的错误，至于内部实现就要看各个系统的代码了。</p>
<p><em>参考资料</em><br><a href="https://www.quora.com/What-actually-happens-when-dereferencing-a-NULL-pointer" target="_blank" rel="external">What actually happens when dereferencing a NULL pointer?</a><br>《深入理解Linux内核》</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>说到 NULL 指针大家都是谈之色变，第一印象就是 <code>NullPointerException]]>
    </summary>
    
      <category term="Linux" scheme="http://blog.xiaohansong.com/tags/Linux/"/>
    
      <category term="Linux" scheme="http://blog.xiaohansong.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[程序员的知识管理]]></title>
    <link href="http://blog.xiaohansong.com/2016/01/16/kownledge-Management/"/>
    <id>http://blog.xiaohansong.com/2016/01/16/kownledge-Management/</id>
    <published>2016-01-16T05:01:51.000Z</published>
    <updated>2016-08-26T13:55:56.864Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文从一个程序员的视角来讨论知识管理，包括以下几个方面：</p>
<ul>
<li>什么是知识管理</li>
<li>为什么要管理知识</li>
<li>如何管理知识</li>
</ul>
<h2 id="u4EC0_u4E48_u662F_u77E5_u8BC6_u7BA1_u7406"><a href="#u4EC0_u4E48_u662F_u77E5_u8BC6_u7BA1_u7406" class="headerlink" title="什么是知识管理"></a>什么是知识管理</h2><blockquote>
<p>个人知识管理（Personal Knowledge Management）：一般指个人通过工具建立知识体系并不断完善，进行知识的收集、消化吸收和创新的过程。</p>
</blockquote>
<p>知识管理的范围很广，一般的知识管理方法可以参考这篇文章 <a href="http://www.jianshu.com/p/dbdac17eb9ff" target="_blank" rel="external">个人知识管理的方法</a>。</p>
<h2 id="u4E3A_u4EC0_u4E48_u8981_u7BA1_u7406_u77E5_u8BC6"><a href="#u4E3A_u4EC0_u4E48_u8981_u7BA1_u7406_u77E5_u8BC6" class="headerlink" title="为什么要管理知识"></a>为什么要管理知识</h2><p>计算机行业的一个特点是新技术更新特别快，意味着程序员需要不停地学习，才能跟上行业的发展。所以，知识管理对程序员非常重要。有意识，成体系地管理知识能够：</p>
<ul>
<li><strong>更有效地学习新的知识。</strong><br>  如果我们已经建立好一个技术知识体系，新的技术也只是在其他技术上建立起来的，有了坚实基础，学习新技术就会更有效。</li>
<li><strong>更好地掌握知识。</strong><br>  使用合适的工具，正确的方法，可以更好地掌握知识，让知识凝固在脑海，而不是流走。</li>
<li><strong>节约时间成本。</strong><br>  程序员经常遇到同样的问题，例如说部署开发环境的时候，如果有把解决方案记录下来，就能省去重新解决问题的时间。</li>
</ul>
<h2 id="u5982_u4F55_u7BA1_u7406_u77E5_u8BC6"><a href="#u5982_u4F55_u7BA1_u7406_u77E5_u8BC6" class="headerlink" title="如何管理知识"></a>如何管理知识</h2><p>程序员的知识获取途径大部分来自于搜索引擎（谷歌可以提高搜索效率）和技术书籍，这与其他行业不同。主要原因是技术知识一个主要来源是互联网，例如说技术博客，技术文档等。因此，程序员的知识管理主要围绕互联网展开（并不意味着书籍就不重要）。</p>
<p>我把程序员的知识管理分为三个过程：</p>
<ul>
<li><strong>知识积累</strong></li>
<li><strong>碎片整理</strong></li>
<li><strong>思考加工</strong></li>
</ul>
<h3 id="u77E5_u8BC6_u79EF_u7D2F"><a href="#u77E5_u8BC6_u79EF_u7D2F" class="headerlink" title="知识积累"></a>知识积累</h3><p>想想我们习以为常的知识积累方式有哪些？也许记笔记是我们最常用的一种。对于程序员来说，用笔记录笔记并不现实，我刚学 C++ 的时候就是把语法记在笔记上。实际上，这种做法是很低效的。更有效的方法是用笔记软件帮我们记录文章。例如说，印象笔记，有道笔记等。</p>
<p>一开始我看到好的技术文章时，都是加书签存起来。后面发现这样不能离线访问，而且链接可能会失效。后来用上了笔记软件，于是我可以把文章保存到笔记中，随时可以翻出来看。可以说，笔记软件给知识积累带来了极大方便，同时可以分类管理不同的知识。</p>
<p>知识积累难在养成积累的习惯。以前我解决某个问题，谷歌了很久找到一篇文章解决了问题。解决之后并没有记录下来，结果下一次遇到同样问题，我又浪费了很多时间搜索解决方法。重复多次之后，我意识到这是个严重的问题。所以逐渐养成了保存各种文章的习惯。这些网上积累下来的文章，成为了我知识体系的土壤。</p>
<p>现在开始，<strong>使用笔记软件分门别类地保存网上看到的文章</strong>，这里要着重强调一下分类的重要性，好的分类可以节省你以后重新检索文章的时间，不要把时间浪费在不必要的劳动上。笔记软件一般都会提供浏览器插件，保存起来是很方便的。</p>
<h3 id="u788E_u7247_u6574_u7406"><a href="#u788E_u7247_u6574_u7406" class="headerlink" title="碎片整理"></a>碎片整理</h3><p>我自己经常遇到这样的情况：要用到某个 Linux 命令的时候，经常大费周章地去搜索。有人说直接查 man 手册不是很快吗？确实查 man 手册比查搜索引擎要快，但是有两个问题：一是看了 man 手册的命令语法，我还得试试看；二是如果我不知道命令的名字怎么查 man。所以，最快的方法不是搜索引擎，也不是 man 手册，而是个人 wiki。</p>
<p>与大家平常所知的 wiki 不同，个人 wiki 主要是用来记录知识碎片的，例如说：某个常用命令的语法，特定的软件配置等等。如果还是不理解，可以看看我的个人 <a href="http://wiki.xiaohansong.com/" target="_blank" rel="external">Wiki</a>。这些知识碎片是我们初步消化的知识，只不过因为太过碎片，不能够组成完整的知识体系。很多人以为把看到的文章保存到自己的笔记里面，就有一种已经掌握它的错觉，结果保存了成千上百的文章，却一篇都没认真看完。别人的文章是他的知识沉淀，并不是自己的。随时把文章中的精华提取整理到 wiki，才能初步消化知识，为后面的思考加工做准备。</p>
<p>有人会问为什么不用笔记软件记录这些碎片化的知识呢？用 wiki 当然是有理由的：</p>
<ol>
<li><strong>笔记软件保存的主要是知识原料。</strong>我们从网上保存别人的文章到笔记，存下来的知识是别人的，你只是存下来而已，还没经过消化。我们上面把笔记软件定义为知识的仓库，如果把初步消化后的知识也存在那里，会造成一定的混乱。当然你一定要这么做也可以，但我有分层的思维定势，这算是职业病吧。</li>
<li><strong>wiki 是随处可访问的。</strong>wiki 发布在互联网上，我们可以随时随地访问它。</li>
<li><strong>wiki 是分享的。</strong>任何人都可以访问你的 wiki，分享自己的知识何乐而不为呢？</li>
</ol>
<p>那么如何制作自己的 wiki 呢？我自己用的是 <a href="http://simiki.org/" target="_blank" rel="external">Simiki</a>，具体用法查看 <a href="http://wiki.xiaohansong.com/tool/simiki.html" target="_blank" rel="external">Simiki-个人Wiki写作</a>。发布到互联网我用的是 Github Page，具体操作自行搜索。</p>
<h3 id="u601D_u8003_u52A0_u5DE5"><a href="#u601D_u8003_u52A0_u5DE5" class="headerlink" title="思考加工"></a>思考加工</h3><p>写博客是最好的思考加工知识的方法。当年我也是被刘未鹏的 <a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="external">为什么你应该（从现在开始就）写博客</a> 和 <a href="http://mindhacks.cn/2009/02/09/writing-is-better-thinking/" target="_blank" rel="external">书写是为了更好的思考</a> 给带入坑的。写博客的好处我就不提了，看上面两篇文章就够洗脑了。下面我着重谈谈如何写好博客的一点个人经验。</p>
<ol>
<li><strong>博客少写纯操作指南类的文章。</strong>网上大部分博客写的都是纯操作指南类的文章，例如，如何搭建 LAMP 之类，可能作者自己都不清楚为什么要这么做。不是说纯操作指南类的文章不好，相反我觉得这种文章很重要，只是它的位置不对。它应该放在 wiki 中，因为纯操作指南类的文章只是描述步骤，关注点是怎么做，而不是为什么。写博客的关注点应该在为什么，讲清楚为什么要这么做。另外不要钻牛角尖，我说的是纯操作指南，不要以为只要是搭建环境之类的文章都不能写，这里的“纯”代表只给步骤，不提背后的原理。其实写得好的操作指南应该力求让读者知其然，知其所以然。</li>
<li><strong>定期写文章。</strong> 万事开头难，动笔开始写作很难，一旦开始就停不下来了。养成定期写文章的习惯，至少确保一个月一篇的节奏。</li>
<li><strong>自荐文章到各个技术头条。</strong>例如说：伯乐头条，开发者头条，极客头条等，有读者才有动力，同时也是保证自己写好文章的监督。</li>
<li><strong>写博客的工具。</strong>我自己用的是托管在 Github Page 的 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo</a> 静态博客。搭建教程见 <a href="http://blog.xiaohansong.com/2015/06/17/%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/">用hexo搭建github博客</a>。如果你有服务器的话，可以试试 wordpress，ghost 之类的博客软件。</li>
<li><strong>把无法加工的知识写到 Wiki。</strong>例如说：git 的一些配置和用法，这些内容在官方文档都能找到，写在博客也只是搬运工，除非你有新的理解。</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>以上是我摸打滚爬两年多积累的经验之谈，如果你有好的经验欢迎留言交流。一开始我是在 CSDN 写博客，只不过走了不少弯路，后来折腾 <a href="http://blog.xiaohansong.com/">个人博客</a>，最后又开了 <a href="http://wiki.xiaohansong.com/" target="_blank" rel="external">个人 Wiki</a>。逐渐形成了自己的知识管理方法。最后总结一下：</p>
<ol>
<li><strong>知识积累</strong>：使用笔记软件保存好的文章，积累知识。</li>
<li><strong>碎片整理</strong>：在个人 wiki 上记录初步消化的知识碎片。</li>
<li><strong>思考加工</strong>：对存在笔记和 wiki 中知识进行思考加工后写在博客。</li>
</ol>
<p>以上讲的是如何在互联网中学习积累，但是千万不要忽视了看书这一重要方法，书中的知识是成体系的，知识密度高，网上的文章良莠不齐，不成体系，比较碎片化。合理分配时间看书和上网学习是很重要的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文从一个程序员的视角来讨论知识管理，包括以下几个方面：</p>
<ul>
<li>什么是知识管理</l]]>
    </summary>
    
      <category term="知识管理" scheme="http://blog.xiaohansong.com/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对抽象类与接口的一点思考]]></title>
    <link href="http://blog.xiaohansong.com/2015/12/02/abstract-class-and-interface/"/>
    <id>http://blog.xiaohansong.com/2015/12/02/abstract-class-and-interface/</id>
    <published>2015-12-02T13:55:47.000Z</published>
    <updated>2016-08-26T13:51:42.806Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>之前写了一篇文章 <a href="http://blog.xiaohansong.com/2015/11/24/clean-code-polymorphism/">简洁代码之道（1）：用多态替代条件语句</a>，有人问实现多态的时候为什么用抽象类而不是接口。当时写文章的时候并没有想到这个问题。后来仔细想想，这的确是个值得探讨的问题。多态可以用抽象类或者接口实现，重点是应该用哪个？更大问题是，接口和抽象类有什么本质的区别？下面我们将讨论以下的问题：</p>
<ul>
<li>抽象类和接口的对比</li>
<li>从 java 容器类的设计讨论抽象类和接口的应用</li>
<li>抽象类和接口的使用时机</li>
</ul>
<h2 id="u62BD_u8C61_u7C7B_u4E0E_u63A5_u53E3_u7684_u5BF9_u6BD4"><a href="#u62BD_u8C61_u7C7B_u4E0E_u63A5_u53E3_u7684_u5BF9_u6BD4" class="headerlink" title="抽象类与接口的对比"></a>抽象类与接口的对比</h2><table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td> 默认的方法实现</td>
<td>它可以有默认的方法实现</td>
<td>接口完全是抽象的。它根本不存在方法的实现</td>
<td></td>
</tr>
<tr>
<td>实现</td>
<td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>与正常Java类的区别</td>
<td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td>接口是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有public、protected和default这些修饰符</td>
<td>接口方法默认修饰符是public。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td>main方法</td>
<td>抽象方法可以有main方法并且我们可以运行它</td>
<td>接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td>多继承</td>
<td>抽象方法可以继承一个类和实现多个接口</td>
<td>接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td>速度</td>
<td>它比接口速度要快</td>
<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody>
</table>
<p>抽象类和接口有不同，也有相似的地方。有些书把接口称作特殊的类，虽然不准确，但也有一定道理，接口能做的事情，抽象类也能做到，除了多重继承。正是因为这些相似的特性，让我们在使用它们的时候有了困惑：这里到底该用抽象类还是接口？</p>
<h2 id="u4ECE_java__u5BB9_u5668_u7C7B_u7684_u8BBE_u8BA1_u8BA8_u8BBA_u62BD_u8C61_u7C7B_u548C_u63A5_u53E3_u7684_u5E94_u7528"><a href="#u4ECE_java__u5BB9_u5668_u7C7B_u7684_u8BBE_u8BA1_u8BA8_u8BBA_u62BD_u8C61_u7C7B_u548C_u63A5_u53E3_u7684_u5E94_u7528" class="headerlink" title="从 java 容器类的设计讨论抽象类和接口的应用"></a>从 java 容器类的设计讨论抽象类和接口的应用</h2><p>除了前面提到的一个问题：多态到底是用抽象类还是接口实现？我还看到有人评论说：现在都是提倡面向接口编程，使用抽象类的都被称为上世纪的老码农了。哈哈。看到这个说法我也是苦笑不得。不过，面向接口编程的确是一个趋势，java 8 已经支持接口实现默认方法和静态方法了，抽象类和接口之间的差异越来越小。闲话少说，我们开始讨论抽象类和接口的应用。</p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/full_container_taxonomy.png" alt="full_container_taxonomy"></p>
<p>上图是 java 容器类的类继承关系。我们以容器类中 <code>ArrayList</code> 为例子来讨论抽象类和接口的应用。</p>
<h3 id="ArrayList__u7C7B_u7EE7_u627F_u5173_u7CFB"><a href="#ArrayList__u7C7B_u7EE7_u627F_u5173_u7CFB" class="headerlink" title="ArrayList 类继承关系"></a>ArrayList 类继承关系</h3><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/ArrayList.png" alt="ArrayList"></p>
<p>上图是 <code>ArrayList</code> 的类继承关系。可以看到，<code>ArrayList</code> 的继承关系中既使用了抽象类，也使用了接口。</p>
<ul>
<li>最顶层的接口是 <code>Iterable</code>，表示这是可迭代的类型。所有容器类都是可迭代的，这是一个极高的抽象。</li>
<li>第二层的接口是 <code>Collection</code>，这是单一元素容器的接口。集合，列表都属于此类。</li>
<li>第三层的接口是 <code>List</code>，这是所有列表的接口。</li>
</ul>
<p>通过三个接口，我们可以找到容器类的三个抽象特性，实现这些接口就意味着拥有这些接口的特性。</p>
<ul>
<li><code>AbstractCollection</code> 实现了 <code>Collection</code> 中的部分方法。</li>
<li><code>AbstractList</code> 实现了 <code>AbstractCollection</code> 和 <code>List</code> 中的部分方法。</li>
</ul>
<p>上面的抽象类提供了一些方法的默认实现，给具体类提供了复用代码。</p>
<h3 id="u7EAF_u62BD_u8C61_u7C7B_u5B9E_u73B0"><a href="#u7EAF_u62BD_u8C61_u7C7B_u5B9E_u73B0" class="headerlink" title="纯抽象类实现"></a>纯抽象类实现</h3><p>如果我们像一个老码农一样，用抽象类来实现上面的接口会有怎样的效果？那么，类图可能变成这样。</p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/AbtractList.png" alt="AbtractList"></p>
<p>抽象类在这里存在着一个很大的问题，它不能多继承，在抽象的层次上没有接口高，也没有接口灵活。例如说：</p>
<pre><code>List + AbstractCollection -&gt; AbstractList
Set  + AbstractCollection -&gt; AbstractSet
</code></pre><p>单纯用抽象类无法实现像接口一样灵活的扩展。</p>
<h3 id="u7EAF_u63A5_u53E3_u5B9E_u73B0"><a href="#u7EAF_u63A5_u53E3_u5B9E_u73B0" class="headerlink" title="纯接口实现"></a>纯接口实现</h3><p>如果我们像一个新码农一样，用纯接口来实现呢？</p>
<p> <img src="http://7xjtfr.com1.z0.glb.clouddn.com/InterfaceList.png" alt="InterfaceList"></p>
<p>这样写理论上没有问题，实际写代码的时候问题就来了。所有的接口都要提供实现，于是你不得不在各个实现类中重复代码。</p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>经过上面的讨论，我们得出两个结论：</p>
<ul>
<li>抽象类和接口并不能互相替代。</li>
<li>抽象类和接口各有不可替代的作用。</li>
</ul>
<p>从容器类的类关系图中可以看到，接口主要是用来抽象类型的共性，例如说，容器的可迭代特性。抽象类主要是给具体实现类提供重用的代码，例如说，<code>List</code> 的一些默认方法。</p>
<h2 id="u62BD_u8C61_u7C7B_u548C_u63A5_u53E3_u7684_u4F7F_u7528_u65F6_u673A"><a href="#u62BD_u8C61_u7C7B_u548C_u63A5_u53E3_u7684_u4F7F_u7528_u65F6_u673A" class="headerlink" title="抽象类和接口的使用时机"></a>抽象类和接口的使用时机</h2><p>那么，什么时候该用抽象类，什么时候该用接口呢？</p>
<p>要解决上面的问题，我们先从弄清楚抽象类和接口之间的关系。首先，我们都知道类对事物的抽象，定义了事物的属性和行为。而抽象类是不完全的类，具有抽象方法。接口则比类的抽象层次更高。所以，我们可以这样理解它们之间的关系：<strong>类是对事物的抽象，抽象类是对类的抽象，接口是对抽象类的抽象。</strong></p>
<p>从这个角度来看 java 容器类，你会发现，它的设计正体现了这种关系。不是吗？从 <code>Iterable</code> 接口，到 <code>AbstractList</code> 抽象类，再到 <code>ArrayList</code> 类。</p>
<p>现在回答前面的问题：在设计类的时候，首先考虑用接口抽象出类的特性，当你发现某些方法可以复用的时候，可以使用抽象类来复用代码。简单说，<strong>接口用于抽象事物的特性，抽象类用于代码复用</strong>。</p>
<p>当然，不是所有类的设计都要从接口到抽象类，再到类。程序设计本就没有绝对的范式可以遵循。上面的说法只是提供一个角度来理解抽象类和接口的关系，每个人都会有自己的理解，有人认为两者一点关系都没有，这也有道理。总之，模式和语法是死的，人是活的。</p>
<p><em>参考资料</em><br><a href="http://www.importnew.com/12399.html" target="_blank" rel="external">Java抽象类与接口的区别</a><br><a href="https://bxbxbai.github.io/2014/07/20/understood_abstract_class_and_interface/.glb.clouddn.com/InterfaceList.png" target="_blank" rel="external">我如何理解Java中抽象类和接口</a><br><a href="http://www.uml.org.cn/mxdx/200904232.asp" target="_blank" rel="external">面向接口编程详解</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>之前写了一篇文章 <a href="http://blog.xiaohansong.com/2015/1]]>
    </summary>
    
      <category term="编程实践" scheme="http://blog.xiaohansong.com/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简洁代码之道（2）：避免全局可变状态]]></title>
    <link href="http://blog.xiaohansong.com/2015/11/30/avoid-global-state/"/>
    <id>http://blog.xiaohansong.com/2015/11/30/avoid-global-state/</id>
    <published>2015-11-30T07:42:41.000Z</published>
    <updated>2016-01-02T17:39:28.897Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文是我看了 <a href="https://www.youtube.com/playlist?list=PL693EFD059797C21E" target="_blank" rel="external">谷歌简洁代码演讲系列</a> 中的 <a href="https://www.youtube.com/watch?v=-FRm3VPhseI&amp;index=4&amp;list=PL693EFD059797C21E" target="_blank" rel="external">全局状态与单例模式</a> 之后的总结。本文的主题是：避免全局可变状态。下面我们将围绕几个问题开展讨论：</p>
<ul>
<li>什么是全局状态</li>
<li>如何设计好的单例模式</li>
<li>如何设计好的 API</li>
</ul>
<h2 id="u5168_u5C40_u72B6_u6001"><a href="#u5168_u5C40_u72B6_u6001" class="headerlink" title="全局状态"></a>全局状态</h2><h3 id="u4EC0_u4E48_u662F_u5168_u5C40_u72B6_u6001"><a href="#u4EC0_u4E48_u662F_u5168_u5C40_u72B6_u6001" class="headerlink" title="什么是全局状态"></a>什么是全局状态</h3><blockquote>
<p>Talk is cheap, show me the code. – Linus</p>
</blockquote>
<p>我们来用一个例子说明什么是全局状态。</p>
<pre><code>class X {
    X() {...}

    public int doSomething() {...}
}

int a = new X().doSomething()
int b = new X().doSomething()
</code></pre><p>现在问题来了，<code>a</code> 等于 <code>b</code> 吗？事实上有两种可能的情况。</p>
<p>第一种情况：<code>X</code> 类不受全局状态的影响，此时 <code>a == b</code></p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/global_state1.png" alt="a==b"><br>当 <code>X</code> 被实例化时，它可能会同时创建多个其它对象，当它执行 <code>doSomething()</code> 的时候，得到的结果是一样。说明它是无状态的，每次执行都像 <code>1+1=2</code> 一样有一个确定的值。</p>
<p>第二种情况：<code>X</code> 类受到全局状态的影响，此时 <code>a != b</code></p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/global_state2.png" alt="a!=b"><br>如果 <code>X</code> 在执行 <code>doSomething()</code> 的时候，其中的 <code>Z</code> 变量受到全局状态 <code>GS</code> 的影响，此时 <code>a==b</code> 可能就不成立了。因为程序的执行依赖全局状态，同样的方法可能会得到不同的结果。</p>
<h3 id="u5168_u5C40_u72B6_u6001_u7684_u7F3A_u70B9"><a href="#u5168_u5C40_u72B6_u6001_u7684_u7F3A_u70B9" class="headerlink" title="全局状态的缺点"></a>全局状态的缺点</h3><p>全局状态相当常见，因为写起来方便。“啊，有一个新的功能要加入，我们加一个全局变量，再加一个条件语句跳转到新的方法就行了。”然而，这种方便却让程序变得难以维护和测试。所以，有一定经验的程序员都会认为全局状态令人讨厌，会避免使用它。</p>
<p>下面我们来列举全局状态的罪状：</p>
<ul>
<li>多次执行同一方法会产生不同的结果<ul>
<li>测试无法给出一个可靠的结果</li>
<li>测试的顺序会影响到结果</li>
<li>不能并行进行测试</li>
</ul>
</li>
<li>很难确定设置状态的位置</li>
</ul>
<p>总之，从测试的角度来看，全局状态是很可怕的东西。</p>
<h3 id="u5168_u5C40_u72B6_u6001_u548C_u5168_u5C40_u53D8_u91CF_u7684_u533A_u522B"><a href="#u5168_u5C40_u72B6_u6001_u548C_u5168_u5C40_u53D8_u91CF_u7684_u533A_u522B" class="headerlink" title="全局状态和全局变量的区别"></a>全局状态和全局变量的区别</h3><ul>
<li>全局状态不仅包括了全局变量，还包括系统的环境变量，以及人为的命令等。</li>
<li>全局变量是在程序生命周期中全局可访问的变量，常用来表示全局状态。</li>
</ul>
<h2 id="u5355_u4F8B_u6A21_u5F0F"><a href="#u5355_u4F8B_u6A21_u5F0F" class="headerlink" title="单例模式"></a>单例模式</h2><p>有些程序员讨厌全局状态，却喜欢单例模式。但是，从某种意义上说，单例模式是另一种全局状态。当然我不是一棍子打死单例模式，应该说，写得不好的单例模式起到的作用就如同全局状态，让程序难以维护和测试。下面我们来讨论什么是好的单例模式，什么是坏的单例模式</p>
<h3 id="u574F_u7684_u5355_u4F8B_u6A21_u5F0F"><a href="#u574F_u7684_u5355_u4F8B_u6A21_u5F0F" class="headerlink" title="坏的单例模式"></a>坏的单例模式</h3><p>下面是典型的单例模式实现。</p>
<pre><code>class AppSetting {
    private static AppSetting instance = new AppSetting();
    private Object state1;
    private Object state2;
    private Object state3;
    private AppSetting() {...}

    public static AppSetting getInstance() {
        return instance;
    }
}
</code></pre><p>我们先来思考一个问题：这个类包括了多少个全局变量？你可能觉得只有一个 <code>instance</code>，事实上一共有4个。只要 <code>instance</code> 一直存在，它的成员变量也会一直存在。也就是说一共有四个全局变量：<code>state1, state2, state3, instance</code>。</p>
<pre><code>class App {
    int method() {
        return AppSetting.getInstance().doX();
    }
}

void testApp {
    ???
}
</code></pre><p>想想我们怎么测试上面的代码。单例模式下，你没有缝隙进入到 <code>method()</code> 函数中测试。</p>
<p>上面的单例模式存在一个很大的测试问题：测试无法覆盖所有的状态。因为状态是私有，同时它单例的。如果我们要测试三个状态怎么办，一个解决办法是在测试的时候把状态改为公有的。这看起来有点诡异，我们一方面又想用单例封装状态，一方面却在测试的时候要去修改代码让它的状态公有。可以说，这种单例模式给测试带来了极大的麻烦。</p>
<h3 id="u597D_u7684_u5355_u4F8B_u6A21_u5F0F"><a href="#u597D_u7684_u5355_u4F8B_u6A21_u5F0F" class="headerlink" title="好的单例模式"></a>好的单例模式</h3><p>那么，什么是好的单例模式呢？看下面的代码。</p>
<pre><code>class AppSetting {
    private Object state1;
    private Object state2;
    private Object state3;
    public AppSetting() {...}
}
</code></pre><p>第一眼看到这个代码，你可能觉得这哪里是单例模式，明明就是个普通的类。</p>
<p>是的，它的确是个普通的类。在这里我们让它不再着重于类自身的单例。什么意思？想想单例模式的本质是什么，单例模式主要是类保证在程序的生命周期内只有一个实例，其它对象访问到的是同一个实例。我们来看看，这种模式对测试带来了怎样的便利。</p>
<pre><code>class App {
    AppSetting settings;
    App(AppSetting settings) {
        this.settings = settings;
    }

    int method() {
        return settings.doX();
    }
}

void testApp() {
     new App(new AppSetting(...)).method();
}
</code></pre><p>每个测试我们可以提供一个不同的 <code>AppSetting</code> 来进行测试，相比上面的单例模式，测试得到了更多的控制。我们可以通过不同的 <code>AppSetting</code> 的构造函数，改变程序的状态来进行测试。</p>
<p>看到这里，你可能有一个疑问：这样子写的代码根本就不是单例模式。的确，从类的实现上，<code>AppSetting</code> 的确不是单例模式的。这里我们强调的是逻辑上的单例，而不是代码实现上的单例。怎么理解？</p>
<p>首先，单例模式的传统实现是由类来管理这个唯一的实例，也就是我们上面说的“坏的单例模式”，而“好的单例模式”则是由程序来控制类的唯一实例，例如说，Spring IoC 容器中的 Bean，在容器的生命周期中，Bean 默认是单例的。（详细的解释可以看这篇文章 <a href="http://blog.xiaohansong.com/2015/10/21/IoC-and-DI/">控制反转（IoC）与依赖注入（DI）</a>）简单说，就是把单例类管理唯一实例的功能转移给外部容器，当你使用了 IoC 框架之后，你会发现，单例模式的实例完全可以通过容器管理，而不用我们写“坏的单例模式”。</p>
<h2 id="u8BBE_u8BA1_u597D_u7684_API"><a href="#u8BBE_u8BA1_u597D_u7684_API" class="headerlink" title="设计好的 API"></a>设计好的 API</h2><p>全局状态同样会影响到 API 的好坏。</p>
<h3 id="u574F_u7684_API"><a href="#u574F_u7684_API" class="headerlink" title="坏的 API"></a>坏的 API</h3><p>我们来看一个坏的 API。</p>
<pre><code>testCharge() {
    Database.connect();
    OfflineQueue.start();
    CreditCardProcessor.init();
    CreditCard cc = new CreditCard(&quot;123&quot;);
    cc.charge(100);
}
</code></pre><p>如果你对单例模式的坏处还没完全理解，或者你也喜欢写这样的代码，那么刷新编程观的时候到了。</p>
<p>上面是一个信用卡测试消费的例子。在实例化 <code>CreditCard</code> 之前要有三个初始化操作（明显都是单例模式）。现在问题来了：如果你是新来的测试人员，让你去测试 <code>CreditCard</code>，你看了 API 文档之后，兴冲冲地写下一些代码。</p>
<pre><code>testCharge() {
    CreditCard cc = new CreditCard(&quot;123&quot;);
    cc.charge(100);
}
</code></pre><p>现在满怀期待的运行，结果却是熟悉的 <code>NullPointerException</code>。为什么？新来的你当然不知道创建 <code>CreditCard</code> 之前要先连接数据库，启动离线队列，初始化信用卡处理器。所以你只能去问开发人员。现在你知道问题出在哪了吗？</p>
<p>坏的单例模式让测试人员很难测试代码，因为你看了 API 之后只知道要实例化 <code>CreditCard</code>，然后调用 <code>charge</code>，完全不知道 <code>Database</code> 之类的全局状态是什么鬼。不要以为这只会为难到测试人员，六个月之后你就能体验到测试人员的痛苦。因此，全局状态让 API 有了误导性，让你以为做了正确的操作。</p>
<p>当然，文档写的清楚可以解决这个问题，然而好的文档可遇不可求，所以我们要有更好的解决办法。</p>
<h3 id="u597D_u7684_API"><a href="#u597D_u7684_API" class="headerlink" title="好的 API"></a>好的 API</h3><p>设计好的 API，可以从代码层面上解决上面的问题，所谓代码就是最好的注释。</p>
<pre><code>testCharge() {
    db = new Database(...);
    queue = new OfflineQueue(db);
    ccProc = new CreditCardProcessor(queue);
    CreditCard cc = new CreditCard(&quot;123&quot;, ccProc);
    cc.charge(100);
}
</code></pre><p>上面的代码通过<strong>让依赖参数化</strong>完美地解决上面的问题。现在，我们还是那个新来的测试人员，我们开始写测试代码。API 告诉我们，实例化 <code>CreditCard</code> 需要 <code>CreditCardProcessor</code> 作为参数，<code>CreditCardProcessor</code>需要 <code>OfflineQueue</code>，<code>OfflineQueue</code> 需要 <code>Database</code>。于是我们可以很清楚的写下上面的测试代码，不需要文档的辅助，我们也知道如何正确的使用 <code>CreditCard</code>。这就是好的 API 设计。</p>
<p>如果我们要让上面的配置类单例化，只需要使用 IoC 容器进行管理即可，通过依赖注入的方式，可以使代码更加清晰，易测试。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>全局状态是大多数测试问题的根源。</li>
<li>全局状态无法被测试控制，无法控制意味着无法进行彻底的测试。</li>
<li>单例模式是封装了全局状态的常用形式。这也是我们不提倡使用单例模式的原因，推荐用容器管理的单例模式。</li>
<li>全局状态会让 API 具有误导性。</li>
</ul>
<p><em>参考资料</em><br><a href="https://www.youtube.com/watch?v=-FRm3VPhseI&amp;index=4&amp;list=PL693EFD059797C21E" target="_blank" rel="external">全局状态与单例模式</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文是我看了 <a href="https://www.youtube.com/playlist?lis]]>
    </summary>
    
      <category term="编程实践" scheme="http://blog.xiaohansong.com/tags/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="设计" scheme="http://blog.xiaohansong.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="编程实践" scheme="http://blog.xiaohansong.com/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
</feed>
