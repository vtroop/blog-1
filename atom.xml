<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ShareHub]]></title>
  <subtitle><![CDATA[悲观的意志,乐观的头脑]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.xiaohansong.com/"/>
  <updated>2016-08-22T14:18:04.416Z</updated>
  <id>http://blog.xiaohansong.com/</id>
  
  <author>
    <name><![CDATA[肖汉松]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[ZooKeeper Watcher 和 AsyncCallback 的区别与实现]]></title>
    <link href="http://blog.xiaohansong.com/2016/08/22/zookeeper-watch-async/"/>
    <id>http://blog.xiaohansong.com/2016/08/22/zookeeper-watch-async/</id>
    <published>2016-08-22T14:15:08.000Z</published>
    <updated>2016-08-22T14:18:04.416Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>初学 Zookeeper 会发现客户端有两种回调方式： Watcher 和 AsyncCallback，而 Zookeeper 的使用是离不开这两种方式的，搞清楚它们之间的区别与实现显得尤为重要。本文将围绕下面几个方面展开</p>
<ul>
<li>Watcher 和 AsyncCallback 的区别</li>
<li>Watcher 的回调实现</li>
<li>AsyncCallback 的回调实现</li>
<li>IO 与事件处理</li>
</ul>
<h2 id="Watcher__u548C_AsyncCallback__u7684_u533A_u522B"><a href="#Watcher__u548C_AsyncCallback__u7684_u533A_u522B" class="headerlink" title="Watcher 和 AsyncCallback 的区别"></a>Watcher 和 AsyncCallback 的区别</h2><p>我们先通过一个例子来感受一下：</p>
<pre><code>zooKeeper.getData(root, new Watcher() {
            public void process(WatchedEvent event) {

            }
        }, new AsyncCallback.DataCallback() {
            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {

            }
        }, null);
</code></pre><p>可以看到，<code>getData</code>方法可以同时设置两个回调：Watcher 和 AsyncCallback，同样是回调，它们的区别是什么呢？要解决这个问题，我们就得从这两个接口的功能入手。</p>
<ul>
<li><code>Watcher</code>：<code>Watcher</code>是用于监听节点，session 状态的，比如<code>getData</code>对数据节点<code>a</code>设置了<code>watcher</code>，那么当<code>a</code>的数据内容发生改变时，客户端会收到<code>NodeDataChanged</code>通知，然后进行<code>watcher</code>的回调。</li>
<li><code>AsyncCallback</code>:<code>AsyncCallback</code>是在以异步方式使用 ZooKeeper API 时，用于处理返回结果的。例如：<code>getData</code>同步调用的版本是：<code>byte[] getData(String path, boolean watch,Stat stat)</code>，异步调用的版本是：<code>void getData(String path,Watcher watcher,AsyncCallback.DataCallback cb,Object ctx)</code>，可以看到，前者是直接返回获取的结果，后者是通过<code>AsyncCallback</code>回调处理结果的。</li>
</ul>
<h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p>Watcher 主要是通过<code>ClientWatchManager</code>进行管理的。</p>
<h3 id="Watcher__u7684_u7C7B_u578B"><a href="#Watcher__u7684_u7C7B_u578B" class="headerlink" title="Watcher 的类型"></a>Watcher 的类型</h3><p><code>ClientWatchManager</code>中有四种<code>Watcher</code></p>
<ul>
<li><code>defaultWatcher</code>：创建<code>Zookeeper</code>连接时传入的<code>Watcher</code>，用于监听 session 状态</li>
<li><code>dataWatches</code>：存放<code>getData</code>传入的<code>Watcher</code></li>
<li><code>existWatches</code>：存放<code>exists</code>传入的<code>Watcher</code>，如果节点已存在，则<code>Watcher</code>会被添加到<code>dataWatches</code></li>
<li><code>childWatches</code>：存放<code>getChildren</code>传入的<code>Watcher</code></li>
</ul>
<p>从代码上可以发现，监听器是存在<code>HashMap</code>中的，<code>key</code>是节点名称<code>path</code>，<code>value</code>是<code>Set&lt;Watcher&gt;</code></p>
<pre><code>private final Map&lt;String, Set&lt;Watcher&gt;&gt; dataWatches =
        new HashMap&lt;String, Set&lt;Watcher&gt;&gt;();
private final Map&lt;String, Set&lt;Watcher&gt;&gt; existWatches =
        new HashMap&lt;String, Set&lt;Watcher&gt;&gt;();
private final Map&lt;String, Set&lt;Watcher&gt;&gt; childWatches =
        new HashMap&lt;String, Set&lt;Watcher&gt;&gt;();

private volatile Watcher defaultWatcher;
</code></pre><h3 id="u901A_u77E5_u7684_u72B6_u6001_u7C7B_u578B_u4E0E_u4E8B_u4EF6_u7C7B_u578B"><a href="#u901A_u77E5_u7684_u72B6_u6001_u7C7B_u578B_u4E0E_u4E8B_u4EF6_u7C7B_u578B" class="headerlink" title="通知的状态类型与事件类型"></a>通知的状态类型与事件类型</h3><p>在<code>Watcher</code>接口中，已经定义了所有的状态类型和事件类型</p>
<ul>
<li><p>KeeperState.Disconnected(0)</p>
<p>  此时客户端处于断开连接状态，和ZK集群都没有建立连接。</p>
<ul>
<li><p>EventType.None(-1)</p>
<p>  触发条件：一般是在与服务器断开连接的时候，客户端会收到这个事件。</p>
</li>
</ul>
</li>
<li><p>KeeperState. SyncConnected(3)</p>
<p>  此时客户端处于连接状态</p>
<ul>
<li><p>EventType.None(-1)</p>
<p>  触发条件：客户端与服务器成功建立会话之后，会收到这个通知。</p>
</li>
<li><p>EventType. NodeCreated (1)</p>
<p>  触发条件：所关注的节点被创建。</p>
</li>
<li><p>EventType. NodeDeleted (2)</p>
<p>  触发条件：所关注的节点被删除。</p>
</li>
<li><p>EventType. NodeDataChanged (3)</p>
<p>  触发条件：所关注的节点的内容有更新。注意，这个地方说的内容是指数据的版本<code>号dataVersion</code>。因此，即使使用相同的数据内容来更新，还是会收到这个事件通知的。无论如何，调用了更新接口，就一定会更新<code>dataVersion</code>的。</p>
</li>
<li><p>EventType. NodeChildrenChanged (4)</p>
<p>  触发条件：所关注的节点的子节点有变化。这里说的变化是指子节点的个数和组成，具体到子节点内容的变化是不会通知的。</p>
</li>
</ul>
</li>
<li><p>KeeperState. AuthFailed(4)</p>
<p>  认证失败</p>
<ul>
<li>EventType.None(-1)</li>
</ul>
</li>
<li><p>KeeperState. Expired(-112)</p>
<p>  session 超时</p>
<ul>
<li>EventType.None(-1)</li>
</ul>
</li>
</ul>
<h3 id="materialize__u65B9_u6CD5"><a href="#materialize__u65B9_u6CD5" class="headerlink" title="materialize 方法"></a>materialize 方法</h3><p><code>ClientWatchManager</code>只有一个方法，那就是<code>materialize</code>，它根据事件类型<code>type</code>和<code>path</code>返回监听该节点的特定类型的<code>Watcher</code>。</p>
<pre><code>public Set&lt;Watcher&gt; materialize(Watcher.Event.KeeperState state,
    Watcher.Event.EventType type, String path);
</code></pre><p>核心逻辑如下：</p>
<ol>
<li><code>type == None</code>:返回所有<code>Watcher</code>，也就是说所有的<code>Watcher</code>都会被触发。如果<code>disableAutoWatchReset == true</code>且当前<code>state != SyncConnected</code>，那么还会清空<code>Watcher</code>，意味着移除所有在节点上的<code>Watcher</code>。</li>
<li><code>type == NodeDataChanged | NodeCreated</code>:返回监听<code>path</code>节点的<code>dataWatches &amp; existWatches</code></li>
<li><code>type == NodeChildrenChanged</code>:返回监听<code>path</code>节点的<code>childWatches</code></li>
<li><code>type == NodeDeleted</code>:返回监听<code>path</code>节点的<code>dataWatches | childWatches</code></li>
</ol>
<p>每次返回都会从<code>HashMap</code>中移除节点对应的<code>Watcher</code>，例如：<code>addTo(dataWatches.remove(clientPath), result);</code>，这就是为什么<code>Watcher</code>是一次性的原因（<code>defaultWatcher</code>除外）。值得注意的是，由于使用的是<code>HashSet</code>存储<code>Watcher</code>，重复添加同一个实例的<code>Watcher</code>也只会被触发一次。</p>
<h2 id="AsyncCallback"><a href="#AsyncCallback" class="headerlink" title="AsyncCallback"></a>AsyncCallback</h2><p>Zookeeper 的<code>exists</code>,<code>getData</code>,<code>getChildren</code>方法都有异步的版本，它们与同步方法的区别仅仅在于是否等待响应，底层发送都是通过<code>sendThread</code>异步发送的。下面我们用一幅图来说明：</p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/async.png" alt=""><br>上面的图展示了同步/异步调用<code>getData</code>的流程，其他方法也是类似的。</p>
<h2 id="IO__u4E0E_u4E8B_u4EF6_u5904_u7406"><a href="#IO__u4E0E_u4E8B_u4EF6_u5904_u7406" class="headerlink" title="IO 与事件处理"></a>IO 与事件处理</h2><p>Zookeeper 客户端会启动两个常驻线程</p>
<ul>
<li><code>SendThread</code>：负责 IO 操作，包括发送，接受响应，发送 ping 等。</li>
<li><code>EventThread</code>：负责处理事件，执行回调函数。</li>
</ul>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/event.png" alt=""></p>
<h3 id="readResponse"><a href="#readResponse" class="headerlink" title="readResponse"></a>readResponse</h3><p><code>readResponse</code>是<code>SendThread</code>处理响应的核心函数，核心逻辑如下：</p>
<ol>
<li>接受服务器的响应，并反序列化出<code>ReplyHeader</code>： 有一个单独的线程<code>SendThread</code>，负责接收服务器端的响应。假设接受到的服务器传递过来的字节流是<code>incomingBuffer</code>，那么就将这个<code>incomingBuffer</code>反序列化为<code>ReplyHeader</code>。</li>
<li><p>判断响应类型：判断<code>ReplyHeader</code>是<code>Watcher</code>响应还是<code>AsyncCallback</code>响应：<code>ReplyHeader.getXid()</code>存储了响应类型。</p>
<ol>
<li>如果是<code>Watcher</code>类型响应：从<code>ReplyHeader</code>中创建<code>WatchedEvent</code>，<code>WatchedEvent</code>里面存储了节点的路径，然后去<code>WatcherManager</code>中找到和这个节点相关联的所有<code>Watcher</code>，将他们写入到<code>EventThread</code>的<code>waitingEvents</code>中。</li>
<li>如果是<code>AsyncCallback</code>类型响应：从<code>ReplyHeader</code>中读取<code>response</code>，这个<code>response</code>描述了是<code>Exists，setData，getData，getChildren，create.....</code>中的哪一个异步回调。从<code>pendingQueue</code>中拿到<code>Packet</code>，<code>Packet</code>中的<code>cb</code>存储了<code>AsyncCallback</code>，也就是异步 API 的结果回调。最后将<code>Packet</code>写入到<code>EventThread</code>的<code>waitingEvents</code>中。</li>
</ol>
</li>
</ol>
<h3 id="processEvent"><a href="#processEvent" class="headerlink" title="processEvent"></a>processEvent</h3><p><code>processEvent</code>是<code>EventThread</code>处理事件核心函数，核心逻辑如下：</p>
<ol>
<li>如果<code>event instanceof WatcherSetEventPair</code>，取出<code>pair</code>中的<code>Watchers</code>，逐个调用<code>watcher.process(pair.event)</code></li>
<li>否则<code>event</code>为<code>AsyncCallback</code>，根据<code>p.response</code>判断为哪种响应类型，执行响应的回调<code>processResult</code>。</li>
</ol>
<p>可见，<code>Watcher</code>和<code>AsyncCallback</code>都是由<code>EventThread</code>处理的，通过<code>processEvent</code>进行区分处理。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>Zookeeper 客户端中<code>Watcher</code>和<code>AsyncCallback</code>都是异步回调的方式，但它们回调的时机是不一样的，前者是由服务器发送事件触发客户端回调，后者是在执行了请求后得到响应后客户端主动触发的。它们的共同点在于都需要在获取了服务器响应之后，由<code>SendThread</code>写入<code>EventThread</code>的<code>waitingEvents</code>中，然后由<code>EventThread</code>逐个从事件队列中获取并处理。</p>
<p><em>参考资料</em><br><a href="http://www.cnblogs.com/francisYoung/p/5225703.html" target="_blank" rel="external">ZooKeeper个人笔记客户端watcher和AsycCallback回调</a><br><a href="http://nileader.blog.51cto.com/1381108/954670" target="_blank" rel="external">【ZooKeeper Notes 13】ZooKeeper Watcher的事件通知类型</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>初学 Zookeeper 会发现客户端有两种回调方式： Watcher 和 AsyncCallback，]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[ThreadLocal 内存泄露的实例分析]]></title>
    <link href="http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/"/>
    <id>http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/</id>
    <published>2016-08-09T14:10:04.000Z</published>
    <updated>2016-08-09T14:21:32.930Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>之前写了一篇<a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/">深入分析 ThreadLocal 内存泄漏问题</a>是从理论上分析<code>ThreadLocal</code>的内存泄漏问题，这一篇文章我们来分析一下实际的内存泄漏案例。分析问题的过程比结果更重要，理论结合实际才能彻底分析出内存泄漏的原因。</p>
<h2 id="u6848_u4F8B_u4E0E_u5206_u6790"><a href="#u6848_u4F8B_u4E0E_u5206_u6790" class="headerlink" title="案例与分析"></a>案例与分析</h2><h3 id="u95EE_u9898_u80CC_u666F"><a href="#u95EE_u9898_u80CC_u666F" class="headerlink" title="问题背景"></a>问题背景</h3><p>在 Tomcat 中，下面的代码都在 webapp 内，会导致<code>WebappClassLoader</code>泄漏，无法被回收。</p>
<pre><code>public class MyCounter {
        private int count = 0;

        public void increment() {
                count++;
        }

        public int getCount() {
                return count;
        }
}

public class MyThreadLocal extends ThreadLocal&lt;MyCounter&gt; {
}

public class LeakingServlet extends HttpServlet {
        private static MyThreadLocal myThreadLocal = new MyThreadLocal();

        protected void doGet(HttpServletRequest request,
                        HttpServletResponse response) throws ServletException, IOException {

                MyCounter counter = myThreadLocal.get();
                if (counter == null) {
                        counter = new MyCounter();
                        myThreadLocal.set(counter);
                }

                response.getWriter().println(
                                &quot;The current thread served this servlet &quot; + counter.getCount()
                                                + &quot; times&quot;);
                counter.increment();
        }
}
</code></pre><p>上面的代码中，只要<code>LeakingServlet</code>被调用过一次，且执行它的线程没有停止，就会导致<code>WebappClassLoader</code>泄漏。每次你 reload 一下应用，就会多一份<code>WebappClassLoader</code>实例，最后导致 PermGen <code>OutOfMemoryException</code>。</p>
<h3 id="u89E3_u51B3_u95EE_u9898"><a href="#u89E3_u51B3_u95EE_u9898" class="headerlink" title="解决问题"></a>解决问题</h3><p>现在我们来思考一下：为什么上面的<code>ThreadLocal</code>子类会导致内存泄漏？</p>
<h4 id="WebappClassLoader"><a href="#WebappClassLoader" class="headerlink" title="WebappClassLoader"></a>WebappClassLoader</h4><p>首先，我们要搞清楚<code>WebappClassLoader</code>是什么鬼？</p>
<blockquote>
<p>对于运行在 Java EE容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。</p>
</blockquote>
<p>也就是说<code>WebappClassLoader</code>是 Tomcat 加载 webapp 的自定义类加载器，每个 webapp 的类加载器都是不一样的，这是为了隔离不同应用加载的类。</p>
<p>那么<code>WebappClassLoader</code>的特性跟内存泄漏有什么关系呢？目前还看不出来，但是它的一个很重要的特点值得我们注意：每个 webapp 都会自己的<code>WebappClassLoader</code>，这跟 Java 核心的类加载器不一样。</p>
<p>我们知道：导致<code>WebappClassLoader</code>泄漏必然是因为它被别的对象强引用了，那么我们可以尝试画出它们的引用关系图。等等！类加载器的作用到底是啥？为什么会被强引用？</p>
<h4 id="u7C7B_u7684_u751F_u547D_u5468_u671F_u4E0E_u7C7B_u52A0_u8F7D_u5668"><a href="#u7C7B_u7684_u751F_u547D_u5468_u671F_u4E0E_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="类的生命周期与类加载器"></a>类的生命周期与类加载器</h4><p>要解决上面的问题，我们得去研究一下类的生命周期和类加载器的关系。这个问题说起来又是一篇文章，参考我做的笔记<a href="http://wiki.xiaohansong.com/java/class_lifecycle.html" target="_blank" rel="external">类的生命周期</a>。</p>
<p>跟我们这个案例相关的主要是类的卸载：</p>
<p>在类使用完之后，如果满足下面的情况，类就会被卸载：</p>
<ol>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的<code>ClassLoader</code>已经被回收。</li>
<li>该类对应的<code>java.lang.Class</code>对象没有任何地方被引用，没有在任何地方通过反射访问该类的方法。</li>
</ol>
<p>如果以上三个条件全部满足，JVM 就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，Java 类的整个生命周期就结束了。</p>
<p>由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机自带的类加载器包括根类加载器、扩展类加载器和系统类加载器。Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。</p>
<p><strong>由用户自定义的类加载器加载的类是可以被卸载的。</strong></p>
<p>注意上面这句话，<code>WebappClassLoader</code>如果泄漏了，意味着它加载的类都无法被卸载，这就解释了为什么上面的代码会导致 PermGen <code>OutOfMemoryException</code>。</p>
<p>关键点看下面这幅图<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/111825528931093.png" alt=""></p>
<p>我们可以发现：类加载器对象跟它加载的 Class 对象是双向关联的。这意味着，Class 对象可能就是强引用<code>WebappClassLoader</code>，导致它泄漏的元凶。</p>
<h3 id="u5F15_u7528_u5173_u7CFB_u56FE"><a href="#u5F15_u7528_u5173_u7CFB_u56FE" class="headerlink" title="引用关系图"></a>引用关系图</h3><p>理解类加载器与类的生命周期的关系之后，我们可以开始画引用关系图了。（图中的<code>LeakingServlet.class</code>与<code>myThreadLocal</code>引用画的不严谨，主要是想表达<code>myThreadLocal</code>是类变量的意思）<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/leak_1.png" alt="leak_1"></p>
<p>下面，我们根据上面的图来分析<code>WebappClassLoader</code>泄漏的原因。</p>
<ol>
<li><code>LeakingServlet</code>持有<code>static</code>的<code>MyThreadLocal</code>，导致<code>myThreadLocal</code>的生命周期跟<code>LeakingServlet</code>类的生命周期一样长。意味着<code>myThreadLocal</code>不会被回收，弱引用形同虚设，所以当前线程无法通过<code>ThreadLocalMap</code>的防护措施清除<code>counter</code>的强引用（见<a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/">深入分析 ThreadLocal 内存泄漏问题</a>）。</li>
<li>强引用链：<code>thread -&gt; threadLocalMap -&gt; counter -&gt; MyCounter.class -&gt; WebappClassLocader</code>，导致<code>WebappClassLoader</code>泄漏。</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>内存泄漏是很难发现的问题，往往由于多方面原因造成。<code>ThreadLocal</code>由于它与线程绑定的生命周期成为了内存泄漏的常客，稍有不慎就酿成大祸。</p>
<p>本文只是对一个特定案例的分析，若能以此举一反三，那便是极好的。最后我留另一个类似的案例供读者分析。</p>
<h2 id="u8BFE_u540E_u9898"><a href="#u8BFE_u540E_u9898" class="headerlink" title="课后题"></a>课后题</h2><p>假设我们有一个定义在 Tomcat Common Classpath 下的类（例如说在 <code>tomcat/lib</code> 目录下）</p>
<pre><code>public class ThreadScopedHolder {
        private final static ThreadLocal&lt;Object&gt; threadLocal = new ThreadLocal&lt;Object&gt;();

        public static void saveInHolder(Object o) {
                threadLocal.set(o);
        }

        public static Object getFromHolder() {
                return threadLocal.get();
        }
}
</code></pre><p>两个在 webapp 的类：</p>
<pre><code>public class MyCounter {
        private int count = 0;

        public void increment() {
                count++;
        }

        public int getCount() {
                return count;
        }
}
public class LeakingServlet extends HttpServlet {

        protected void doGet(HttpServletRequest request,
                        HttpServletResponse response) throws ServletException, IOException {

                MyCounter counter = (MyCounter)ThreadScopedHolder.getFromHolder();
                if (counter == null) {
                        counter = new MyCounter();
                        ThreadScopedHolder.saveInHolder(counter);
                }

                response.getWriter().println(
                                &quot;The current thread served this servlet &quot; + counter.getCount()
                                                + &quot; times&quot;);
                counter.increment();
        }
}
</code></pre><h3 id="u63D0_u793A"><a href="#u63D0_u793A" class="headerlink" title="提示"></a>提示</h3><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/leak_2.png" alt="leak_2"></p>
<p><strong>欢迎大家批评指正，留言交流。</strong></p>
<p><em>参考文章</em><br><a href="http://www.tuicool.com/articles/6BJJzin" target="_blank" rel="external">ClassLoader内存溢出-从tomcat的reload说起</a><br><a href="http://blog.csdn.net/u010723709/article/details/50291315" target="_blank" rel="external">类加载器内存泄露与tomcat自定义加载器</a><br><a href="http://wiki.xiaohansong.com/java/class_lifecycle.html" target="_blank" rel="external">类的生命周期</a><br><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/">深入分析 ThreadLocal 内存泄漏问题</a><br><a href="http://lengyun3566.iteye.com/blog/1683972" target="_blank" rel="external">Tomcat源码解读系列（四）——Tomcat类加载机制概述</a><br><a href="https://wiki.apache.org/tomcat/MemoryLeakProtection" target="_blank" rel="external">MemoryLeakProtection</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>之前写了一篇<a href="http://blog.xiaohansong.com/2016/08/0]]>
    </summary>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="http://blog.xiaohansong.com/tags/ThreadLocal/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入分析 ThreadLocal 内存泄漏问题]]></title>
    <link href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/"/>
    <id>http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/</id>
    <published>2016-08-06T12:12:16.000Z</published>
    <updated>2016-08-09T14:21:23.293Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>ThreadLocal</code> 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。但是如果滥用 <code>ThreadLocal</code>，就可能会导致内存泄漏。下面，我们将围绕三个方面来分析 <code>ThreadLocal</code> 内存泄漏的问题</p>
<ul>
<li><code>ThreadLocal</code> 实现原理</li>
<li><code>ThreadLocal</code>为什么会内存泄漏</li>
<li><code>ThreadLocal</code> 最佳实践</li>
</ul>
<h2 id="ThreadLocal__u5B9E_u73B0_u539F_u7406"><a href="#ThreadLocal__u5B9E_u73B0_u539F_u7406" class="headerlink" title="ThreadLocal 实现原理"></a>ThreadLocal 实现原理</h2><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/threadlocal.jpg" alt="ThreadLocal"><br><code>ThreadLocal</code>的实现是这样的：每个<code>Thread</code> 维护一个 <code>ThreadLocalMap</code> 映射表，这个映射表的 <code>key</code> 是 <code>ThreadLocal</code> 实例本身，<code>value</code> 是真正需要存储的 <code>Object</code>。</p>
<p>也就是说 <code>ThreadLocal</code> 本身并不存储值，它只是作为一个 <code>key</code> 来让线程从 <code>ThreadLocalMap</code> 获取 <code>value</code>。值得注意的是图中的虚线，表示 <code>ThreadLocalMap</code> 是使用 <code>ThreadLocal</code> 的弱引用作为 <code>Key</code> 的，弱引用的对象在 GC 时会被回收。</p>
<h2 id="ThreadLocal_u4E3A_u4EC0_u4E48_u4F1A_u5185_u5B58_u6CC4_u6F0F"><a href="#ThreadLocal_u4E3A_u4EC0_u4E48_u4F1A_u5185_u5B58_u6CC4_u6F0F" class="headerlink" title="ThreadLocal为什么会内存泄漏"></a><code>ThreadLocal</code>为什么会内存泄漏</h2><p><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有外部强引用来引用它，那么系统 GC 的时候，这个<code>ThreadLocal</code>势必会被回收，这样一来，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就没有办法访问这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>，如果当前线程再迟迟不结束的话，这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄漏。</p>
<p>其实，<code>ThreadLocalMap</code>的设计中已经考虑到这种情况，也加上了一些防护措施：在<code>ThreadLocal</code>的<code>get()</code>,<code>set()</code>,<code>remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。</p>
<p>但是这些被动的预防措施并不能保证不会内存泄漏：</p>
<ul>
<li>使用<code>static</code>的<code>ThreadLocal</code>，延长了<code>ThreadLocal</code>的生命周期，可能导致的内存泄漏（参考<a href="http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/">ThreadLocal 内存泄露的实例分析</a>）。</li>
<li>分配使用了<code>ThreadLocal</code>又不再调用<code>get()</code>,<code>set()</code>,<code>remove()</code>方法，那么就会导致内存泄漏。</li>
</ul>
<h3 id="u4E3A_u4EC0_u4E48_u4F7F_u7528_u5F31_u5F15_u7528"><a href="#u4E3A_u4EC0_u4E48_u4F7F_u7528_u5F31_u5F15_u7528" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h3><p>从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析<code>ThreadLocal</code>使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？</p>
<p>我们先来看看官方文档的说法：</p>
<blockquote>
<p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了应对非常大和长时间的用途，哈希表使用弱引用的 key。</p>
</blockquote>
<p>下面我们分两种情况讨论：</p>
<ul>
<li><strong>key 使用强引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>不会被回收，导致<code>Entry</code>内存泄漏。</li>
<li><strong>key 使用弱引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，由于<code>ThreadLocalMap</code>持有<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>,<code>get</code>，<code>remove</code>的时候会被清除。</li>
</ul>
<p>比较两种情况，我们可以发现：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果都没有手动删除对应<code>key</code>，都会导致内存泄漏，但是使用弱引用可以多一层保障：<strong>弱引用<code>ThreadLocal</code>不会内存泄漏，对应的<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>,<code>get</code>,<code>remove</code>的时候会被清除</strong>。</p>
<p>因此，<code>ThreadLocal</code>内存泄漏的根源是：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果没有手动删除对应<code>key</code>就会导致内存泄漏，而不是因为弱引用。</p>
<h2 id="ThreadLocal__u6700_u4F73_u5B9E_u8DF5"><a href="#ThreadLocal__u6700_u4F73_u5B9E_u8DF5" class="headerlink" title="ThreadLocal 最佳实践"></a>ThreadLocal 最佳实践</h2><p>综合上面的分析，我们可以理解<code>ThreadLocal</code>内存泄漏的前因后果，那么怎么避免内存泄漏呢？</p>
<ul>
<li>每次使用完<code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据。</li>
</ul>
<p>在使用线程池的情况下，没有及时清理<code>ThreadLocal</code>，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用<code>ThreadLocal</code>就跟加锁完要解锁一样，用完就清理。</p>
<p><em>参考文章</em><br><a href="http://qifuguang.me/2015/09/02/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83%5D%E8%A7%A3%E5%AF%86ThreadLocal/" target="_blank" rel="external">Java并发包学习七 解密ThreadLocal</a><br><a href="http://www.cnblogs.com/onlywujun/p/3524675.html" target="_blank" rel="external">ThreadLocal可能引起的内存泄露</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>ThreadLocal</code> 的作用是提供线程内的局部变量，这种变量在线程的生命周期]]>
    </summary>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="http://blog.xiaohansong.com/tags/ThreadLocal/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Getty】Java NIO框架设计与实现]]></title>
    <link href="http://blog.xiaohansong.com/2016/07/30/getty/"/>
    <id>http://blog.xiaohansong.com/2016/07/30/getty/</id>
    <published>2016-07-30T02:42:23.000Z</published>
    <updated>2016-07-30T03:14:39.521Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/x-hansong/Getty" target="_blank" rel="external">Getty</a>是我为了学习 Java NIO 所写的一个 NIO 框架，实现过程中参考了 Netty 的设计，同时使用 Groovy 来实现。虽然只是玩具，但是麻雀虽小，五脏俱全，在实现过程中，不仅熟悉了 NIO 的使用，还借鉴了很多 Netty 的设计思想，提升了自己的编码和设计能力。</p>
<p>至于为什么用 Groovy 来写，因为我刚学了 Groovy，正好拿来练手，加上 Groovy 是兼容 Java 的，所以只是语法上的差别，底层实现还是基于 Java API的。</p>
<p>Getty 的核心代码行数不超过 500 行，一方面得益于 Groovy 简洁的语法，另一方面是因为我只实现了核心的逻辑，最复杂的其实是解码器实现。脚手架容易搭，摩天大楼哪有那么容易盖，但用来学习 NIO 足以。</p>
<h2 id="u7EBF_u7A0B_u6A21_u578B"><a href="#u7EBF_u7A0B_u6A21_u578B" class="headerlink" title="线程模型"></a>线程模型</h2><p>Getty 使用的是 Reactor 多线程模型<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/getty-1.png" alt="reactor"></p>
<ol>
<li>有专门一个 NIO 线程- Acceptor 线程用于监听服务端，接收客户端的 TCP 连接请求，然后将连接分配给工作线程，由工作线程来监听读写事件。</li>
<li>网络 IO 操作-读/写等由多个工作线程负责，由这些工作线程负责消息的读取、解码、编码和发送。</li>
<li>1 个工作线程可以同时处理N条链路，但是 1 个链路只对应 1 个工作线程，防止发生并发操作问题。</li>
</ol>
<h2 id="u4E8B_u4EF6_u9A71_u52A8_u6A21_u578B"><a href="#u4E8B_u4EF6_u9A71_u52A8_u6A21_u578B" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h2><p>整个服务端的流程处理，建立于事件机制上。在 [接受连接－＞读－＞业务处理－＞写 －＞关闭连接 ]这个过程中，触发器将触发相应事件，由事件处理器对相应事件分别响应，完成服务器端的业务处理。</p>
<h3 id="u4E8B_u4EF6_u5B9A_u4E49"><a href="#u4E8B_u4EF6_u5B9A_u4E49" class="headerlink" title="事件定义"></a>事件定义</h3><ol>
<li><code>onRead</code>：当客户端发来数据，并已被工作线程正确读取时，触发该事件 。该事件通知各事件处理器可以对客户端发来的数据进行实际处理了。</li>
<li><code>onWrite</code>：当客户端可以开始接受服务端发送数据时触发该事件，通过该事件，我们可以向客户端发送响应数据。（当前的实现中并未使用写事件）</li>
<li><code>onClosed</code>：当客户端与服务器断开连接时触发该事件。</li>
</ol>
<h3 id="u4E8B_u4EF6_u56DE_u8C03_u673A_u5236_u7684_u5B9E_u73B0"><a href="#u4E8B_u4EF6_u56DE_u8C03_u673A_u5236_u7684_u5B9E_u73B0" class="headerlink" title="事件回调机制的实现"></a>事件回调机制的实现</h3><p>在这个模型中，事件采用广播方式，也就是所有注册的事件处理器都能获得事件通知。这样可以将不同性质的业务处理，分别用不同的处理器实现，使每个处理器的功能尽可能单一。</p>
<p>如下图：整个事件模型由监听器、事件适配器、事件触发器（HandlerChain，PipeLine）、事件处理器组成。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/getty-2.png" alt="event"></p>
<ul>
<li><p><code>ServerListener</code>：这是一个事件接口，定义需监听的服务器事件</p>
<pre><code>interface ServerListener extends Serializable{
    /**
     * 可读事件回调
     * @param request
     */
    void onRead(ctx)
    /**
     * 可写事件回调
     * @param request
     * @param response
     */
    void onWrite(ctx)
    /**
     * 连接关闭回调
     * @param request
     */
    void onClosed(ctx)
}
</code></pre></li>
<li><p><code>EventAdapter</code>：对 Serverlistener 接口实现一个适配器 (EventAdapter)，这样的好处是最终的事件处理器可以只处理所关心的事件。</p>
<pre><code>class EventAdapter implements ServerListener {
    //下个处理器的引用
    protected next
    void onRead(Object ctx) {
    }
    void onWrite(Object ctx) {
    }
    void onClosed(Object ctx) {
    }
}
</code></pre></li>
<li><p><code>Notifier</code>：用于在适当的时候通过触发服务器事件，通知在册的事件处理器对事件做出响应。</p>
<pre><code>interface Notifier extends Serializable{
    /**
     * 触发所有可读事件回调
     */
    void fireOnRead(ctx)
    /**
     * 触发所有可写事件回调
     */
    void fireOnWrite(ctx)
    /**
     * 触发所有连接关闭事件回调
     */
    void fireOnClosed(ctx)
}
</code></pre></li>
<li><p><code>HandlerChain</code>：实现了<code>Notifier</code>接口，维持有序的事件处理器链条，每次从第一个处理器开始触发。</p>
<pre><code>class HandlerChain implements Notifier{
    EventAdapter head
    EventAdapter tail
    /**
     * 添加处理器到执行链的最后
     * @param handler
     */
    void addLast(handler) {
        if (tail != null) {
            tail.next = handler
            tail = tail.next
        } else {
            head = handler
            tail = head
        }
    }
    void fireOnRead(ctx) {
        head.onRead(ctx)
    }
    void fireOnWrite(ctx) {
        head.onWrite(ctx)
    }
    void fireOnClosed(ctx) {
        head.onClosed(ctx)
    }
}
</code></pre></li>
<li><p><code>PipeLine</code>：实现了<code>Notifier</code>接口，作为事件总线，维持一个事件链的列表。</p>
<pre><code>class PipeLine implements Notifier{
    static logger = LoggerFactory.getLogger(PipeLine.name)
    //监听器队列
    def listOfChain = []
    PipeLine(){}
    /**
     * 添加监听器到监听队列中
     * @param chain
     */
    void addChain(chain) {
        synchronized (listOfChain) {
            if (!listOfChain.contains(chain)) {
                listOfChain.add(chain)
            }
        }
    }
    /**
     * 触发所有可读事件回调
     */
    void fireOnRead(ctx) {
        logger.debug(&quot;fireOnRead&quot;)
        listOfChain.each { chain -&gt;
            chain.fireOnRead(ctx)
        }
    }
    /**
     * 触发所有可写事件回调
     */
    void fireOnWrite(ctx) {
        listOfChain.each { chain -&gt;
            chain.fireOnWrite(ctx)
        }
    }
    /**
     * 触发所有连接关闭事件回调
     */
    void fireOnClosed(ctx) {
        listOfChain.each { chain -&gt;
            chain.fireOnClosed(ctx)
        }
    }
}
</code></pre></li>
</ul>
<h3 id="u4E8B_u4EF6_u5904_u7406_u6D41_u7A0B"><a href="#u4E8B_u4EF6_u5904_u7406_u6D41_u7A0B" class="headerlink" title="事件处理流程"></a>事件处理流程</h3><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/getty-3.png" alt="编程模型"><br>事件处理采用职责链模式，每个处理器处理完数据之后会决定是否继续执行下一个处理器。如果处理器不将任务交给线程池处理，那么整个处理流程都在同一个线程中处理。而且每个连接都有单独的<code>PipeLine</code>，工作线程可以在多个连接上下文切换，但是一个连接上下文只会被一个线程处理。</p>
<h2 id="u6838_u5FC3_u7C7B"><a href="#u6838_u5FC3_u7C7B" class="headerlink" title="核心类"></a>核心类</h2><h3 id="ConnectionCtx"><a href="#ConnectionCtx" class="headerlink" title="ConnectionCtx"></a>ConnectionCtx</h3><p>连接上下文<code>ConnectionCtx</code></p>
<pre><code>class ConnectionCtx {
    /**socket连接*/
    SocketChannel channel
    /**用于携带额外参数*/
    Object attachment
    /**处理当前连接的工作线程*/
    Worker worker
    /**连接超时时间*/
    Long timeout
    /**每个连接拥有自己的pipeline*/
    PipeLine pipeLine
}
</code></pre><h3 id="NioServer"><a href="#NioServer" class="headerlink" title="NioServer"></a>NioServer</h3><p>主线程负责监听端口，持有工作线程的引用（使用轮转法分配连接），每次有连接到来时，将连接放入工作线程的连接队列，并唤醒线程<code>selector.wakeup()</code>（线程可能阻塞在<code>selector</code>上）。</p>
<pre><code>class NioServer extends Thread {
    /**服务端的套接字通道*/
    ServerSocketChannel ssc
    /**选择器*/
    Selector selector
    /**事件总线*/
    PipeLine pipeLine
    /**工作线程列表*/
    def workers = []
    /**当前工作线程索引*/
    int index
}
</code></pre><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>工作线程，负责注册server传递过来的socket连接。主要监听读事件，管理socket，处理写操作。</p>
<pre><code>class Worker extends Thread {
    /**选择器*/
    Selector selector
    /**读缓冲区*/
    ByteBuffer buffer
    /**主线程分配的连接队列*/
    def queue = []
    /**存储按超时时间从小到大的连接*/
    TreeMap&lt;Long, ConnectionCtx&gt; ctxTreeMap

    void run() {
        while (true) {
            selector.select()
            //注册主线程发送过来的连接
            registerCtx()
            //关闭超时的连接
            closeTimeoutCtx()
            //处理事件
            dispatchEvent()
        }
    }
}
</code></pre><h2 id="u8FD0_u884C_u4E00_u4E2A_u7B80_u5355_u7684_Web__u670D_u52A1_u5668"><a href="#u8FD0_u884C_u4E00_u4E2A_u7B80_u5355_u7684_Web__u670D_u52A1_u5668" class="headerlink" title="运行一个简单的 Web 服务器"></a>运行一个简单的 Web 服务器</h2><p>我实现了一系列处理<code>HTTP</code>请求的处理器，具体实现看代码。</p>
<ul>
<li><code>LineBasedDecoder</code>：行解码器，按行解析数据</li>
<li><code>HttpRequestDecoder</code>：HTTP请求解析，目前只支持GET请求</li>
<li><code>HttpRequestHandler</code>：Http 请求处理器，目前只支持GET方法</li>
<li><code>HttpResponseHandler</code>：Http响应处理器</li>
</ul>
<p>下面是写在<code>test</code>中的例子</p>
<pre><code>class WebServerTest {
    static void main(args) {
        def pipeLine = new PipeLine()

        def readChain = new HandlerChain()
        readChain.addLast(new LineBasedDecoder())
        readChain.addLast(new HttpRequestDecoder())
        readChain.addLast(new HttpRequestHandler())
        readChain.addLast(new HttpResponseHandler())

        def closeChain = new HandlerChain()
        closeChain.addLast(new ClosedHandler())

        pipeLine.addChain(readChain)
        pipeLine.addChain(closeChain)

        NioServer nioServer = new NioServer(pipeLine)
        nioServer.start()
    }
}
</code></pre><p>另外，还可以使用配置文件<code>getty.properties</code>设置程序的运行参数。</p>
<pre><code>#用于拼接消息时使用的二进制数组的缓存区
common_buffer_size=1024
#工作线程读取tcp数据的缓存大小
worker_rcv_buffer_size=1024
#监听的端口
port=4399
#工作线程的数量
worker_num=1
#连接超时自动断开时间
timeout=900
#根目录
root=.
</code></pre><h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p><a href="https://github.com/x-hansong/Getty" target="_blank" rel="external">Getty</a>是我造的第二个小轮子，第一个是<a href="https://github.com/x-hansong/RedisHttpSession" target="_blank" rel="external">RedisHttpSession</a>。都说不要重复造轮子。这话我是认同的，但是掌握一门技术最好的方法就是实践，在没有合适项目可以使用新技术的时候，造一个简单的轮子是不错的实践手段。</p>
<p><a href="https://github.com/x-hansong/Getty" target="_blank" rel="external">Getty</a> 的缺点或者说还可以优化的点：</p>
<ol>
<li>线程的使用直接用了<code>Thread</code>类，看起来有点low。等以后水平提升了再来抽象一下。</li>
<li>目前只有读事件是异步的，写事件是同步的。未来将写事件也改为异步的。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/x-hansong/Getty" target=]]>
    </summary>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/tags/Java/"/>
    
      <category term="NIO" scheme="http://blog.xiaohansong.com/tags/NIO/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 线程池框架核心代码分析]]></title>
    <link href="http://blog.xiaohansong.com/2016/07/12/java-executor/"/>
    <id>http://blog.xiaohansong.com/2016/07/12/java-executor/</id>
    <published>2016-07-11T16:13:44.000Z</published>
    <updated>2016-08-13T14:35:47.881Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>多线程编程中，为每个任务分配一个线程是不现实的，线程创建的开销和资源消耗都是很高的。线程池应运而生，成为我们管理线程的利器。Java 通过<code>Executor</code>接口，提供了一种标准的方法将任务的提交过程和执行过程解耦开来，并用<code>Runnable</code>表示任务。</p>
<p>下面，我们来分析一下 Java 线程池框架的实现<code>ThreadPoolExecutor</code>。</p>
<p><em>下面的分析基于JDK1.7</em></p>
<h2 id="u751F_u547D_u5468_u671F"><a href="#u751F_u547D_u5468_u671F" class="headerlink" title="生命周期"></a>生命周期</h2><p><code>ThreadPoolExecutor</code>中，使用<code>CAPACITY</code>的高3位来表示运行状态，分别是：</p>
<ol>
<li>RUNNING：接收新任务，并且处理任务队列中的任务</li>
<li>SHUTDOWN：不接收新任务，但是处理任务队列的任务</li>
<li>STOP：不接收新任务，不处理任务队列，同时中断所有进行中的任务</li>
<li>TIDYING：所有任务已经被终止，工作线程数量为 0，到达该状态会执行<code>terminated()</code></li>
<li>TERMINATED：<code>terminated()</code>执行完毕</li>
</ol>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/executor_lifecycle.png" alt="状态转换图"><br><code>ThreadPoolExecutor</code>中用原子类来表示状态位</p>
<pre><code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
</code></pre><h2 id="u7EBF_u7A0B_u6C60_u6A21_u578B"><a href="#u7EBF_u7A0B_u6C60_u6A21_u578B" class="headerlink" title="线程池模型"></a>线程池模型</h2><h3 id="u6838_u5FC3_u53C2_u6570"><a href="#u6838_u5FC3_u53C2_u6570" class="headerlink" title="核心参数"></a>核心参数</h3><ul>
<li><code>corePoolSize</code>：最小存活的工作线程数量（如果设置<code>allowCoreThreadTimeOut</code>，那么该值为 0）</li>
<li><code>maximumPoolSize</code>：最大的线程数量，受限于<code>CAPACITY</code></li>
<li><code>keepAliveTime</code>：对应线程的存活时间，时间单位由TimeUnit指定</li>
<li><code>workQueue</code>：工作队列，存储待执行的任务</li>
<li><code>RejectExecutionHandler</code>：拒绝策略，线程池满后会触发</li>
</ul>
<p><strong>线程池的最大容量</strong>：<code>CAPACITY</code>中的前三位用作标志位，也就是说工作线程的最大容量为<code>(2^29)-1</code></p>
<h3 id="u56DB_u79CD_u6A21_u578B"><a href="#u56DB_u79CD_u6A21_u578B" class="headerlink" title="四种模型"></a>四种模型</h3><ul>
<li><code>CachedThreadPool</code>：一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，当需求增加时，则可以添加新的线程，线程池的规模不存在任何的限制。</li>
<li><code>FixedThreadPool</code>：一个固定大小的线程池，提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的大小将不再变化。</li>
<li><code>SingleThreadPool</code>：一个单线程的线程池，它只有一个工作线程来执行任务，可以确保按照任务在队列中的顺序来串行执行，如果这个线程异常结束将创建一个新的线程来执行任务。</li>
<li><code>ScheduledThreadPool</code>：一个固定大小的线程池，并且以延迟或者定时的方式来执行任务，类似于Timer。</li>
</ul>
<h2 id="u6267_u884C_u4EFB_u52A1_execute"><a href="#u6267_u884C_u4EFB_u52A1_execute" class="headerlink" title="执行任务 execute"></a>执行任务 execute</h2><p>核心逻辑：</p>
<ol>
<li>当前线程数量 &lt; <code>corePoolSize</code>，直接开启新的核心线程执行任务<code>addWorker(command, true)</code></li>
<li><p>当前线程数量 &gt;= <code>corePoolSize</code>，且任务加入工作队列成功</p>
<ol>
<li>检查线程池当前状态是否处于<code>RUNNING</code></li>
<li>如果否，则拒绝该任务</li>
<li>如果是，判断当前线程数量是否为 0，如果为 0，就增加一个工作线程。</li>
</ol>
</li>
<li>开启普通线程执行任务<code>addWorker(command, false)</code>，开启失败就拒绝该任务</li>
</ol>
<p>从上面的分析可以总结出线程池运行的四个阶段：</p>
<ol>
<li><code>poolSize &lt; corePoolSize</code> 且队列为空，此时会新建线程来处理提交的任务</li>
<li><code>poolSize == corePoolSize</code>，此时提交的任务进入工作队列，工作线程从队列中获取任务执行，此时队列不为空且未满。</li>
<li><code>poolSize == corePoolSize</code>，并且队列已满，此时也会新建线程来处理提交的任务，但是<code>poolSize &lt; maxPoolSize</code></li>
<li><code>poolSize == maxPoolSize</code>，并且队列已满，此时会触发拒绝策略</li>
</ol>
<h2 id="u62D2_u7EDD_u7B56_u7565"><a href="#u62D2_u7EDD_u7B56_u7565" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>前面我们提到任务无法执行会被拒绝，<code>RejectedExecutionHandler</code>是处理被拒绝任务的接口。下面是四种拒绝策略。</p>
<ul>
<li><code>AbortPolicy</code>：默认策略，终止任务，抛出RejectedException</li>
<li><code>CallerRunsPolicy</code>：在调用者线程执行当前任务，不抛异常</li>
<li><code>DiscardPolicy</code>： 抛弃策略，直接丢弃任务，不抛异常</li>
<li><code>DiscardOldersPolicy</code>：抛弃最老的任务，执行当前任务，不抛异常</li>
</ul>
<h2 id="u7EBF_u7A0B_u6C60_u4E2D_u7684_Worker"><a href="#u7EBF_u7A0B_u6C60_u4E2D_u7684_Worker" class="headerlink" title="线程池中的 Worker"></a>线程池中的 Worker</h2><p><code>Worker</code>继承了<code>AbstractQueuedSynchronizer</code>和<code>Runnable</code>，前者给<code>Worker</code>提供锁的功能，后者执行工作线程的主要方法<code>runWorker(Worker w)</code>（从任务队列捞任务执行）。Worker 引用存在<code>workers</code>集合里面，用<code>mainLock</code>守护。</p>
<pre><code>private final ReentrantLock mainLock = new ReentrantLock();
private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();
</code></pre><h3 id="u6838_u5FC3_u51FD_u6570_runWorker"><a href="#u6838_u5FC3_u51FD_u6570_runWorker" class="headerlink" title="核心函数 runWorker"></a>核心函数 runWorker</h3><p>下面是简化的逻辑，注意：每个工作线程的<code>run</code>都执行下面的函数</p>
<pre><code>final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    while (task != null || (task = getTask()) != null) {
        w.lock();
        beforeExecute(wt, task);
        task.run();
        afterExecute(task, thrown);
        w.unlock();
    }
    processWorkerExit(w, completedAbruptly);
}
</code></pre><ol>
<li>从<code>getTask()</code>中获取任务</li>
<li>锁住 worker</li>
<li>执行<code>beforeExecute(wt, task)</code>，这是<code>ThreadPoolExecutor</code>提供给子类的扩展方法</li>
<li>运行任务，如果该worker有配置了首次任务，则先执行首次任务且只执行一次。</li>
<li>执行<code>afterExecute(task, thrown);</code></li>
<li>解锁 worker</li>
<li>如果获取到的任务为 null，关闭 worker</li>
</ol>
<h2 id="u83B7_u53D6_u4EFB_u52A1_getTask"><a href="#u83B7_u53D6_u4EFB_u52A1_getTask" class="headerlink" title="获取任务 getTask"></a>获取任务 getTask</h2><p>线程池内部的任务队列是一个阻塞队列，具体实现在构造时传入。</p>
<pre><code>private final BlockingQueue&lt;Runnable&gt; workQueue;
</code></pre><p><code>getTask()</code>从任务队列中获取任务，支持阻塞和超时等待任务，四种情况会导致返回<code>null</code>，让<code>worker</code>关闭。</p>
<ol>
<li>现有的线程数量超过最大线程数量</li>
<li>线程池处于<code>STOP</code>状态</li>
<li>线程池处于<code>SHUTDOWN</code>状态且工作队列为空</li>
<li>线程等待任务超时，且线程数量超过保留线程数量</li>
</ol>
<p>核心逻辑：根据<code>timed</code>在阻塞队列上超时等待或者阻塞等待任务，等待任务超时会导致工作线程被关闭。</p>
<pre><code>timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;
Runnable r = timed ?
    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
    workQueue.take();
</code></pre><p>在以下两种情况下等待任务会超时：</p>
<ol>
<li>允许核心线程等待超时，即<code>allowCoreThreadTimeOut(true)</code></li>
<li>当前线程是普通线程，此时<code>wc &gt; corePoolSize</code></li>
</ol>
<p>工作队列使用的是<code>BlockingQueue</code>，这里就不展开了，后面再写一篇详细的分析。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>ThreadPoolExecutor</code>基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。</li>
<li><code>Executors</code>提供了四种基于<code>ThreadPoolExecutor</code>构造线程池模型的方法，除此之外，我们还可以直接继承<code>ThreadPoolExecutor</code>，重写<code>beforeExecute</code>和<code>afterExecute</code>方法来定制线程池任务执行过程。</li>
<li>使用有界队列还是无界队列需要根据具体情况考虑，工作队列的大小和线程的数量也是需要好好考虑的。</li>
<li>拒绝策略推荐使用<code>CallerRunsPolicy</code>，该策略不会抛弃任务，也不会抛出异常，而是将任务回退到调用者线程中执行。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>多线程编程中，为每个任务分配一个线程是不现实的，线程创建的开销和资源消耗都是很高的。线程池应运而生，成为]]>
    </summary>
    
      <category term="Executor" scheme="http://blog.xiaohansong.com/tags/Executor/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/tags/Java/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RedisHttpSession 的设计与实现]]></title>
    <link href="http://blog.xiaohansong.com/2016/05/15/RedisHttpSession/"/>
    <id>http://blog.xiaohansong.com/2016/05/15/RedisHttpSession/</id>
    <published>2016-05-15T02:49:39.000Z</published>
    <updated>2016-08-13T14:37:59.220Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/x-hansong/RedisHttpSession" target="_blank" rel="external">RedisHttpSession</a> 是我的一个 Java 开源项目，通过将 Session 存储在 Redis 中实现多服务器间共享 Session，同时这一过程是完全透明的。主要用于支持 RESTfuls API。下面我将对其核心类进行分析，阐述它的设计以及实现细节。</p>
<h2 id="RedisHttpSession"><a href="#RedisHttpSession" class="headerlink" title="RedisHttpSession"></a>RedisHttpSession</h2><p>这个类实现了<code>HttpSession</code>接口，用于替换默认的<code>HttpSession</code>实现。<code>RedisHttpSession</code>将<code>HttpSession</code>的接口方法重写了一遍，将<code>HttpSession</code>的属性存储到了 Redis 中。</p>
<p>每个<code>RedisHttpSession</code>都有一个 UUID 与之对应，该字段加上<code>session:</code>前缀作为存储在 Redis 中的键值。例如：</p>
<pre><code>localhost:63679&gt; keys *
1) &quot;session:fd9ec3cf-fb9b-4672-ade6-67a810e7db9f&quot;
2) &quot;session:cbaa057c-85a4-475d-b399-38c320e85dcc&quot;
3) &quot;session:13e030f5-de3d-458f-8d25-fd5643c40ff0&quot;
4) &quot;session:262596b3-3d13-4df1-8328-714153c1ae83&quot;
5) &quot;session:0b7d04c6-eaac-4eed-a9aa-8366f25f04f0&quot;
</code></pre><p>同时，<code>RedisHttpSession</code>中的属性是直接序列化成字节数组存储在 Redis 中的，存储在对应键中的哈希表里面。例如：</p>
<pre><code>localhost:63679&gt; hgetall session:fd9ec3cf-fb9b-4672-ade6-67a810e7db9f
1) &quot;lastAccessedTime&quot;
2) &quot;\xac\xed\x00\x05sr\x00\x0ejava.lang.Long;\x8b\xe4\x90\xcc\x8f#\xdf\x02\x00\x01J\x00\x05valuexr\x00\x10java.lang.Number\x86\xac\x95\x1d\x0b\x94\xe0\x8b\x02\x00\x00xp\x00\x00\x01T\x91\x03\&quot;\xec&quot;
3) &quot;maxInactiveInterval&quot;
4) &quot;\xac\xed\x00\x05sr\x00\x11java.lang.Integer\x12\xe2\xa0\xa4\xf7\x81\x878\x02\x00\x01I\x00\x05valuexr\x00\x10java.lang.Number\x86\xac\x95\x1d\x0b\x94\xe0\x8b\x02\x00\x00xp\x00\x00\a\b&quot;
5) &quot;creationTime&quot;
6) &quot;\xac\xed\x00\x05sr\x00\x0ejava.lang.Long;\x8b\xe4\x90\xcc\x8f#\xdf\x02\x00\x01J\x00\x05valuexr\x00\x10java.lang.Number\x86\xac\x95\x1d\x0b\x94\xe0\x8b\x02\x00\x00xp\x00\x00\x01T\x91\x03\&quot;\xb4&quot;
</code></pre><p>另外，Session 的自动过期是通过 Redis 设置键的过期时间实现的。</p>
<h2 id="RedisHttpSessionProxy"><a href="#RedisHttpSessionProxy" class="headerlink" title="RedisHttpSessionProxy"></a>RedisHttpSessionProxy</h2><p><code>RedisHttpSessionProxy</code>是<code>RedisHttpSession</code>的代理类，使用了 JDK 的动态代理。为什么要引入代理？这是基于下面的考虑做出的设计。</p>
<ol>
<li>由于 Session 存储在 Redis 中，在执行每个<code>RedisHttpSession</code>的接口方法之前都需要检查 Redis 连接是否可用。</li>
<li>访问一个已经被注销的 Session 需要抛出异常。</li>
<li>每次访问 Session 需要刷新过期时间和最后访问时间。</li>
</ol>
<p>基于上面的考虑，对于每个<code>RedisHttpSession</code>的接口方法，我们都需要进行重复的操作，因此使用动态代理对每个接口方法进行增强是最合适的。代码如下：</p>
<pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    RedisHttpSession session = (RedisHttpSession) originalObj;
    //check redis connection
    RedisConnection connection = session.getRedisConnection();
    if (!connection.isConnected()){
        connection.close();
        session.setRedisConnection(repository.getRedisConnection());
    }
    //For every methods of interface, check it valid or not
    if (session.isInvalidated()){
        throw new IllegalStateException(&quot;The HttpSession has already be invalidated.&quot;);
    } else {
        Object result =  method.invoke(originalObj, args);
        //if not invalidate method, refresh expireTime and lastAccessedTime;
        if (!method.getName().equals(&quot;invalidate&quot;)) {
            session.refresh();
            session.setLastAccessedTime(System.currentTimeMillis());
        }
        return result;
    }
}
</code></pre><h2 id="RedisHttpSessionFilter"><a href="#RedisHttpSessionFilter" class="headerlink" title="RedisHttpSessionFilter"></a>RedisHttpSessionFilter</h2><p><code>RedisHttpSessionFilter</code>作为过滤器，将请求和响应替换成<code>RedisSessionRequestWrapper</code>和<code>RedisSessionResponseWrapper</code>，利用了装饰器模式动态的给请求和响应进行增强：</p>
<ol>
<li><code>RedisSessionRequestWrapper</code>：重写了<code>getSession</code>，替换默认的<code>HttpSession</code>实现为<code>RedisHttpSession</code>。</li>
<li><code>RedisSessionResponseWrapper</code>：在响应的头部中加入<code>x-auth-token</code>字段，作为 Session 的 ID。客户端之后的请求都需要附带该字段，以便服务端识别对应的 Session。</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p><a href="https://github.com/x-hansong/RedisHttpSession" target="_blank" rel="external">RedisHttpSession</a> 利用 Filter 将请求的 Session 替换成 <code>RedisHttpSession</code>，在过滤阶段偷梁换柱，在之后对 Session 的操作都无需关心其内部实现，整个过程都是透明的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/x-hansong/RedisHttpSessi]]>
    </summary>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/tags/Java/"/>
    
      <category term="Session" scheme="http://blog.xiaohansong.com/tags/Session/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[三言两语：JVM 字节码执行实例分析]]></title>
    <link href="http://blog.xiaohansong.com/2016/04/26/java-bytecode/"/>
    <id>http://blog.xiaohansong.com/2016/04/26/java-bytecode/</id>
    <published>2016-04-26T03:11:29.000Z</published>
    <updated>2016-04-27T02:35:01.141Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>最近在看《Java 虚拟机规范》和《深入理解JVM虚拟机》，对于字节码的执行有了进一步的了解。字节码就像是汇编语言，是 JVM 的指令集。下面我们先对 JVM 执行引擎做一下简单介绍，然后根据实例分析 JVM 字节码的执行过程。包括：</p>
<ol>
<li>for 循环字节码分析</li>
<li>try-catch-finally 字节码分析</li>
</ol>
<h2 id="u8FD0_u884C_u65F6_u6808_u5E27_u7ED3_u6784"><a href="#u8FD0_u884C_u65F6_u6808_u5E27_u7ED3_u6784" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<p>在编译程序员代码的时候，栈帧中局部变量表和操作数栈的大小已经确定了，并且写入到方法表中的 <code>Code</code> 属性中。</p>
<p>在活动线程中，只有位于栈顶的栈帧才是有效的， 称为当前栈帧，与这个栈帧关联的方法称为当前方法。执行引擎运行的所有字节码指令只对当前栈帧进行操作。</p>
<h3 id="u5C40_u90E8_u53D8_u91CF_u8868"><a href="#u5C40_u90E8_u53D8_u91CF_u8868" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表的容量以变量槽（slot）为最小单位，每个 slot 保证能放下 32 位内的数据类型。虚拟机通过索引定位的方式使用局部变量表，索引值从 0 开始。值得注意的是，对于实例方法，局部变量表中第 0 位索引的 slot 默认是 <code>this</code>引用；静态方法则不是。而且为了节约内存，slot 是可以重用的。</p>
<h3 id="u64CD_u4F5C_u6570_u6808"><a href="#u64CD_u4F5C_u6570_u6808" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈的元素可以是任意的 Java 数据类型。当一个方法开始时，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈入栈操作。</p>
<h2 id="u5B9E_u4F8B_u5206_u6790"><a href="#u5B9E_u4F8B_u5206_u6790" class="headerlink" title="实例分析"></a>实例分析</h2><p>下面分析的字节码指令主要是对局部变量表和操作栈的读写。</p>
<h3 id="for__u5FAA_u73AF_u5B57_u8282_u7801_u5206_u6790"><a href="#for__u5FAA_u73AF_u5B57_u8282_u7801_u5206_u6790" class="headerlink" title="for 循环字节码分析"></a>for 循环字节码分析</h3><pre><code>void spin() {
    int i;
    for (i = 0; i &lt; 100; i++) {
        ; // Loop body is empty
    }
}
</code></pre><p>上面是一个空循环的代码，编译后的字节码如下：</p>
<pre><code>Method void spin()
    0 iconst_0 // Push int constant 0
    1 istore_1 // Store into local variable 1 (i=0)
    2 goto 8 // First time through don’t increment
    5 iinc 1 1 // Increment local variable 1 by 1 (i++)
    8 iload_1 // Push local variable 1 (i)
    9 bipush 100 // Push int constant 100
    11 if_icmplt 5 // Compare and loop if less than (i &lt; 100)
    14 return // Return void when done
</code></pre><p>相信大家看到上面的代码都是一脸懵逼，即使有注释还是不知道字节码到底做了什么操作。下面我就图解每一条指令，帮助理解。上面的代码都是对局部变量表和操作数栈的操作，所以我们的关注点就在这两个区域上。（栈是自顶向下的）</p>
<pre><code>0 iconst_0 //把常量0放入栈
+--------+--------+
| local  | stack  |
+-----------------+
|        |   0    |
+-----------------+
|        |        |
+--------+--------+

1 istore_1 //把栈顶的元素出栈，存到局部变量表索引为1的位置
+--------+--------+
| local  | stack  |
+-----------------+
|   0    |        |
+-----------------+
|        |        |
+--------+--------+

2 goto 8 //跳转到第8条指令

8 iload_1 //把局部变量表中索引为1的变量入栈
+--------+--------+
| local  | stack  |
+-----------------+
|   0    |   0    |
+-----------------+
|        |        |
+--------+--------+

9 bipush 100 //把100入栈
+--------+--------+
| local  | stack  |
+-----------------+
|   0    |   0    |
+-----------------+
|        |  100   |
+--------+--------+

11 if_icmplt 5 //出栈两个元素v1，v2，比较它们的值，当且仅当v1 &lt; v2，跳转到指令5
+--------+--------+
| local  | stack  |
+-----------------+
|   0    |        |
+-----------------+
|        |        |
+--------+--------+

5 iinc 1 1 //自增局部变量表中索引为1的值
+--------+--------+
| local  | stack  |
+-----------------+
|   1    |        |
+-----------------+
|        |        |
+--------+--------+

//进行下次循环直到指令11不满足，到达指令14
14 return //清空栈，执行引擎把控制权交换给调用者。
+--------+--------+
| local  | stack  |
+-----------------+
|   100  |        |
+-----------------+
|        |        |
+--------+--------+
</code></pre><p>以上就是<code>for</code>循环字节码执行的过程。可以发现，所有指令都是围绕者局部变量表和操作数栈在操作。</p>
<blockquote>
<p><strong>解惑</strong><br>指令<code>iconst_0</code>,<code>iload_1</code>的命名解读<br>第一个<code>i</code>代表这是对int数据类型进行的操作<br><code>const</code>,<code>load</code>是操作码<br><code>0</code>,<code>1</code>是隐含的操作数<br>上面的两个指令等价于<code>iconst 0</code>,<code>iload 1</code><br><em>详细的字节码解释查阅《JVM 虚拟机规范》</em></p>
</blockquote>
<h3 id="try-catch-finally__u5B57_u8282_u7801_u5206_u6790"><a href="#try-catch-finally__u5B57_u8282_u7801_u5206_u6790" class="headerlink" title="try-catch-finally 字节码分析"></a>try-catch-finally 字节码分析</h3><pre><code>static int inc(){
    int x;
    try {
        x = 1;
        return x;
    } catch (Exception e){
        x = 2;
        return x;
    } finally {
        x = 3;
    }
}
</code></pre><p>下面是它的字节码，这次我就不画图了，里面的命令跟上面的类似。</p>
<pre><code>static int inc();
descriptor: ()I
flags: ACC_STATIC
Code:
  stack=1, locals=4, args_size=0
     0: iconst_1  //try 块中的 x = 1;
     1: istore_0  //保存栈顶元素到局部变量表中索引为 0 的 slot 中
     2: iload_0   //加载局部变量表中索引为 0 的值到栈中
     3: istore_1  //保存栈顶元素到局部变量表中索引为 1 的 slot 中
     4: iconst_3  //finally 块中的 x = 3;
     5: istore_0  //保存栈顶元素到局部变量表中索引为 0 的 slot 中，x 的值存在这里。
     6: iload_1  //加载局部变量表中索引为 1 的值到栈中
     7: ireturn  //返回栈顶元素，即 x = 1;正常情况下函数运行到这里就结束了，如果出现异常根据异常表跳转到指定的位置
     8: astore_1 //给 catch 块中定义的 Exception e 赋值，存储在 slot1 中。
     9: iconst_2 //catch 块中的 x = 2;
    10: istore_0
    11: iload_0
    12: istore_2
    13: iconst_3 //finally 块中的 x = 3;
    14: istore_0
    15: iload_2
    16: ireturn //此时返回的是 slot2 中的值，即 x = 2
    17: astore_3 //如果出现不属于 java.lang.Exception 及其子类的异常，才会根据异常表中的规则跳转到这里。
    18: iconst_3 //finally 块中的 x = 3;
    19: istore_0
    20: aload_3 //将异常加载到栈顶，
    21: athrow //抛出栈顶的异常
  Exception table:
     from    to  target type
         0     4     8   Class java/lang/Exception
         0     4    17   any
         8    13    17   any
</code></pre><ol>
<li>字节码中 0 ~ 4 行将整数 1 赋值为变量 x，x 存储在 slot0 中，并且将 x 的值拷贝一份放到 slot1。如果没有出现异常，继续走到 5 ~ 7 行，将 x 赋值为 3，然后读取 slot1 中的值到栈顶，最后<code>ireturn</code>返回栈顶的值，方法结束。</li>
<li>如果出现异常，PC 寄存器指针转到第 8 行，第 8 ~ 16 行所做的事情就是将 2 赋值给 x，然后保存 x 的拷贝，最后将 x 赋值为 3。方法返回前将 x 的拷贝 2 读取到栈顶。</li>
<li>如果在 0 ~ 4，8 ~ 13 行中出现其他异常，则跳转到第 17 行执行，先同样执行<code>finally</code>块中的<code>x = 3</code>，最后抛出异常，方法结束。</li>
</ol>
<p>可以看到，Java 的异常处理是通过异常表的方式来决定代码执行的路径。而<code>finally</code>的实现是通过在每个路径的最后加入<code>finally</code>块中的字节码实现的。</p>
<p><em>参考资料</em><br>《Java 虚拟机规范》<br>《深入理解JVM虚拟机》</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>最近在看《Java 虚拟机规范》和《深入理解JVM虚拟机》，对于字节码的执行有了进一步的了解。字节码就像]]>
    </summary>
    
      <category term="JVM" scheme="http://blog.xiaohansong.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/tags/Java/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译】JVM 进行线程同步背后的原理]]></title>
    <link href="http://blog.xiaohansong.com/2016/04/23/JVM-Synchronized/"/>
    <id>http://blog.xiaohansong.com/2016/04/23/JVM-Synchronized/</id>
    <published>2016-04-23T02:50:37.000Z</published>
    <updated>2016-04-23T02:55:47.408Z</updated>
    <content type="html"><![CDATA[<p><em>本文翻译自<a href="http://www.javaworld.com/article/2076971/java-concurrency/how-the-java-virtual-machine-performs-thread-synchronization.html" target="_blank" rel="external">How the Java virtual machine performs thread synchronization</a>，内容略有删改</em></p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>所有的 Java 程序都会被翻译为包含字节码的 class 文件，字节码是 JVM 的机器语言。这篇文章将阐述 JVM 是如何处理线程同步以及相关的字节码。</p>
<h2 id="u7EBF_u7A0B_u548C_u5171_u4EAB_u6570_u636E"><a href="#u7EBF_u7A0B_u548C_u5171_u4EAB_u6570_u636E" class="headerlink" title="线程和共享数据"></a>线程和共享数据</h2><p>Java 的一个优点就是在语言层面支持多线程，这种支持集中在协调多线程对数据的访问上。</p>
<p>JVM 将运行时数据划分为几个区域：一个或多个栈，一个堆，一个方法区。</p>
<p>在 JVM 中，每个线程拥有一个栈，其他线程无法访问，里面的数据包括：局部变量，函数参数，线程调用的方法的返回值。栈里面的数据只包含原生数据类型和对象引用。在 JVM 中，不可能将实际对象的拷贝放入栈。所有对象都在堆里面。</p>
<p>JVM 只有一个堆，所有线程都共享它。堆中只包含对象，把单独的原生类型或者对象引用放入堆也是不可能的，除非它们是对象的一部分。数组也在堆中，包括原生类型的数组，因为在 Java 中，数组也是对象。</p>
<p>除了栈和堆，另一个存放数据的区域就是方法区了，它包含程序中使用到的所有类（静态）变量。方法区类似于栈，也只包含原生类型和对象引用，但是又跟栈不同，方法区中类变量是线程共享的。</p>
<h2 id="u5BF9_u8C61_u9501_u548C_u7C7B_u9501"><a href="#u5BF9_u8C61_u9501_u548C_u7C7B_u9501" class="headerlink" title="对象锁和类锁"></a>对象锁和类锁</h2><p>正如前面所说，JVM 中的两个区域包含线程共享的数据，分别是：</p>
<ol>
<li><strong>堆</strong>：包含所有对象</li>
<li><strong>方法区</strong>：包含所有类变量</li>
</ol>
<p>如果多个线程需要同时使用同一个对象或者类变量，它们对数据的访问必须被恰当地控制。否则，程序会产生不可预测的行为。</p>
<p>为了协调多个线程对共享数据的访问，JVM 给每个对象和类关联了一个锁。锁就像是任意时间点只有一个线程能够拥有的特权。如果一个线程想要锁住一个特定的对象或者类，它需要向 JVM 请求锁。线程向 JVM 请求锁之后，可能很快就拿到，或者过一会就拿到，也可能永远拿不到。当线程不需要锁之后，它把锁还给 JVM。如果其他线程需要这个锁，JVM 会交给该线程。</p>
<p>类锁的实现其实跟对象锁是一样的。当 JVM 加载类文件的时候，它会创建一个对应类<code>java.lang.Class</code>对象。当你锁住一个类的时候，你实际上是锁住了这个类的<code>Class</code>对象。</p>
<p>线程访问对象实例或者类变量的时候不需要获取锁。但是如果一个线程获取了一个锁，其他线程不能访问被锁住的数据，直到拥有锁的线程释放它。</p>
<h2 id="u7BA1_u7A0B"><a href="#u7BA1_u7A0B" class="headerlink" title="管程"></a>管程</h2><p>JVM 使用锁和管程协作。管程监视一段代码，保证一个时间点内只有一个线程能执行这段代码。</p>
<p>每个管程与一个对象引用关联。当线程到达管程监视代码段的第一条指令时，线程必须获取关联对象的锁。线程不能执行这段代码直到它得到了锁。一旦它得到了锁，线程可以进入被保护的代码段。</p>
<p>当线程离开被保护的代码块，不管是如何离开的，它都会释放关联对象的锁。</p>
<h2 id="u591A_u6B21_u9501_u5B9A"><a href="#u591A_u6B21_u9501_u5B9A" class="headerlink" title="多次锁定"></a>多次锁定</h2><p>一个线程被允许锁定一个对象多次。对于每个对象，JVM 维护了一个锁的计数器。没有被锁的对象计数为 0。当一个线程第一次获取锁，计数器自增变为 1。每次这个线程（已经得到锁的线程）请求同一个对象的锁，计数器都会自增。每次线程释放锁，计数器都会自减。当计数器变为 0 时，锁才被释放，可以给别的线程使用。</p>
<h2 id="u540C_u6B65_u5757"><a href="#u540C_u6B65_u5757" class="headerlink" title="同步块"></a>同步块</h2><p>在 Java 语言的术语中，协调多个线程访问共享数据被称为<strong>同步（synchronization）</strong>。Java 提供了两种内建的方式来同步对数据的访问：</p>
<ol>
<li>同步语句</li>
<li>同步方法</li>
</ol>
<h3 id="u540C_u6B65_u8BED_u53E5"><a href="#u540C_u6B65_u8BED_u53E5" class="headerlink" title="同步语句"></a>同步语句</h3><p>为了创建同步语句，你需要使用<code>synchronized</code>关键字，括号里面是同步的对象引用，如下所示：</p>
<pre><code>class KitchenSync {
    private int[] intArray = new int[10];
    void reverseOrder() {
        synchronized (this) {
            int halfWay = intArray.length / 2;
            for (int i = 0; i &lt; halfWay; ++i) {
                int upperIndex = intArray.length - 1 - i;
                int save = intArray[upperIndex];
                intArray[upperIndex] = intArray[i];
                intArray[i] = save;
            }
        }
    }
}
</code></pre><p>在上面的例子中，被同步块包含的语句不会被执行，直到线程得到<code>this</code>引用的对象锁。如果不是锁住<code>this</code>引用，而是锁住其他对象，在线程执行同步块语句之前，它需要获得该对象的锁。</p>
<p>有两个字节码<code>monitorenter</code>和<code>monitorexit</code>，被用来<strong>同步方法中的同步块</strong>。</p>
<table>
<thead>
<tr>
<th>字节码</th>
<th>操作数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>monitorenter</td>
<td>无</td>
<td>取出对象引用，请求与对象引用关联的锁</td>
</tr>
<tr>
<td>monitorexit</td>
<td>无</td>
<td>取出对象引用，释放与对象引用关联的锁</td>
</tr>
</tbody>
</table>
<p>当<code>monitorenter</code>被 JVM 执行时，它请求栈顶对象引用关联的锁。如果该线程已经拥有该对象的锁，计数器自增。每次<code>monitorexit</code>被执行，计数器自减。当计数器变为 0 时，该锁被释放。</p>
<p><strong>注意：</strong>当同步块中抛出异常时，<code>catch</code>语句保证对象锁被释放。不管同步块是如何退出的，JVM 保证线程会释放锁。</p>
<h3 id="u540C_u6B65_u65B9_u6CD5"><a href="#u540C_u6B65_u65B9_u6CD5" class="headerlink" title="同步方法"></a>同步方法</h3><p>为了同步整个方法，你只需要在方法声明前面加上<code>synchronized</code>关键字。</p>
<pre><code>class HeatSync {
    private int[] intArray = new int[10];
    synchronized void reverseOrder() {
        int halfWay = intArray.length / 2;
        for (int i = 0; i &lt; halfWay; ++i) {
            int upperIndex = intArray.length - 1 - i;
            int save = intArray[upperIndex];
            intArray[upperIndex] = intArray[i];
            intArray[i] = save;
        }
    }
}
</code></pre><p>JVM 不会使用特殊的字节码来调用同步方法。当 JVM 解析方法的符号引用时，它会判断方法是不是同步的。如果是，JVM 要求线程在调用之前请求锁。对于实例方法，JVM 要求得到该实例对象的锁。对于类方法，JVM 要求得到类锁。在同步方法完成之后，不管它是正常返回还是抛出异常，锁都会被释放。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>本文翻译自<a href="http://www.javaworld.com/article/2076971/java-concurrency/how-the-java-virtual-machine-performs-thread-synchronization.]]>
    </summary>
    
      <category term="synchronized" scheme="http://blog.xiaohansong.com/tags/synchronized/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[三言两语：SQL 连接（join）]]></title>
    <link href="http://blog.xiaohansong.com/2016/04/14/sql-join/"/>
    <id>http://blog.xiaohansong.com/2016/04/14/sql-join/</id>
    <published>2016-04-14T13:52:59.000Z</published>
    <updated>2016-04-23T02:57:58.464Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文将从连接的理论和语法讲起，结合具体的例子，详细分析 SQL 连接。</p>
<p>之前对数据库的连接操作似懂非懂，大概知道是什么东西，但是面试笔试的时候被虐成渣，讲不清连接到底是什么。吃一堑，长一智。这就是所谓的似懂非懂， 只是单纯的看书是没用的，只有亲自动手做实验才能彻底理解什么是连接。</p>
<h2 id="u8FDE_u63A5_u7C7B_u578B_u4E0E_u6761_u4EF6"><a href="#u8FDE_u63A5_u7C7B_u578B_u4E0E_u6761_u4EF6" class="headerlink" title="连接类型与条件"></a>连接类型与条件</h2><p>SQL 中每一种连接操作都包括一个连接类型和连接条件。</p>
<h3 id="u8FDE_u63A5_u7C7B_u578B"><a href="#u8FDE_u63A5_u7C7B_u578B" class="headerlink" title="连接类型"></a>连接类型</h3><p>连接类型决定了如何处理连接条件不匹配的记录。</p>
<table>
<thead>
<tr>
<th>连接类型</th>
<th>返回结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>inner join</td>
<td>只包含左右表中满足连接条件的记录</td>
</tr>
<tr>
<td>left outer join</td>
<td>在内连接的基础上，加入左表中不与右表匹配的记录，剩余字段赋值为null</td>
</tr>
<tr>
<td>right outer join</td>
<td>在内连接的基础上，加入右表中不与左表匹配的记录，剩余字段赋值为null</td>
</tr>
<tr>
<td>full outer join</td>
<td>左外连接和右外连接的组合。</td>
</tr>
<tr>
<td>cross join</td>
<td>等价于没有连接条件的内连接（即产生笛卡尔乘积）</td>
</tr>
</tbody>
</table>
<p>关键字 inner 和 outer 是可选的，因为根据连接类型的其余内容我们可以判断出连接是内连接和外连接。简单来说就是：除了单独的<code>join</code>是内连接，其他都是外连接。</p>
<p>对外连接来说，连接条件是<strong>必须的</strong>；但对内连接来说，连接条件是<strong>可选的</strong>（如果省略，将产生笛卡尔积）。</p>
<h3 id="u8FDE_u63A5_u6761_u4EF6"><a href="#u8FDE_u63A5_u6761_u4EF6" class="headerlink" title="连接条件"></a>连接条件</h3><p>连接条件决定两个表中哪些记录互相匹配以及连接结果中出现哪些属性。</p>
<table>
<thead>
<tr>
<th>连接条件</th>
<th>修饰位置</th>
<th>语义</th>
</tr>
</thead>
<tbody>
<tr>
<td>natural</td>
<td>连接类型之前</td>
<td>连接两个表之间的所有公共字段相等的记录，合并相同的列</td>
</tr>
<tr>
<td>on &lt;谓词&gt;</td>
<td>连接类型之后</td>
<td>连接符合谓词的记录，不合并相同的列</td>
</tr>
<tr>
<td>using(A1, A2,…,An)</td>
<td>连接类型之后</td>
<td>natural 语义的子集，只连接两个表中（A1,A2,..An)的公共字段，合并相同的列</td>
</tr>
</tbody>
</table>
<p>从上面的描述可以看到：连接操作是连接类型和连接条件的组合，只有在这个前提下才能真正的理解连接的功能。</p>
<h2 id="FQA"><a href="#FQA" class="headerlink" title="FQA"></a>FQA</h2><p>例子中使用到的表</p>
<p><strong>student</strong></p>
<pre><code>+----+--------+
| id | name   |
+----+--------+
|  1 | 张三   |
|  2 | 李四   |
|  3 | 王二   |
|  4 | 初一   |
|  5 | 初二   |
+----+--------+
</code></pre><p><strong>teacher</strong></p>
<pre><code>+----+-----------+
| id | name      |
+----+-----------+
|  1 | 王老师    |
|  2 | 李老师    |
|  3 | 张老师    |
|  4 | 肖老师    |
|  5 | NULL      |
|  6 | 陈老师    |
+----+-----------+
</code></pre><p><strong>course</strong></p>
<pre><code>+----+--------+------+
| id | cname  | tid  |
+----+--------+------+
|  1 | 数学   |    1 |
|  2 | 英语   |    2 |
|  3 | 语文   |    3 |
|  4 | 体育   |    1 |
|  5 | 物理   | NULL |
+----+--------+------+
</code></pre><p><strong>student_course</strong></p>
<pre><code>+-----+-----+
| sid | cid |
+-----+-----+
|   1 |   1 |
|   1 |   2 |
|   1 |   3 |
|   2 |   1 |
|   2 |   4 |
|   3 |   5 |
|   3 |   6 |
|   4 |   4 |
+-----+-----+
</code></pre><h3 id="u5185_u8FDE_u63A5_u4E4B_u540E_u7684_u7ED3_u679C_u96C6_u6570_u91CF_u662F_u591A_u5C11_uFF1F_u7B49_u4E8E_u5DE6_u8868_u6216_u8005_u53F3_u8868_u4E2D_u8BB0_u5F55_u7684_u6570_u91CF_u5417_uFF1F"><a href="#u5185_u8FDE_u63A5_u4E4B_u540E_u7684_u7ED3_u679C_u96C6_u6570_u91CF_u662F_u591A_u5C11_uFF1F_u7B49_u4E8E_u5DE6_u8868_u6216_u8005_u53F3_u8868_u4E2D_u8BB0_u5F55_u7684_u6570_u91CF_u5417_uFF1F" class="headerlink" title="内连接之后的结果集数量是多少？等于左表或者右表中记录的数量吗？"></a>内连接之后的结果集数量是多少？等于左表或者右表中记录的数量吗？</h3><p>内连接<code>teacher</code> <code>course</code>的结果</p>
<pre><code>select * from teacher inner join course on teacher.id = course.tid;
+----+-----------+----+--------+------+
| id | name      | id | cname  | tid  |
+----+-----------+----+--------+------+
|  1 | 王老师    |  1 | 数学   |    1 |
|  2 | 李老师    |  2 | 英语   |    2 |
|  3 | 张老师    |  3 | 语文   |    3 |
|  1 | 王老师    |  4 | 体育   |    1 |
+----+-----------+----+--------+------+
</code></pre><p>可以发现，王老师同时教数学和体育，因此左表中王老师匹配了右表中两条记录，物理没有老师教，所以没有出现在结果中。说明<strong>内连接的结果集数量等于左右表中匹配记录的数量</strong>。</p>
<h3 id="u5DE6_u8FDE_u63A5_u4E4B_u540E_u7684_u7ED3_u679C_u96C6_u6570_u91CF_u662F_u591A_u5C11_uFF1F_u7B49_u4E8E_u5DE6_u8868_u7684_u8BB0_u5F55_u6570_u91CF_u5417_uFF1F"><a href="#u5DE6_u8FDE_u63A5_u4E4B_u540E_u7684_u7ED3_u679C_u96C6_u6570_u91CF_u662F_u591A_u5C11_uFF1F_u7B49_u4E8E_u5DE6_u8868_u7684_u8BB0_u5F55_u6570_u91CF_u5417_uFF1F" class="headerlink" title="左连接之后的结果集数量是多少？等于左表的记录数量吗？"></a>左连接之后的结果集数量是多少？等于左表的记录数量吗？</h3><p>左连接<code>teacher</code> <code>course</code>的结果</p>
<pre><code>select * from teacher left join course on teacher.id = course.tid;
+----+-----------+------+--------+------+
| id | name      | id   | cname  | tid  |
+----+-----------+------+--------+------+
|  1 | 王老师    |    1 | 数学   |    1 |
|  2 | 李老师    |    2 | 英语   |    2 |
|  3 | 张老师    |    3 | 语文   |    3 |
|  1 | 王老师    |    4 | 体育   |    1 |
|  4 | 肖老师    | NULL | NULL   | NULL |
|  5 | NULL      | NULL | NULL   | NULL |
|  6 | 陈老师    | NULL | NULL   | NULL |
+----+-----------+------+--------+------+
</code></pre><p>可以看到，没有教授课程的老师也出现在结果中，对应的字段都为NULL。说明结果集的数量并不等于左表记录的数量，因为两个表直接不是一对一的关系。其数量应该等于<strong>内连接的结果集数量加上左表中不匹配的记录数量</strong>。</p>
<h3 id="Mysql__u4E2D_u4E0D_u652F_u6301full_outer_join"><a href="#Mysql__u4E2D_u4E0D_u652F_u6301full_outer_join" class="headerlink" title="Mysql 中不支持full outer join"></a>Mysql 中不支持<code>full outer join</code></h3><p>可以通过<code>union</code>操作模拟。</p>
<pre><code>SELECT * FROM teacher
LEFT JOIN course ON teacher.id = course.tid
UNION
SELECT * FROM teacher
RIGHT JOIN course ON teacher.id = course.id;

+------+-----------+------+--------+------+
| id   | name      | id   | cname  | tid  |
+------+-----------+------+--------+------+
|    1 | 王老师    |    1 | 数学   |    1 |
|    2 | 李老师    |    2 | 英语   |    2 |
|    3 | 张老师    |    3 | 语文   |    3 |
|    1 | 王老师    |    4 | 体育   |    1 |
|    4 | 肖老师    | NULL | NULL   | NULL |
|    5 | NULL      | NULL | NULL   | NULL |
|    6 | 陈老师    | NULL | NULL   | NULL |
|    4 | 肖老师    |    4 | 体育   |    1 |
|    5 | NULL      |    5 | 物理   | NULL |
+------+-----------+------+--------+------+
</code></pre><h3 id="u591A_u8868_u8FDE_u63A5_u95EE_u9898"><a href="#u591A_u8868_u8FDE_u63A5_u95EE_u9898" class="headerlink" title="多表连接问题"></a>多表连接问题</h3><p>考虑查出所有学生的课程的记录</p>
<pre><code>select * from student
left join student_course on student.id = student_course.sid
left join course on student_course.cid = course.id;

+----+--------+------+------+------+--------+------+
| id | name   | sid  | cid  | id   | cname  | tid  |
+----+--------+------+------+------+--------+------+
|  1 | 张三   |    1 |    1 |    1 | 数学   |    1 |
|  2 | 李四   |    2 |    1 |    1 | 数学   |    1 |
|  1 | 张三   |    1 |    2 |    2 | 英语   |    2 |
|  1 | 张三   |    1 |    3 |    3 | 语文   |    3 |
|  2 | 李四   |    2 |    4 |    4 | 体育   |    1 |
|  4 | 初一   |    4 |    4 |    4 | 体育   |    1 |
|  3 | 王二   |    3 |    5 |    5 | 物理   | NULL |
|  3 | 王二   |    3 |    6 | NULL | NULL   | NULL |
|  5 | 初二   | NULL | NULL | NULL | NULL   | NULL |
+----+--------+------+------+------+--------+------+
</code></pre><p>用学生表连接中间表，再连接课程表可以得到结果。连接操作是针对两个表之间的，所以上面的结果是从左到右，两两连接得到的。</p>
<p><strong>如果你有更多关于连接的问题，或者发现文章中的错误，欢迎留言交流</strong></p>
<p><em>参考资料</em><br>《数据库系统概念》</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文将从连接的理论和语法讲起，结合具体的例子，详细分析 SQL 连接。</p>
<p>之前对数据库的连接]]>
    </summary>
    
      <category term="MySQL" scheme="http://blog.xiaohansong.com/tags/MySQL/"/>
    
      <category term="join" scheme="http://blog.xiaohansong.com/tags/join/"/>
    
      <category term="数据库" scheme="http://blog.xiaohansong.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hiho 1289 403 Forbidden（微软编程题）]]></title>
    <link href="http://blog.xiaohansong.com/2016/04/09/forbidden/"/>
    <id>http://blog.xiaohansong.com/2016/04/09/forbidden/</id>
    <published>2016-04-09T08:10:40.000Z</published>
    <updated>2016-04-09T08:12:09.131Z</updated>
    <content type="html"><![CDATA[<h2 id="u9898_u610F"><a href="#u9898_u610F" class="headerlink" title="题意"></a>题意</h2><pre><code>allow 1.2.3.4/30
deny 1.1.1.1
allow 127.0.0.1
allow 123.234.12.23/3
deny 0.0.0.0/0
</code></pre><p>输入 ip 按顺序匹配规则，优先匹配前面的规则，如果没有规则可以匹配则视为合法。注意：掩码为 0 的时候表示匹配所有 ip。</p>
<h2 id="u601D_u8DEF"><a href="#u601D_u8DEF" class="headerlink" title="思路"></a>思路</h2><p>一开始做的时候用遍历匹配的方法，直接超时了。后来才想到用字典树的方法来做，这道题本质上是一道字典树变形。</p>
<h3 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h3><pre><code>class Node {
        byte flag;//0代表普通节点，1代表允许规则终点，2代表禁止规则终点
        int seq;//规则顺序
        Node[] next = new Node[2];

        Node(byte flag){
            this.flag = flag;
    }
}
</code></pre><h3 id="u5EFA_u6811"><a href="#u5EFA_u6811" class="headerlink" title="建树"></a>建树</h3><ol>
<li>seq 自增，记录规则的顺序</li>
<li>解析掩码：如果输入的 ip 没有 mask，则默认 <code>mask = 32</code></li>
<li>把ip地址转化为二进制形式</li>
<li>插入节点：如果该节点不存在，则新建；否则沿着节点往下走</li>
<li>设置节点的 flag 和 seq：后面的规则不能覆盖前面的规则，所以要查看当前节点是否为某规则的终点。</li>
</ol>
<p>代码如下：</p>
<pre><code>public void insert(String ip, byte flag) {
    seq++;
    int mask = 32;
    int index = ip.indexOf(&apos;/&apos;);
    //检测是否有掩码
    if (index != -1) {
        mask = Integer.parseInt(ip.substring(index + 1));
    } else {
        index = ip.length();
    }
     //把ip地址转化为二进制形式
    String binary = toBinary(ip.substring(0, index));

    char[] binarys = binary.toCharArray();

    Node node = root;

    for (int i = 0; i &lt; mask; i++) {
        int pos = binarys[i] - &apos;0&apos;;
        if (node.next[pos] == null){
            node.next[pos] = new Node((byte) 0);
        }
        node = node.next[pos];
    }
    //后面的规则不能覆盖前面的
    if (node.flag == 0){
        node.flag = flag;
    }
    if (node.seq == 0) {
        node.seq = seq;
    }
}
</code></pre><h3 id="u5339_u914D"><a href="#u5339_u914D" class="headerlink" title="匹配"></a>匹配</h3><ol>
<li>把ip地址转化为二进制形式</li>
<li>遍历字典树</li>
<li>如果当前节点为规则的终点，则需要比较该规则的顺序，seq 小的优先匹配</li>
<li>遍历完字典树之后，isAllow 的值就是该 ip 最先匹配到的规则所规定的权限</li>
</ol>
<p>代码如下：</p>
<pre><code>public boolean isAllow(String ip){
    String binary = toBinary(ip);
    char[] binarys = binary.toCharArray();

    Node node = root;
    int seq = Integer.MAX_VALUE;
    boolean isAllow = true;
    int i = 0;
    int pos = 0;
    while (node != null){
        //字典树最多会有33个节点，而ip的二进制最多只有32位
        //另一种避免判断的方法是在ip的二进制后面补一个0
        if (i &lt; binarys.length){
            pos = binarys[i] - &apos;0&apos;;
        }
        if (node.flag == 1){
            if (node.seq &lt; seq){
                isAllow = true;
                seq = node.seq;
            }
        } else if (node.flag == 2){
            if (node.seq &lt; seq){
                isAllow = false;
                seq = node.seq;
            }
        } else {
            //flag=0说明是普通节点，直接跳过即可。
        }
        node = node.next[pos];
        i++;
    }
    return isAllow;
}
</code></pre><p><em><a href="https://github.com/x-hansong/JavaCodes/blob/master/src/main/java/com/contest/Forbidden.java" target="_blank" rel="external">完整代码</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u9898_u610F"><a href="#u9898_u610F" class="headerlink" title="题意"></a>题意</h2><pre><code>allow 1.2.3.4/30
deny 1.1.1.1
allow 127.0.0.]]>
    </summary>
    
      <category term="Trie" scheme="http://blog.xiaohansong.com/tags/Trie/"/>
    
      <category term="字典树" scheme="http://blog.xiaohansong.com/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
      <category term="解题报告" scheme="http://blog.xiaohansong.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java String 对 null 对象的容错处理]]></title>
    <link href="http://blog.xiaohansong.com/2016/03/13/null-in-java-string/"/>
    <id>http://blog.xiaohansong.com/2016/03/13/null-in-java-string/</id>
    <published>2016-03-13T09:10:24.000Z</published>
    <updated>2016-04-26T03:40:32.990Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>最近在读《Thinking in Java》，看到这样一段话：</p>
<blockquote>
<p>Primitives that are fields in a class are automatically initialized to zero, as noted in the Everything Is an Object chapter. But the object references are initialized to null, and if you try to call methods for any of them, you’ll get an exception-a runtime error. Conveniently, you can still print a null reference without throwing an exception.<br>大意是：原生类型会被自动初始化为 0，但是对象引用会被初始化为 null，如果你尝试调用该对象的方法，就会抛出空指针异常。通常，你可以打印一个 null 对象而不会抛出异常。</p>
</blockquote>
<p>第一句相信大家都会容易理解，这是类型初始化的基础知识，但是第二句就让我很疑惑：为什么打印一个 null 对象不会抛出异常？带着这个疑问，我开始了解惑之旅。下面我将详细阐述我解决这个问题的思路，并且深入 JDK 源码找到问题的答案。</p>
<h2 id="u89E3_u51B3_u95EE_u9898_u7684_u8FC7_u7A0B"><a href="#u89E3_u51B3_u95EE_u9898_u7684_u8FC7_u7A0B" class="headerlink" title="解决问题的过程"></a>解决问题的过程</h2><p>可以发现，其实这个问题有几种情况，所以我们分类讨论各种情况，看最后能不能得到答案。</p>
<p>首先，我们把这个问题分解为三个小问题，逐一解决。</p>
<h3 id="u7B2C_u4E00_u4E2A_u95EE_u9898"><a href="#u7B2C_u4E00_u4E2A_u95EE_u9898" class="headerlink" title="第一个问题"></a>第一个问题</h3><p>直接打印 null 的 String 对象，会得到什么结果？</p>
<pre><code>String s = null;
System.out.print(s);
</code></pre><p>运行的结果是</p>
<pre><code>null
</code></pre><p>果然如书上说的没有抛出异常，而是打印了<code>null</code>。显然问题的线索在于<code>print</code>函数的源码中。我们找到<code>print</code>的源码：</p>
<pre><code>public void print(String s) {
    if (s == null) {
        s = &quot;null&quot;;
    }
    write(s);
}
</code></pre><p>看到源码才发现原来就只是加了一句判断而已，简单粗暴，可能你对 JDK 的简单实现有点失望了。放心，第一个问题只是开胃菜而已，大餐还在后面。</p>
<h3 id="u7B2C_u4E8C_u4E2A_u95EE_u9898"><a href="#u7B2C_u4E8C_u4E2A_u95EE_u9898" class="headerlink" title="第二个问题"></a>第二个问题</h3><p>打印一个 null 的非 String 对象，例如说 Integer：</p>
<pre><code>Integer i = null;
System.out.print(i);
</code></pre><p>运行的结果不出意料：</p>
<pre><code>null
</code></pre><p>我们再去看看<code>print</code>的源码：</p>
<pre><code>public void print(Object obj) {
    write(String.valueOf(obj));
}
</code></pre><p>有点不一样的了，看来秘密藏在<code>valueOf</code>里面。</p>
<pre><code>public static String valueOf(Object obj) {
    return (obj == null) ? &quot;null&quot; : obj.toString();
}
</code></pre><p>看到这里，我们终于发现了打印 null 对象不会抛出异常的秘密。<code>print</code>方法对 String 对象和非 String 对象分开进行处理。</p>
<ol>
<li><strong>String 对象</strong>：直接判断是否为 null，如果为 null 给 null 对象赋值为<code>&quot;null&quot;</code>。</li>
<li><strong>非 String 对象</strong>：通过调用<code>String.valueOf</code>方法，如果是 null 对象，就返回<code>&quot;null&quot;</code>，否则调用对象的<code>toString</code>方法。</li>
</ol>
<p>通过上面的处理，可以保证打印 null 对象不会出错。</p>
<p>到这里，本文就应该结束了。<br>什么？说好的大餐呢？上面还不够塞牙缝呢。<br>开玩笑啦。下面我们来探讨第三个问题。</p>
<h3 id="u7B2C_u4E09_u4E2A_u95EE_u9898_uFF08_u9690_u85CF_u7684_u5927_u9910_uFF09"><a href="#u7B2C_u4E09_u4E2A_u95EE_u9898_uFF08_u9690_u85CF_u7684_u5927_u9910_uFF09" class="headerlink" title="第三个问题（隐藏的大餐）"></a>第三个问题（隐藏的大餐）</h3><p>null 对象与字符串拼接会得到什么结果？</p>
<pre><code>String s = null;
s = s + &quot;!&quot;;
System.out.print(s);
</code></pre><p>结果可能你也猜到了：</p>
<pre><code>null!
</code></pre><p>为什么呢？跟踪代码运行可以发现，这回跟<code>print</code>没有什么关系。但是上面的代码就调用了<code>print</code>函数，不是它会是谁呢？<code>+</code>的嫌疑最大，但是<code>+</code>又不是函数，我们怎么看到它的源代码？这种情况，唯一的解释就是编译器动了手脚，天网恢恢，疏而不漏，找不到源代码，我们可以去看看编译器生成的字节码。</p>
<pre><code>L0
 LINENUMBER 27 L0
 ACONST_NULL
 ASTORE 1
L1
 LINENUMBER 28 L1
 NEW java/lang/StringBuilder
 DUP
 INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V
 ALOAD 1
 INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
 LDC &quot;!&quot;
 INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
 INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
 ASTORE 1
L2
 LINENUMBER 29 L2
 GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
 ALOAD 1
 INVOKEVIRTUAL java/io/PrintStream.print (Ljava/lang/String;)V
</code></pre><p>看了上面的字节码是不是一头雾水？这里我们就要扯开话题，来侃侃<code>+</code>字符串拼接的原理了。</p>
<p>编译器对字符串相加会进行优化，首先实例化一个<code>StringBuilder</code>，然后把相加的字符串按顺序<code>append</code>，最后调用<code>toString</code>返回一个<code>String</code>对象。不信你们看看上面的字节码是不是出现了<code>StringBuilder</code>。详细的解释参考这篇文章 <a href="http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/" target="_blank" rel="external">Java细节：字符串的拼接</a>。</p>
<pre><code>String s = &quot;a&quot; + &quot;b&quot;;
//等价于
StringBuilder sb = new StringBuilder();
sb.append(&quot;a&quot;);
sb.append(&quot;b&quot;);
String s = sb.toString();
</code></pre><p>再回到我们的问题，现在我们知道秘密在<code>StringBuilder.append</code>函数的源码中。</p>
<pre><code>//针对 String 对象
public AbstractStringBuilder append(String str) {
    if (str == null)
        return appendNull();
    int len = str.length();
    ensureCapacityInternal(count + len);
    str.getChars(0, len, value, count);
    count += len;
    return this;
}
//针对非 String 对象
public AbstractStringBuilder append(Object obj) {
    return append(String.valueOf(obj));
}

private AbstractStringBuilder appendNull() {
    int c = count;
    ensureCapacityInternal(c + 4);
    final char[] value = this.value;
    value[c++] = &apos;n&apos;;
    value[c++] = &apos;u&apos;;
    value[c++] = &apos;l&apos;;
    value[c++] = &apos;l&apos;;
    count = c;
    return this;
}
</code></pre><p>现在我们恍然大悟，<code>append</code>函数如果判断对象为 null，就会调用<code>appendNull</code>，填充<code>&quot;null&quot;</code>。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>上面我们讨论了三个问题，由此引出 Java 中 String 对 null 对象的容错处理。上面的例子没有覆盖所有的处理情况，算是抛砖引玉。</p>
<p>如何让程序中的 null 对象在我们的控制之中，是我们编程的时候需要时刻注意的事情。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>最近在读《Thinking in Java》，看到这样一段话：</p>
<blockquote>
<p>]]>
    </summary>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/tags/Java/"/>
    
      <category term="String" scheme="http://blog.xiaohansong.com/tags/String/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[访问 NULL 指针错误背后的原理]]></title>
    <link href="http://blog.xiaohansong.com/2016/02/18/dereference-null/"/>
    <id>http://blog.xiaohansong.com/2016/02/18/dereference-null/</id>
    <published>2016-02-18T14:50:43.000Z</published>
    <updated>2016-04-26T03:40:20.262Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>说到 NULL 指针大家都是谈之色变，第一印象就是 <code>NullPointerException</code>, <code>Segmentation fault</code> 之类的错误。NULL 指针大部分情况下会导致程序被终止。但是其实严格来说，访问空指针会产生不可预料的结果。只不过大部分情况是程序被终止。为什么呢？接下来让我们来探讨访问 NULL 指针错误背后的原理。</p>
<h2 id="NULL__u5728_u7F16_u8BD1_u5668_u4E2D_u7684_u5B9E_u73B0"><a href="#NULL__u5728_u7F16_u8BD1_u5668_u4E2D_u7684_u5B9E_u73B0" class="headerlink" title="NULL 在编译器中的实现"></a>NULL 在编译器中的实现</h2><p>首先，我们来看看 NULL 指针到底是什么？</p>
<blockquote>
<p>Null 是一个特殊指针值（或是一种对象引用）表示这个指针并不指向任何的对象。</p>
</blockquote>
<p>举一些例子，C/C++ 中的 <code>NULL</code>，Python 中的 <code>None</code> 等等。大部分 <code>NULL</code> 实现是用 <code>0</code> 代表 <code>NULL</code>，例如说 C/C++ 。实际上，NULL 的值并不重要，重要的是它代表的含义。例如说，JVM 规范并没有规定 NULL 的值，不同虚拟机实现可以自己定义 NULL 的值。</p>
<p>总之， NULL 的值取决编译器实现。</p>
<h2 id="u8BBF_u95EE_NULL__u6307_u9488_u7684_u8FC7_u7A0B"><a href="#u8BBF_u95EE_NULL__u6307_u9488_u7684_u8FC7_u7A0B" class="headerlink" title="访问 NULL 指针的过程"></a>访问 NULL 指针的过程</h2><p>C 语言中，NULL 的值是 0，即 <code>NULL == 0</code> 是成立的。我们前面说访问 NULL 指针的行为会产生不可预料的后果。但是在 Linux 系统中后果是确定的：访问空指针会产生 <code>Segmentation fault</code> 的错误。因此这里的“不可预料”指的是在不同系统产生的后果不一样。</p>
<p>让我们假设现在使用的是 C 语言，运行在 Linux 系统上，以此来分析访问 NULL 指针的过程。</p>
<ol>
<li>Linux 中，每个进程空间的 0x0 虚拟地址开始的线性区(memory region)都会被映射到一个用户态没有访问权限的页上。通过这样的映射，内核可以保证没有别的页会映射到这个区域。</li>
<li>编译器把空指针当做 <code>0</code> 对待，开心地让你去访问空指针。</li>
<li>缺页异常处理程序被调用，因为在 0x0 的页没有在物理内存里面。</li>
<li>缺页异常处理程序发现你没有访问的权限。</li>
<li>内核发送 <code>SIGSEGV</code> 信号给进程，该信号默认是让进程自杀。</li>
</ol>
<p>可以看到：不需要特定的编译器实现或者内核的支持，只需要让一个页映射到 0x0 的虚拟地址上，就完美的实现了检测空指针的错误。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>为了研究这个问题，我查了很多资料。空指针的问题涉及 Linux 内存管理的知识，主要参考了 Robert Love 大神对该 <a href="https://www.quora.com/What-actually-happens-when-dereferencing-a-NULL-pointer" target="_blank" rel="external">问题</a> 的回答和《深入理解Linux内核》。最大的感悟是带着问题去看内核的书，你会理解内核为什么要这么做，同时可以加深理解和记忆。</p>
<p>总之，空指针的实现取决于编译器的实现，访问空指针的后果取决于操作系统的实现。大部分系统类似于 Linux，会产生 <code>Segmentation fault</code> 的错误，至于内部实现就要看各个系统的代码了。</p>
<p><em>参考资料</em><br><a href="https://www.quora.com/What-actually-happens-when-dereferencing-a-NULL-pointer" target="_blank" rel="external">What actually happens when dereferencing a NULL pointer?</a><br>《深入理解Linux内核》</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>说到 NULL 指针大家都是谈之色变，第一印象就是 <code>NullPointerException]]>
    </summary>
    
      <category term="Linux" scheme="http://blog.xiaohansong.com/tags/Linux/"/>
    
      <category term="Linux内核" scheme="http://blog.xiaohansong.com/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[程序员的知识管理]]></title>
    <link href="http://blog.xiaohansong.com/2016/01/16/kownledge-Management/"/>
    <id>http://blog.xiaohansong.com/2016/01/16/kownledge-Management/</id>
    <published>2016-01-16T05:01:51.000Z</published>
    <updated>2016-07-30T03:05:14.308Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文从一个程序员的视角来讨论知识管理，包括以下几个方面：</p>
<ul>
<li>什么是知识管理</li>
<li>为什么要管理知识</li>
<li>如何管理知识</li>
</ul>
<h2 id="u4EC0_u4E48_u662F_u77E5_u8BC6_u7BA1_u7406"><a href="#u4EC0_u4E48_u662F_u77E5_u8BC6_u7BA1_u7406" class="headerlink" title="什么是知识管理"></a>什么是知识管理</h2><blockquote>
<p>个人知识管理（Personal Knowledge Management）：一般指个人通过工具建立知识体系并不断完善，进行知识的收集、消化吸收和创新的过程。</p>
</blockquote>
<p>知识管理的范围很广，一般的知识管理方法可以参考这篇文章 <a href="http://www.jianshu.com/p/dbdac17eb9ff" target="_blank" rel="external">个人知识管理的方法</a>。</p>
<h2 id="u4E3A_u4EC0_u4E48_u8981_u7BA1_u7406_u77E5_u8BC6"><a href="#u4E3A_u4EC0_u4E48_u8981_u7BA1_u7406_u77E5_u8BC6" class="headerlink" title="为什么要管理知识"></a>为什么要管理知识</h2><p>计算机行业的一个特点是新技术更新特别快，意味着程序员需要不停地学习，才能跟上行业的发展。所以，知识管理对程序员非常重要。有意识，成体系地管理知识能够：</p>
<ul>
<li><strong>更有效地学习新的知识。</strong><br>  如果我们已经建立好一个技术知识体系，新的技术也只是在其他技术上建立起来的，有了坚实基础，学习新技术就会更有效。</li>
<li><strong>更好地掌握知识。</strong><br>  使用合适的工具，正确的方法，可以更好地掌握知识，让知识凝固在脑海，而不是流走。</li>
<li><strong>节约时间成本。</strong><br>  程序员经常遇到同样的问题，例如说部署开发环境的时候，如果有把解决方案记录下来，就能省去重新解决问题的时间。</li>
</ul>
<h2 id="u5982_u4F55_u7BA1_u7406_u77E5_u8BC6"><a href="#u5982_u4F55_u7BA1_u7406_u77E5_u8BC6" class="headerlink" title="如何管理知识"></a>如何管理知识</h2><p>程序员的知识获取途径大部分来自于搜索引擎（谷歌可以提高搜索效率）和技术书籍，这与其他行业不同。主要原因是技术知识一个主要来源是互联网，例如说技术博客，技术文档等。因此，程序员的知识管理主要围绕互联网展开（并不意味着书籍就不重要）。</p>
<p>我把程序员的知识管理分为三个过程：</p>
<ul>
<li><strong>知识积累</strong></li>
<li><strong>碎片整理</strong></li>
<li><strong>思考加工</strong></li>
</ul>
<h3 id="u77E5_u8BC6_u79EF_u7D2F"><a href="#u77E5_u8BC6_u79EF_u7D2F" class="headerlink" title="知识积累"></a>知识积累</h3><p>想想我们习以为常的知识积累方式有哪些？也许记笔记是我们最常用的一种。对于程序员来说，用笔记录笔记并不现实，我刚学 C++ 的时候就是把语法记在笔记上。实际上，这种做法是很低效的。更有效的方法是用笔记软件帮我们记录文章。例如说，印象笔记，有道笔记等。</p>
<p>一开始我看到好的技术文章时，都是加书签存起来。后面发现这样不能离线访问，而且链接可能会失效。后来用上了笔记软件，于是我可以把文章保存到笔记中，随时可以翻出来看。可以说，笔记软件给知识积累带来了极大方便，同时可以分类管理不同的知识。</p>
<p>知识积累难在养成积累的习惯。以前我解决某个问题，谷歌了很久找到一篇文章解决了问题。解决之后并没有记录下来，结果下一次遇到同样问题，我又浪费了很多时间搜索解决方法。重复多次之后，我意识到这是个严重的问题。所以逐渐养成了保存各种文章的习惯。这些网上积累下来的文章，成为了我知识体系的土壤。</p>
<p>现在开始，<strong>使用笔记软件分门别类地保存网上看到的文章</strong>，这里要着重强调一下分类的重要性，好的分类可以节省你以后重新检索文章的时间，不要把时间浪费在不必要的劳动上。笔记软件一般都会提供浏览器插件，保存起来是很方便的。</p>
<h3 id="u788E_u7247_u6574_u7406"><a href="#u788E_u7247_u6574_u7406" class="headerlink" title="碎片整理"></a>碎片整理</h3><p>我自己经常遇到这样的情况：要用到某个 Linux 命令的时候，经常大费周章地去搜索。有人说直接查 man 手册不是很快吗？确实查 man 手册比查搜索引擎要快，但是有两个问题：一是看了 man 手册的命令语法，我还得试试看；二是如果我不知道命令的名字怎么查 man。所以，最快的方法不是搜索引擎，也不是 man 手册，而是个人 wiki。</p>
<p>与大家平常所知的 wiki 不同，个人 wiki 主要是用来记录知识碎片的，例如说：某个常用命令的语法，特定的软件配置等等。如果还是不理解，可以看看我的个人 <a href="http://wiki.xiaohansong.com/" target="_blank" rel="external">Wiki</a>。这些知识碎片是我们初步消化的知识，只不过因为太过碎片，不能够组成完整的知识体系。很多人以为把看到的文章保存到自己的笔记里面，就有一种已经掌握它的错觉，结果保存了成千上百的文章，却一篇都没认真看完。别人的文章是他的知识沉淀，并不是自己的。随时把文章中的精华提取整理到 wiki，才能初步消化知识，为后面的思考加工做准备。</p>
<p>有人会问为什么不用笔记软件记录这些碎片化的知识呢？用 wiki 当然是有理由的：</p>
<ol>
<li><strong>笔记软件保存的主要是知识原料。</strong>我们从网上保存别人的文章到笔记，存下来的知识是别人的，你只是存下来而已，还没经过消化。我们上面把笔记软件定义为知识的仓库，如果把初步消化后的知识也存在那里，会造成一定的混乱。当然你一定要这么做也可以，但我有分层的思维定势，这算是职业病吧。</li>
<li><strong>wiki 是随处可访问的。</strong>wiki 发布在互联网上，我们可以随时随地访问它。</li>
<li><strong>wiki 是分享的。</strong>任何人都可以访问你的 wiki，分享自己的知识何乐而不为呢？</li>
</ol>
<p>那么如何制作自己的 wiki 呢？我自己用的是 <a href="http://simiki.org/" target="_blank" rel="external">Simiki</a>，具体用法查看 <a href="http://wiki.xiaohansong.com/tool/simiki.html" target="_blank" rel="external">Simiki-个人Wiki写作</a>。发布到互联网我用的是 Github Page，具体操作自行搜索。</p>
<h3 id="u601D_u8003_u52A0_u5DE5"><a href="#u601D_u8003_u52A0_u5DE5" class="headerlink" title="思考加工"></a>思考加工</h3><p>写博客是最好的思考加工知识的方法。当年我也是被刘未鹏的 <a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="external">为什么你应该（从现在开始就）写博客</a> 和 <a href="http://mindhacks.cn/2009/02/09/writing-is-better-thinking/" target="_blank" rel="external">书写是为了更好的思考</a> 给带入坑的。写博客的好处我就不提了，看上面两篇文章就够洗脑了。下面我着重谈谈如何写好博客的一点个人经验。</p>
<ol>
<li><strong>博客少写纯操作指南类的文章。</strong>网上大部分博客写的都是纯操作指南类的文章，例如，如何搭建 LAMP 之类，可能作者自己都不清楚为什么要这么做。不是说纯操作指南类的文章不好，相反我觉得这种文章很重要，只是它的位置不对。它应该放在 wiki 中，因为纯操作指南类的文章只是描述步骤，关注点是怎么做，而不是为什么。写博客的关注点应该在为什么，讲清楚为什么要这么做。另外不要钻牛角尖，我说的是纯操作指南，不要以为只要是搭建环境之类的文章都不能写，这里的“纯”代表只给步骤，不提背后的原理。其实写得好的操作指南应该力求让读者知其然，知其所以然。</li>
<li><strong>定期写文章。</strong> 万事开头难，动笔开始写作很难，一旦开始就停不下来了。养成定期写文章的习惯，至少确保一个月一篇的节奏。</li>
<li><strong>自荐文章到各个技术头条。</strong>例如说：伯乐头条，开发者头条，极客头条等，有读者才有动力，同时也是保证自己写好文章的监督。</li>
<li><strong>写博客的工具。</strong>我自己用的是托管在 Github Page 的 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo</a> 静态博客。搭建教程见 <a href="http://blog.xiaohansong.com/2015/06/17/%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/">用hexo搭建github博客</a>。如果你有服务器的话，可以试试 wordpress，ghost 之类的博客软件。</li>
<li><strong>把无法加工的知识写到 Wiki。</strong>例如说：git 的一些配置和用法，这些内容在官方文档都能找到，写在博客也只是搬运工，除非你有新的理解。</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>以上是我摸打滚爬两年多积累的经验之谈，如果你有好的经验欢迎留言交流。一开始我是在 CSDN 写博客，只不过走了不少弯路，后来折腾 <a href="http://blog.xiaohansong.com/">个人博客</a>，最后又开了 <a href="http://wiki.xiaohansong.com/" target="_blank" rel="external">个人 Wiki</a>。逐渐形成了自己的知识管理方法。最后总结一下：</p>
<ol>
<li><strong>知识积累</strong>：使用笔记软件保存好的文章，积累知识。</li>
<li><strong>碎片整理</strong>：在个人 wiki 上记录初步消化的知识碎片。</li>
<li><strong>思考加工</strong>：对存在笔记和 wiki 中知识进行思考加工后写在博客。</li>
</ol>
<p>以上讲的是如何在互联网中学习积累，但是千万不要忽视了看书这一重要方法，书中的知识是成体系的，知识密度高，网上的文章良莠不齐，不成体系，比较碎片化。合理分配时间看书和上网学习是很重要的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文从一个程序员的视角来讨论知识管理，包括以下几个方面：</p>
<ul>
<li>什么是知识管理</l]]>
    </summary>
    
      <category term="知识管理" scheme="http://blog.xiaohansong.com/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
    
      <category term="个人随想" scheme="http://blog.xiaohansong.com/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对抽象类与接口的一点思考]]></title>
    <link href="http://blog.xiaohansong.com/2015/12/02/abstract-class-and-interface/"/>
    <id>http://blog.xiaohansong.com/2015/12/02/abstract-class-and-interface/</id>
    <published>2015-12-02T13:55:47.000Z</published>
    <updated>2016-01-02T17:39:28.897Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>之前写了一篇文章 <a href="http://blog.xiaohansong.com/2015/11/24/clean-code-polymorphism/">简洁代码之道（1）：用多态替代条件语句</a>，有人问实现多态的时候为什么用抽象类而不是接口。当时写文章的时候并没有想到这个问题。后来仔细想想，这的确是个值得探讨的问题。多态可以用抽象类或者接口实现，重点是应该用哪个？更大问题是，接口和抽象类有什么本质的区别？下面我们将讨论以下的问题：</p>
<ul>
<li>抽象类和接口的对比</li>
<li>从 java 容器类的设计讨论抽象类和接口的应用</li>
<li>抽象类和接口的使用时机</li>
</ul>
<h2 id="u62BD_u8C61_u7C7B_u4E0E_u63A5_u53E3_u7684_u5BF9_u6BD4"><a href="#u62BD_u8C61_u7C7B_u4E0E_u63A5_u53E3_u7684_u5BF9_u6BD4" class="headerlink" title="抽象类与接口的对比"></a>抽象类与接口的对比</h2><table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td> 默认的方法实现</td>
<td>它可以有默认的方法实现</td>
<td>接口完全是抽象的。它根本不存在方法的实现</td>
<td></td>
</tr>
<tr>
<td>实现</td>
<td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>与正常Java类的区别</td>
<td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td>接口是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有public、protected和default这些修饰符</td>
<td>接口方法默认修饰符是public。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td>main方法</td>
<td>抽象方法可以有main方法并且我们可以运行它</td>
<td>接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td>多继承</td>
<td>抽象方法可以继承一个类和实现多个接口</td>
<td>接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td>速度</td>
<td>它比接口速度要快</td>
<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody>
</table>
<p>抽象类和接口有不同，也有相似的地方。有些书把接口称作特殊的类，虽然不准确，但也有一定道理，接口能做的事情，抽象类也能做到，除了多重继承。正是因为这些相似的特性，让我们在使用它们的时候有了困惑：这里到底该用抽象类还是接口？</p>
<h2 id="u4ECE_java__u5BB9_u5668_u7C7B_u7684_u8BBE_u8BA1_u8BA8_u8BBA_u62BD_u8C61_u7C7B_u548C_u63A5_u53E3_u7684_u5E94_u7528"><a href="#u4ECE_java__u5BB9_u5668_u7C7B_u7684_u8BBE_u8BA1_u8BA8_u8BBA_u62BD_u8C61_u7C7B_u548C_u63A5_u53E3_u7684_u5E94_u7528" class="headerlink" title="从 java 容器类的设计讨论抽象类和接口的应用"></a>从 java 容器类的设计讨论抽象类和接口的应用</h2><p>除了前面提到的一个问题：多态到底是用抽象类还是接口实现？我还看到有人评论说：现在都是提倡面向接口编程，使用抽象类的都被称为上世纪的老码农了。哈哈。看到这个说法我也是苦笑不得。不过，面向接口编程的确是一个趋势，java 8 已经支持接口实现默认方法和静态方法了，抽象类和接口之间的差异越来越小。闲话少说，我们开始讨论抽象类和接口的应用。</p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/full_container_taxonomy.png" alt="full_container_taxonomy"></p>
<p>上图是 java 容器类的类继承关系。我们以容器类中 <code>ArrayList</code> 为例子来讨论抽象类和接口的应用。</p>
<h3 id="ArrayList__u7C7B_u7EE7_u627F_u5173_u7CFB"><a href="#ArrayList__u7C7B_u7EE7_u627F_u5173_u7CFB" class="headerlink" title="ArrayList 类继承关系"></a>ArrayList 类继承关系</h3><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/ArrayList.png" alt="ArrayList"></p>
<p>上图是 <code>ArrayList</code> 的类继承关系。可以看到，<code>ArrayList</code> 的继承关系中既使用了抽象类，也使用了接口。</p>
<ul>
<li>最顶层的接口是 <code>Iterable</code>，表示这是可迭代的类型。所有容器类都是可迭代的，这是一个极高的抽象。</li>
<li>第二层的接口是 <code>Collection</code>，这是单一元素容器的接口。集合，列表都属于此类。</li>
<li>第三层的接口是 <code>List</code>，这是所有列表的接口。</li>
</ul>
<p>通过三个接口，我们可以找到容器类的三个抽象特性，实现这些接口就意味着拥有这些接口的特性。</p>
<ul>
<li><code>AbstractCollection</code> 实现了 <code>Collection</code> 中的部分方法。</li>
<li><code>AbstractList</code> 实现了 <code>AbstractCollection</code> 和 <code>List</code> 中的部分方法。</li>
</ul>
<p>上面的抽象类提供了一些方法的默认实现，给具体类提供了复用代码。</p>
<h3 id="u7EAF_u62BD_u8C61_u7C7B_u5B9E_u73B0"><a href="#u7EAF_u62BD_u8C61_u7C7B_u5B9E_u73B0" class="headerlink" title="纯抽象类实现"></a>纯抽象类实现</h3><p>如果我们像一个老码农一样，用抽象类来实现上面的接口会有怎样的效果？那么，类图可能变成这样。</p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/AbtractList.png" alt="AbtractList"></p>
<p>抽象类在这里存在着一个很大的问题，它不能多继承，在抽象的层次上没有接口高，也没有接口灵活。例如说：</p>
<pre><code>List + AbstractCollection -&gt; AbstractList
Set  + AbstractCollection -&gt; AbstractSet
</code></pre><p>单纯用抽象类无法实现像接口一样灵活的扩展。</p>
<h3 id="u7EAF_u63A5_u53E3_u5B9E_u73B0"><a href="#u7EAF_u63A5_u53E3_u5B9E_u73B0" class="headerlink" title="纯接口实现"></a>纯接口实现</h3><p>如果我们像一个新码农一样，用纯接口来实现呢？</p>
<p> <img src="http://7xjtfr.com1.z0.glb.clouddn.com/InterfaceList.png" alt="InterfaceList"></p>
<p>这样写理论上没有问题，实际写代码的时候问题就来了。所有的接口都要提供实现，于是你不得不在各个实现类中重复代码。</p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>经过上面的讨论，我们得出两个结论：</p>
<ul>
<li>抽象类和接口并不能互相替代。</li>
<li>抽象类和接口各有不可替代的作用。</li>
</ul>
<p>从容器类的类关系图中可以看到，接口主要是用来抽象类型的共性，例如说，容器的可迭代特性。抽象类主要是给具体实现类提供重用的代码，例如说，<code>List</code> 的一些默认方法。</p>
<h2 id="u62BD_u8C61_u7C7B_u548C_u63A5_u53E3_u7684_u4F7F_u7528_u65F6_u673A"><a href="#u62BD_u8C61_u7C7B_u548C_u63A5_u53E3_u7684_u4F7F_u7528_u65F6_u673A" class="headerlink" title="抽象类和接口的使用时机"></a>抽象类和接口的使用时机</h2><p>那么，什么时候该用抽象类，什么时候该用接口呢？</p>
<p>要解决上面的问题，我们先从弄清楚抽象类和接口之间的关系。首先，我们都知道类对事物的抽象，定义了事物的属性和行为。而抽象类是不完全的类，具有抽象方法。接口则比类的抽象层次更高。所以，我们可以这样理解它们之间的关系：<strong>类是对事物的抽象，抽象类是对类的抽象，接口是对抽象类的抽象。</strong></p>
<p>从这个角度来看 java 容器类，你会发现，它的设计正体现了这种关系。不是吗？从 <code>Iterable</code> 接口，到 <code>AbstractList</code> 抽象类，再到 <code>ArrayList</code> 类。</p>
<p>现在回答前面的问题：在设计类的时候，首先考虑用接口抽象出类的特性，当你发现某些方法可以复用的时候，可以使用抽象类来复用代码。简单说，<strong>接口用于抽象事物的特性，抽象类用于代码复用</strong>。</p>
<p>当然，不是所有类的设计都要从接口到抽象类，再到类。程序设计本就没有绝对的范式可以遵循。上面的说法只是提供一个角度来理解抽象类和接口的关系，每个人都会有自己的理解，有人认为两者一点关系都没有，这也有道理。总之，模式和语法是死的，人是活的。</p>
<p><em>参考资料</em><br><a href="http://www.importnew.com/12399.html" target="_blank" rel="external">Java抽象类与接口的区别</a><br><a href="https://bxbxbai.github.io/2014/07/20/understood_abstract_class_and_interface/.glb.clouddn.com/InterfaceList.png" target="_blank" rel="external">我如何理解Java中抽象类和接口</a><br><a href="http://www.uml.org.cn/mxdx/200904232.asp" target="_blank" rel="external">面向接口编程详解</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>之前写了一篇文章 <a href="http://blog.xiaohansong.com/2015/1]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[简洁代码之道（2）：避免全局可变状态]]></title>
    <link href="http://blog.xiaohansong.com/2015/11/30/avoid-global-state/"/>
    <id>http://blog.xiaohansong.com/2015/11/30/avoid-global-state/</id>
    <published>2015-11-30T07:42:41.000Z</published>
    <updated>2016-01-02T17:39:28.897Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文是我看了 <a href="https://www.youtube.com/playlist?list=PL693EFD059797C21E" target="_blank" rel="external">谷歌简洁代码演讲系列</a> 中的 <a href="https://www.youtube.com/watch?v=-FRm3VPhseI&amp;index=4&amp;list=PL693EFD059797C21E" target="_blank" rel="external">全局状态与单例模式</a> 之后的总结。本文的主题是：避免全局可变状态。下面我们将围绕几个问题开展讨论：</p>
<ul>
<li>什么是全局状态</li>
<li>如何设计好的单例模式</li>
<li>如何设计好的 API</li>
</ul>
<h2 id="u5168_u5C40_u72B6_u6001"><a href="#u5168_u5C40_u72B6_u6001" class="headerlink" title="全局状态"></a>全局状态</h2><h3 id="u4EC0_u4E48_u662F_u5168_u5C40_u72B6_u6001"><a href="#u4EC0_u4E48_u662F_u5168_u5C40_u72B6_u6001" class="headerlink" title="什么是全局状态"></a>什么是全局状态</h3><blockquote>
<p>Talk is cheap, show me the code. – Linus</p>
</blockquote>
<p>我们来用一个例子说明什么是全局状态。</p>
<pre><code>class X {
    X() {...}

    public int doSomething() {...}
}

int a = new X().doSomething()
int b = new X().doSomething()
</code></pre><p>现在问题来了，<code>a</code> 等于 <code>b</code> 吗？事实上有两种可能的情况。</p>
<p>第一种情况：<code>X</code> 类不受全局状态的影响，此时 <code>a == b</code></p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/global_state1.png" alt="a==b"><br>当 <code>X</code> 被实例化时，它可能会同时创建多个其它对象，当它执行 <code>doSomething()</code> 的时候，得到的结果是一样。说明它是无状态的，每次执行都像 <code>1+1=2</code> 一样有一个确定的值。</p>
<p>第二种情况：<code>X</code> 类受到全局状态的影响，此时 <code>a != b</code></p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/global_state2.png" alt="a!=b"><br>如果 <code>X</code> 在执行 <code>doSomething()</code> 的时候，其中的 <code>Z</code> 变量受到全局状态 <code>GS</code> 的影响，此时 <code>a==b</code> 可能就不成立了。因为程序的执行依赖全局状态，同样的方法可能会得到不同的结果。</p>
<h3 id="u5168_u5C40_u72B6_u6001_u7684_u7F3A_u70B9"><a href="#u5168_u5C40_u72B6_u6001_u7684_u7F3A_u70B9" class="headerlink" title="全局状态的缺点"></a>全局状态的缺点</h3><p>全局状态相当常见，因为写起来方便。“啊，有一个新的功能要加入，我们加一个全局变量，再加一个条件语句跳转到新的方法就行了。”然而，这种方便却让程序变得难以维护和测试。所以，有一定经验的程序员都会认为全局状态令人讨厌，会避免使用它。</p>
<p>下面我们来列举全局状态的罪状：</p>
<ul>
<li>多次执行同一方法会产生不同的结果<ul>
<li>测试无法给出一个可靠的结果</li>
<li>测试的顺序会影响到结果</li>
<li>不能并行进行测试</li>
</ul>
</li>
<li>很难确定设置状态的位置</li>
</ul>
<p>总之，从测试的角度来看，全局状态是很可怕的东西。</p>
<h3 id="u5168_u5C40_u72B6_u6001_u548C_u5168_u5C40_u53D8_u91CF_u7684_u533A_u522B"><a href="#u5168_u5C40_u72B6_u6001_u548C_u5168_u5C40_u53D8_u91CF_u7684_u533A_u522B" class="headerlink" title="全局状态和全局变量的区别"></a>全局状态和全局变量的区别</h3><ul>
<li>全局状态不仅包括了全局变量，还包括系统的环境变量，以及人为的命令等。</li>
<li>全局变量是在程序生命周期中全局可访问的变量，常用来表示全局状态。</li>
</ul>
<h2 id="u5355_u4F8B_u6A21_u5F0F"><a href="#u5355_u4F8B_u6A21_u5F0F" class="headerlink" title="单例模式"></a>单例模式</h2><p>有些程序员讨厌全局状态，却喜欢单例模式。但是，从某种意义上说，单例模式是另一种全局状态。当然我不是一棍子打死单例模式，应该说，写得不好的单例模式起到的作用就如同全局状态，让程序难以维护和测试。下面我们来讨论什么是好的单例模式，什么是坏的单例模式</p>
<h3 id="u574F_u7684_u5355_u4F8B_u6A21_u5F0F"><a href="#u574F_u7684_u5355_u4F8B_u6A21_u5F0F" class="headerlink" title="坏的单例模式"></a>坏的单例模式</h3><p>下面是典型的单例模式实现。</p>
<pre><code>class AppSetting {
    private static AppSetting instance = new AppSetting();
    private Object state1;
    private Object state2;
    private Object state3;
    private AppSetting() {...}

    public static AppSetting getInstance() {
        return instance;
    }
}
</code></pre><p>我们先来思考一个问题：这个类包括了多少个全局变量？你可能觉得只有一个 <code>instance</code>，事实上一共有4个。只要 <code>instance</code> 一直存在，它的成员变量也会一直存在。也就是说一共有四个全局变量：<code>state1, state2, state3, instance</code>。</p>
<pre><code>class App {
    int method() {
        return AppSetting.getInstance().doX();
    }
}

void testApp {
    ???
}
</code></pre><p>想想我们怎么测试上面的代码。单例模式下，你没有缝隙进入到 <code>method()</code> 函数中测试。</p>
<p>上面的单例模式存在一个很大的测试问题：测试无法覆盖所有的状态。因为状态是私有，同时它单例的。如果我们要测试三个状态怎么办，一个解决办法是在测试的时候把状态改为公有的。这看起来有点诡异，我们一方面又想用单例封装状态，一方面却在测试的时候要去修改代码让它的状态公有。可以说，这种单例模式给测试带来了极大的麻烦。</p>
<h3 id="u597D_u7684_u5355_u4F8B_u6A21_u5F0F"><a href="#u597D_u7684_u5355_u4F8B_u6A21_u5F0F" class="headerlink" title="好的单例模式"></a>好的单例模式</h3><p>那么，什么是好的单例模式呢？看下面的代码。</p>
<pre><code>class AppSetting {
    private Object state1;
    private Object state2;
    private Object state3;
    public AppSetting() {...}
}
</code></pre><p>第一眼看到这个代码，你可能觉得这哪里是单例模式，明明就是个普通的类。</p>
<p>是的，它的确是个普通的类。在这里我们让它不再着重于类自身的单例。什么意思？想想单例模式的本质是什么，单例模式主要是类保证在程序的生命周期内只有一个实例，其它对象访问到的是同一个实例。我们来看看，这种模式对测试带来了怎样的便利。</p>
<pre><code>class App {
    AppSetting settings;
    App(AppSetting settings) {
        this.settings = settings;
    }

    int method() {
        return settings.doX();
    }
}

void testApp() {
     new App(new AppSetting(...)).method();
}
</code></pre><p>每个测试我们可以提供一个不同的 <code>AppSetting</code> 来进行测试，相比上面的单例模式，测试得到了更多的控制。我们可以通过不同的 <code>AppSetting</code> 的构造函数，改变程序的状态来进行测试。</p>
<p>看到这里，你可能有一个疑问：这样子写的代码根本就不是单例模式。的确，从类的实现上，<code>AppSetting</code> 的确不是单例模式的。这里我们强调的是逻辑上的单例，而不是代码实现上的单例。怎么理解？</p>
<p>首先，单例模式的传统实现是由类来管理这个唯一的实例，也就是我们上面说的“坏的单例模式”，而“好的单例模式”则是由程序来控制类的唯一实例，例如说，Spring IoC 容器中的 Bean，在容器的生命周期中，Bean 默认是单例的。（详细的解释可以看这篇文章 <a href="http://blog.xiaohansong.com/2015/10/21/IoC-and-DI/">控制反转（IoC）与依赖注入（DI）</a>）简单说，就是把单例类管理唯一实例的功能转移给外部容器，当你使用了 IoC 框架之后，你会发现，单例模式的实例完全可以通过容器管理，而不用我们写“坏的单例模式”。</p>
<h2 id="u8BBE_u8BA1_u597D_u7684_API"><a href="#u8BBE_u8BA1_u597D_u7684_API" class="headerlink" title="设计好的 API"></a>设计好的 API</h2><p>全局状态同样会影响到 API 的好坏。</p>
<h3 id="u574F_u7684_API"><a href="#u574F_u7684_API" class="headerlink" title="坏的 API"></a>坏的 API</h3><p>我们来看一个坏的 API。</p>
<pre><code>testCharge() {
    Database.connect();
    OfflineQueue.start();
    CreditCardProcessor.init();
    CreditCard cc = new CreditCard(&quot;123&quot;);
    cc.charge(100);
}
</code></pre><p>如果你对单例模式的坏处还没完全理解，或者你也喜欢写这样的代码，那么刷新编程观的时候到了。</p>
<p>上面是一个信用卡测试消费的例子。在实例化 <code>CreditCard</code> 之前要有三个初始化操作（明显都是单例模式）。现在问题来了：如果你是新来的测试人员，让你去测试 <code>CreditCard</code>，你看了 API 文档之后，兴冲冲地写下一些代码。</p>
<pre><code>testCharge() {
    CreditCard cc = new CreditCard(&quot;123&quot;);
    cc.charge(100);
}
</code></pre><p>现在满怀期待的运行，结果却是熟悉的 <code>NullPointerException</code>。为什么？新来的你当然不知道创建 <code>CreditCard</code> 之前要先连接数据库，启动离线队列，初始化信用卡处理器。所以你只能去问开发人员。现在你知道问题出在哪了吗？</p>
<p>坏的单例模式让测试人员很难测试代码，因为你看了 API 之后只知道要实例化 <code>CreditCard</code>，然后调用 <code>charge</code>，完全不知道 <code>Database</code> 之类的全局状态是什么鬼。不要以为这只会为难到测试人员，六个月之后你就能体验到测试人员的痛苦。因此，全局状态让 API 有了误导性，让你以为做了正确的操作。</p>
<p>当然，文档写的清楚可以解决这个问题，然而好的文档可遇不可求，所以我们要有更好的解决办法。</p>
<h3 id="u597D_u7684_API"><a href="#u597D_u7684_API" class="headerlink" title="好的 API"></a>好的 API</h3><p>设计好的 API，可以从代码层面上解决上面的问题，所谓代码就是最好的注释。</p>
<pre><code>testCharge() {
    db = new Database(...);
    queue = new OfflineQueue(db);
    ccProc = new CreditCardProcessor(queue);
    CreditCard cc = new CreditCard(&quot;123&quot;, ccProc);
    cc.charge(100);
}
</code></pre><p>上面的代码通过<strong>让依赖参数化</strong>完美地解决上面的问题。现在，我们还是那个新来的测试人员，我们开始写测试代码。API 告诉我们，实例化 <code>CreditCard</code> 需要 <code>CreditCardProcessor</code> 作为参数，<code>CreditCardProcessor</code>需要 <code>OfflineQueue</code>，<code>OfflineQueue</code> 需要 <code>Database</code>。于是我们可以很清楚的写下上面的测试代码，不需要文档的辅助，我们也知道如何正确的使用 <code>CreditCard</code>。这就是好的 API 设计。</p>
<p>如果我们要让上面的配置类单例化，只需要使用 IoC 容器进行管理即可，通过依赖注入的方式，可以使代码更加清晰，易测试。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>全局状态是大多数测试问题的根源。</li>
<li>全局状态无法被测试控制，无法控制意味着无法进行彻底的测试。</li>
<li>单例模式是封装了全局状态的常用形式。这也是我们不提倡使用单例模式的原因，推荐用容器管理的单例模式。</li>
<li>全局状态会让 API 具有误导性。</li>
</ul>
<p><em>参考资料</em><br><a href="https://www.youtube.com/watch?v=-FRm3VPhseI&amp;index=4&amp;list=PL693EFD059797C21E" target="_blank" rel="external">全局状态与单例模式</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文是我看了 <a href="https://www.youtube.com/playlist?lis]]>
    </summary>
    
      <category term="编程实践" scheme="http://blog.xiaohansong.com/tags/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="设计" scheme="http://blog.xiaohansong.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="编程实践" scheme="http://blog.xiaohansong.com/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简洁代码之道（1）：用多态替代条件语句]]></title>
    <link href="http://blog.xiaohansong.com/2015/11/24/clean-code-polymorphism/"/>
    <id>http://blog.xiaohansong.com/2015/11/24/clean-code-polymorphism/</id>
    <published>2015-11-24T07:54:43.000Z</published>
    <updated>2016-04-09T08:16:17.133Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文是我看了 <a href="https://www.youtube.com/playlist?list=PL693EFD059797C21E" target="_blank" rel="external">谷歌简洁代码演讲系列</a> 中的 <a href="https://www.youtube.com/watch?v=4F72VULWFvc&amp;list=PL693EFD059797C21E&amp;index=1" target="_blank" rel="external">多态和条件语句</a> 的总结。大部分的条件语句是可以用多态代替的，本文将围绕以下问题开展：</p>
<ul>
<li>为什么要用多态替代条件语句</li>
<li>多态和条件语句的使用场景</li>
<li>如何用多态代替条件语句</li>
<li>在哪里决定要创建什么子类</li>
<li>什么情况下使用多态</li>
</ul>
<h2 id="u4E3A_u4EC0_u4E48_u8981_u7528_u591A_u6001_u66FF_u4EE3_u6761_u4EF6_u8BED_u53E5"><a href="#u4E3A_u4EC0_u4E48_u8981_u7528_u591A_u6001_u66FF_u4EE3_u6761_u4EF6_u8BED_u53E5" class="headerlink" title="为什么要用多态替代条件语句"></a>为什么要用多态替代条件语句</h2><ul>
<li>没有 if 语句的函数更容易阅读。</li>
<li>没有 if 语句的函数更容易测试。</li>
<li>多态的系统更容易维护。</li>
</ul>
<h2 id="u591A_u6001_u548C_u6761_u4EF6_u8BED_u53E5_u7684_u4F7F_u7528_u573A_u666F"><a href="#u591A_u6001_u548C_u6761_u4EF6_u8BED_u53E5_u7684_u4F7F_u7528_u573A_u666F" class="headerlink" title="多态和条件语句的使用场景"></a>多态和条件语句的使用场景</h2><h3 id="u4F7F_u7528_u591A_u6001_u7684_u573A_u666F"><a href="#u4F7F_u7528_u591A_u6001_u7684_u573A_u666F" class="headerlink" title="使用多态的场景"></a>使用多态的场景</h3><ul>
<li>当对象要根据不同的状态表现不同的行为时。</li>
<li>当你需要在很多地方检查相同的条件时。</li>
</ul>
<h3 id="u4F7F_u7528_u6761_u4EF6_u8BED_u53E5_u7684_u573A_u666F"><a href="#u4F7F_u7528_u6761_u4EF6_u8BED_u53E5_u7684_u573A_u666F" class="headerlink" title="使用条件语句的场景"></a>使用条件语句的场景</h3><ul>
<li>主要用于原始对象的比较：&lt;，&gt;，==，!=。</li>
<li>其他</li>
</ul>
<p>这篇文章主要着重于如何避免 if 语句。</p>
<h3 id="u5982_u4F55_u907F_u514D_u4F7F_u7528_if__u8BED_u53E5"><a href="#u5982_u4F55_u907F_u514D_u4F7F_u7528_if__u8BED_u53E5" class="headerlink" title="如何避免使用 if 语句"></a>如何避免使用 if 语句</h3><ul>
<li>不要返回 null，而是返回一个空的对象，例如说空的链表。</li>
<li>不要返回错误码，而是直接在运行时抛出异常。</li>
</ul>
<h2 id="u5982_u4F55_u7528_u591A_u6001_u4EE3_u66FF_u6761_u4EF6_u8BED_u53E5"><a href="#u5982_u4F55_u7528_u591A_u6001_u4EE3_u66FF_u6761_u4EF6_u8BED_u53E5" class="headerlink" title="如何用多态代替条件语句"></a>如何用多态代替条件语句</h2><p>如果你有一个条件语句，它根据对象的类型选择不同的行为。那么如何用多态来替代它呢？下面，我们来看一个例子。</p>
<h3 id="u6761_u4EF6_u8BED_u53E5_u5B9E_u73B0_u7684_u7C7B"><a href="#u6761_u4EF6_u8BED_u53E5_u5B9E_u73B0_u7684_u7C7B" class="headerlink" title="条件语句实现的类"></a>条件语句实现的类</h3><pre><code>Class Update {
    execute() {
        if (FLAG_i18n_ENABLE) {
            //DO A;
        } else {
            //DO B;
        }
    }
    render() {
        if (FLAG_i18n_ENABLE) {
            //render A;
        } else {
            //render B;
        }
    }
}
</code></pre><p>上面的类根据 <code>FLAG_i18n_ENABLE</code> 来执行不同的操作。可能你以前就是这么写代码的，觉得这样写一点问题都没有。那么，我现在问你，怎么测试上面的类？</p>
<p>下面我们来看看一般的测试方法。</p>
<pre><code>void testExecuteDoA() {
    FLAG_i18n_ENABLE = true;
    Update u = new Update();
    u.execute();
    assertX();
}
void testExecuteDoB() {
    FLAG_i18n_ENABLE = false;
    Update u = new Update();
    u.execute();
    assertX();
}
</code></pre><p>看完上面的代码，你可能也觉得似曾相识，也觉得没什么问题。</p>
<p>实际上，这样写的类有以下几个问题：</p>
<ul>
<li>大量的条件语句判断让代码可读性急剧下降。就好像你在高速公路上行驶的时候，开的正开心，前面一个此路不通的公示牌出现，于是你不得不走别的路。看代码也是同样道理，太多的分支语句会让读者晕头转向。</li>
<li>条件语句的存在让测试更加困难。在写测试的时候，你不得不去考虑它的状态码。上面的类只有两个状态，如果有五个状态呢。光是搞清楚状态之间关系就已经够呛了。</li>
</ul>
<h3 id="u591A_u6001_u5B9E_u73B0_u7684_u7C7B"><a href="#u591A_u6001_u5B9E_u73B0_u7684_u7C7B" class="headerlink" title="多态实现的类"></a>多态实现的类</h3><p>那么，如何用多态来重写上面的类呢？</p>
<p>我们可以分为两步来操作：</p>
<ul>
<li>让 <code>Update</code> 成为抽象类，方法也抽象。</li>
<li>在子类中的覆盖方法实现条件语句的分支操作。</li>
</ul>
<p>代码如下</p>
<pre><code>abstract class Update {
    abstract execute();
    abstract render();
}

class I18NUpdate extends Update {
    execute() {
        //Do A;
    }
    render() {
        //render A;
    }
}

class NonI18NUpdate extends Update {
    execute() {
        //Do B;
    }
    render() {
        //render B;
    }
}
</code></pre><p>测试方法：</p>
<pre><code>void testExecuteDoA() {
    Update u = new I18NUpdate();
    u.execute();
    assertX();
}
void testExecuteDoB() {
    Update u = new NonI18NUpdate();
    u.execute();
    assertX();
}
</code></pre><p>用多态实现的类，通过继承抽象类，重写抽象方法的方式，避免使用了条件语句。在测试的时候，不需要关心它的状态码，子类本身就已经承载了状态信息。所以你可以看到，在测试的时候，代码非常的清晰易懂。</p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>使用多态实现的类有两个好处：</p>
<ul>
<li>我们可以通过增加新的子类来添加新的行为，而且不会影响到原来的代码。</li>
<li>不同的操作和概念在不同的类中，容易理解和阅读。</li>
</ul>
<h2 id="u5728_u54EA_u91CC_u51B3_u5B9A_u8981_u521B_u5EFA_u4EC0_u4E48_u5B50_u7C7B"><a href="#u5728_u54EA_u91CC_u51B3_u5B9A_u8981_u521B_u5EFA_u4EC0_u4E48_u5B50_u7C7B" class="headerlink" title="在哪里决定要创建什么子类"></a>在哪里决定要创建什么子类</h2><p>咋一看上面的标题有点绕，我们来详细讨论一下问题的来源。上面我们讲了如何多态代替条件语句，但是有一个问题是无法回避的：我们怎么判断要创建哪一种子类？</p>
<p>实际上，我们还是要依靠 <code>FLAG_i18n_ENABLE</code> 来决定实例化哪个子类，也就是说，我们仍然要用到条件语句。看到这里你可能就觉得：说到底还是要靠条件语句，博主忽悠人。此言差矣，这么说，条件语句的使用是必要不充分的。写程序你肯定要用到条件语句，但是用的太多会有前面我们说到的问题。把多态和条件语句结合，才是正道。</p>
<p>我们回到前面的问题，既然条件语句无法避免，因为我们要根据条件决定使用哪个子类。我们先来对类做一个粗略的划分。</p>
<ul>
<li>负责业务逻辑的类：例如说我们上面的 <code>Update</code></li>
<li>负责创建类的类：例如说工厂模式中的 <code>Factory</code></li>
</ul>
<p>通过上面的划分，我们可以把子类创建交给工厂类。</p>
<pre><code>class Consumer {
    Cosumer(Update u) {...}
}

class Factory {
    Consumer build() {
        Update u = FLAG_i18n_ENABLE
                    ? new I18NUpdate()
                    : new NonI18NUpdate;
        return new Consumer(u);
    }
}
</code></pre><p>现在我们可以回答上面的问题了：在工厂类中根据条件决定要创建哪个子类。这样处理有以下的好处：</p>
<ul>
<li>条件语句集中在了一个地方。</li>
<li>没有多余的重复，除了工厂类，其他地方不需要用到条件语句。</li>
<li>分离了职责和全局状态。</li>
<li>相同的代码集中在一个地方。</li>
<li>独立测试变得简单，而且能同时进行。</li>
<li>在子类中可以清楚地看到实现的不同。</li>
</ul>
<h2 id="u4EC0_u4E48_u60C5_u51B5_u4E0B_u4F7F_u7528_u591A_u6001"><a href="#u4EC0_u4E48_u60C5_u51B5_u4E0B_u4F7F_u7528_u591A_u6001" class="headerlink" title="什么情况下使用多态"></a>什么情况下使用多态</h2><blockquote>
<p>多态虽好，可不要滥用。 – Yonah潇</p>
</blockquote>
<ul>
<li>类的行为根据状态进行变化的时候。</li>
<li>同样的条件语句在多个地方出现的时候。</li>
</ul>
<p>最后，我只说一句：该用条件语句的时候不要强行用多态。</p>
<p><em>参考资料</em><br><a href="https://www.youtube.com/watch?v=4F72VULWFvc&amp;list=PL693EFD059797C21E&amp;index=1" target="_blank" rel="external">多态和条件语句</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文是我看了 <a href="https://www.youtube.com/playlist?lis]]>
    </summary>
    
      <category term="编程实践" scheme="http://blog.xiaohansong.com/tags/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="设计" scheme="http://blog.xiaohansong.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="编程实践" scheme="http://blog.xiaohansong.com/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[控制反转（IoC）与依赖注入（DI）]]></title>
    <link href="http://blog.xiaohansong.com/2015/10/21/IoC-and-DI/"/>
    <id>http://blog.xiaohansong.com/2015/10/21/IoC-and-DI/</id>
    <published>2015-10-21T13:39:57.000Z</published>
    <updated>2016-04-23T02:54:04.713Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>最近在学习Spring框架，它的核心就是IoC容器。要掌握Spring框架，就必须要理解控制反转的思想以及依赖注入的实现方式。下面，我们将围绕下面几个问题来探讨控制反转与依赖注入的关系以及在Spring中如何应用。</p>
<ul>
<li>什么是控制反转？</li>
<li>什么是依赖注入？</li>
<li>它们之间有什么关系？</li>
<li>如何在Spring框架中应用依赖注入？</li>
</ul>
<h2 id="u4EC0_u4E48_u662F_u63A7_u5236_u53CD_u8F6C"><a href="#u4EC0_u4E48_u662F_u63A7_u5236_u53CD_u8F6C" class="headerlink" title="什么是控制反转"></a>什么是控制反转</h2><p>在讨论控制反转之前，我们先来看看软件系统中耦合的对象。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/%E9%BD%BF%E8%BD%AE_%E8%80%A6%E5%90%88%E5%85%B3%E7%B3%BB_full.jpg" alt="图1：软件系统中耦合的对象"><br>从图中可以看到，软件中的对象就像齿轮一样，协同工作，但是互相耦合，一个零件不能正常工作，整个系统就崩溃了。这是一个强耦合的系统。齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。</p>
<p>为了解决对象间耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”。</p>
<p><strong>控制反转（Inversion of Control）</strong>是一种是面向对象编程中的一种设计原则，用来减低计算机代码之间的耦合度。其基本思想是：借助于“第三方”实现具有依赖关系的对象之间的解耦。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/%E9%BD%BF%E8%BD%AE_%E8%A7%A3%E8%80%A6%E5%90%88_full.jpg" alt="图2：IOC解耦过程"><br>由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。<br>我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：</p>
<ol>
<li>软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</li>
<li>软件系统在引入IOC容器之后，这种情形就完全改变了，如图2所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</li>
</ol>
<p>通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p>
<p>控制反转不只是软件工程的理论，在生活中我们也有用到这种思想。再举一个现实生活的例子：<br>海尔公司作为一个电器制商需要把自己的商品分销到全国各地，但是发现，不同的分销渠道有不同的玩法，于是派出了各种销售代表玩不同的玩法，随着渠道越来越多，发现，每增加一个渠道就要新增一批人和一个新的流程，严重耦合并依赖各渠道商的玩法。实在受不了了，于是制定业务标准，开发分销信息化系统，只有符合这个标准的渠道商才能成为海尔的分销商。让各个渠道商反过来依赖自己标准。反转了控制，倒置了依赖。</p>
<p>我们把海尔和分销商当作软件对象，分销信息化系统当作IOC容器，可以发现，在没有IOC容器之前，分销商就像图1中的齿轮一样，增加一个齿轮就要增加多种依赖在其他齿轮上，势必导致系统越来越复杂。开发分销系统之后，所有分销商只依赖分销系统，就像图2显示那样，可以很方便的增加和删除齿轮上去。</p>
<h2 id="u4EC0_u4E48_u662F_u4F9D_u8D56_u6CE8_u5165"><a href="#u4EC0_u4E48_u662F_u4F9D_u8D56_u6CE8_u5165" class="headerlink" title="什么是依赖注入"></a>什么是依赖注入</h2><p><strong>依赖注入</strong>就是将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)。</p>
<h3 id="u4EC0_u4E48_u662F_u4F9D_u8D56"><a href="#u4EC0_u4E48_u662F_u4F9D_u8D56" class="headerlink" title="什么是依赖"></a>什么是依赖</h3><p>如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。</p>
<pre><code>public class Human {
    ...
    Father father;
    ...
    public Human() {
        father = new Father();
    }
}
</code></pre><p>仔细看这段代码我们会发现存在一些问题：</p>
<ol>
<li>如果现在要改变 father 生成方式，如需要用new Father(String name)初始化 father，需要修改 Human 代码；</li>
<li>如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中；</li>
<li>如果new Father()过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。</li>
</ol>
<h3 id="u4F9D_u8D56_u6CE8_u5165"><a href="#u4F9D_u8D56_u6CE8_u5165" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式，如下：</p>
<pre><code>public class Human {
    ...
    Father father;
    ...
    public Human(Father father) {
        this.father = father;
    }
}
</code></pre><p>上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。<br>现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处：</p>
<ol>
<li>解耦，将依赖之间解耦。</li>
<li>因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。</li>
</ol>
<h2 id="u63A7_u5236_u53CD_u8F6C_u548C_u4F9D_u8D56_u6CE8_u5165_u7684_u5173_u7CFB"><a href="#u63A7_u5236_u53CD_u8F6C_u548C_u4F9D_u8D56_u6CE8_u5165_u7684_u5173_u7CFB" class="headerlink" title="控制反转和依赖注入的关系"></a>控制反转和依赖注入的关系</h2><p>我们已经分别解释了控制反转和依赖注入的概念。有些人会把控制反转和依赖注入等同，但实际上它们有着本质上的不同。</p>
<ul>
<li><strong>控制反转</strong>是一种思想</li>
<li><strong>依赖注入</strong>是一种设计模式</li>
</ul>
<p>IoC框架使用依赖注入作为实现控制反转的方式，但是控制反转还有其他的实现方式，例如说<a href="http://martinfowler.com/articles/injection.html#UsingAServiceLocator" target="_blank" rel="external">ServiceLocator</a>，所以不能将控制反转和依赖注入等同。</p>
<h2 id="Spring_u4E2D_u7684_u4F9D_u8D56_u6CE8_u5165"><a href="#Spring_u4E2D_u7684_u4F9D_u8D56_u6CE8_u5165" class="headerlink" title="Spring中的依赖注入"></a>Spring中的依赖注入</h2><p>上面我们提到，依赖注入是实现控制反转的一种方式。下面我们结合Spring的IoC容器，简单描述一下这个过程。</p>
<pre><code>class MovieLister...
    private MovieFinder finder;
    public void setFinder(MovieFinder finder) {
        this.finder = finder;
    }

class ColonMovieFinder...
    public void setFilename(String filename) {
        this.filename = filename;
    }
</code></pre><p>我们先定义两个类，可以看到都使用了依赖注入的方式，通过外部传入依赖，而不是自己创建依赖。那么问题来了，谁把依赖传给他们，也就是说谁负责创建<code>finder</code>，并且把<code>finder</code>传给<code>MovieLister</code>。答案是Spring的IoC容器。</p>
<p>要使用IoC容器，首先要进行配置。这里我们使用xml的配置，也可以通过代码注解方式配置。下面是<code>spring.xml</code>的内容</p>
<pre><code>&lt;beans&gt;
    &lt;bean id=&quot;MovieLister&quot; class=&quot;spring.MovieLister&quot;&gt;
        &lt;property name=&quot;finder&quot;&gt;
            &lt;ref local=&quot;MovieFinder&quot;/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;MovieFinder&quot; class=&quot;spring.ColonMovieFinder&quot;&gt;
        &lt;property name=&quot;filename&quot;&gt;
            &lt;value&gt;movies1.txt&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>在Spring中，每个bean代表一个对象的实例，默认是单例模式，即在程序的生命周期内，所有的对象都只有一个实例，进行重复使用。通过配置bean，IoC容器在启动的时候会根据配置生成bean实例。具体的配置语法参考Spring文档。这里只要知道IoC容器会根据配置创建<code>MovieFinder</code>，在运行的时候把<code>MovieFinder</code>赋值给<code>MovieLister</code>的<code>finder</code>属性，完成依赖注入的过程。</p>
<p>下面给出测试代码</p>
<pre><code>public void testWithSpring() throws Exception {
    ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;spring.xml&quot;);//1
    MovieLister lister = (MovieLister) ctx.getBean(&quot;MovieLister&quot;);//2
    Movie[] movies = lister.moviesDirectedBy(&quot;Sergio Leone&quot;);
    assertEquals(&quot;Once Upon a Time in the West&quot;, movies[0].getTitle());
}
</code></pre><ol>
<li>根据配置生成<code>ApplicationContext</code>，即IoC容器。</li>
<li>从容器中获取<code>MovieLister</code>的实例。</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>控制反转是一种在软件工程中解耦合的思想，调用类只依赖接口，而不依赖具体的实现类，减少了耦合。控制权交给了容器，在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中。</li>
<li>依赖注入是一种设计模式，可以作为控制反转的一种实现方式。依赖注入就是将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)。</li>
<li>通过IoC框架，类A依赖类B的强耦合关系可以在运行时通过容器建立，也就是说把创建B实例的工作移交给容器，类A只管使用就可以。</li>
</ol>
<p><em>参考文章</em><br><a href="http://coolshell.cn/articles/9949.html" target="_blank" rel="external">IoC/DIP其实是一种管理思想</a><br><a href="http://martinfowler.com/articles/injection.html" target="_blank" rel="external">Inversion of Control Containers and the Dependency Injection pattern</a><br><a href="https://github.com/android-cn/blog/tree/master/java/dependency-injectionrticles/9949.html" target="_blank" rel="external">依赖注入</a><br><a href="http://www.importnew.com/13619.html" target="_blank" rel="external">跟我一起学Spring 3(4)–深入理解IoC(控制反转)和DI(依赖注入)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>最近在学习Spring框架，它的核心就是IoC容器。要掌握Spring框架，就必须要理解控制反转的思想以]]>
    </summary>
    
      <category term="DI" scheme="http://blog.xiaohansong.com/tags/DI/"/>
    
      <category term="IoC" scheme="http://blog.xiaohansong.com/tags/IoC/"/>
    
      <category term="java" scheme="http://blog.xiaohansong.com/tags/java/"/>
    
      <category term="Java" scheme="http://blog.xiaohansong.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内存寻址之分页机制]]></title>
    <link href="http://blog.xiaohansong.com/2015/10/05/Linux%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80%E4%B9%8B%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.xiaohansong.com/2015/10/05/Linux内存寻址之分页机制/</id>
    <published>2015-10-05T04:51:06.000Z</published>
    <updated>2016-05-21T03:16:51.174Z</updated>
    <content type="html"><![CDATA[<p>在上一篇文章<a href="http://blog.xiaohansong.com/2015/10/03/Linux%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80%E4%B9%8B%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/">Linux内存寻址之分段机制</a>中，我们了解逻辑地址通过分段机制转换为线性地址的过程。下面，我们就来看看更加重要和复杂的分页机制。</p>
<p>分页机制在段机制之后进行，以完成线性—物理地址的转换过程。段机制把逻辑地址转换为线性地址，分页机制进一步把该线性地址再转换为物理地址。</p>
<h2 id="u786C_u4EF6_u4E2D_u7684_u5206_u9875"><a href="#u786C_u4EF6_u4E2D_u7684_u5206_u9875" class="headerlink" title="硬件中的分页"></a>硬件中的分页</h2><p>分页机制由CR0中的PG位启用。如PG=1，启用分页机制，并使用本节要描述的机制，把线性地址转换为物理地址。如PG=0，禁用分页机制，直接把段机制产生的线性地址当作物理地址使用。分页机制管理的对象是固定大小的存储块，称之为页(page)。分页机制把整个线性地址空间及整个物理地址空间都看成由页组成，在线性地址空间中的任何一页，可以映射为物理地址空间中的任何一页（我们把物理空间中的一页叫做一个页面或页框(page frame)）<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/image002.gif" alt=""><br>80386使用4K字节大小的页。每一页都有4K字节长，并在4K字节的边界上对齐，即每一页的起始地址都能被4K整除。因此，80386把4G字节的线性地址空间，划分为1M个页面，每页有4K字节大小。分页机制通过把线性地址空间中的页，重新定位到物理地址空间来进行管理，因为每个页面的整个4K字节作为一个单位进行映射，并且每个页面都对齐4K字节的边界，因此，线性地址的低12位经过分页机制直接地作为物理地址的低12位使用。</p>
<h3 id="u4E3A_u4EC0_u4E48_u4F7F_u7528_u4E24_u7EA7_u9875_u8868"><a href="#u4E3A_u4EC0_u4E48_u4F7F_u7528_u4E24_u7EA7_u9875_u8868" class="headerlink" title="为什么使用两级页表"></a>为什么使用两级页表</h3><p>假设每个进程都占用了4G的线性地址空间，页表共含1M个表项，每个表项占4个字节，那么每个进程的页表要占据4M的内存空间。为了节省页表占用的空间，我们使用两级页表。每个进程都会被分配一个页目录，但是只有被实际使用页表才会被分配到内存里面。一级页表需要一次分配所有页表空间，两级页表则可以在需要的时候再分配页表空间。</p>
<h3 id="u4E24_u7EA7_u9875_u8868_u7ED3_u6784"><a href="#u4E24_u7EA7_u9875_u8868_u7ED3_u6784" class="headerlink" title="两级页表结构"></a>两级页表结构</h3><p>两级表结构的第一级称为页目录，存储在一个4K字节的页面中。页目录表共有1K个表项，每个表项为4个字节，并指向第二级表。线性地址的最高10位(即位31~位32)用来产生第一级的索引，由索引得到的表项中，指定并选择了1K个二级表中的一个表。<br>两级表结构的第二级称为页表，也刚好存储在一个4K字节的页面中，包含1K个字节的表项，每个表项包含一个页的物理基地址。第二级页表由线性地址的中间10位(即位21~位12)进行索引，以获得包含页的物理地址的页表项，这个物理地址的高20位与线性地址的低12位形成了最后的物理地址，也就是页转化过程输出的物理地址。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/image003.gif" alt="两级页表结构"></p>
<h3 id="u9875_u76EE_u5F55_u9879"><a href="#u9875_u76EE_u5F55_u9879" class="headerlink" title="页目录项"></a>页目录项</h3><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/image004.gif" alt="页目录项结构"></p>
<ul>
<li>第31~12位是20位页表地址，由于页表地址的低12位总为0，所以用高20位指出32位页表地址就可以了。因此，一个页目录最多包含1024个页表地址。</li>
<li>第0位是存在位，如果P=1，表示页表地址指向的该页在内存中，如果P=0，表示不在内存中。</li>
<li>第1位是读/写位，第2位是用户/管理员位，这两位为页目录项提供硬件保护。当特权级为3的进程要想访问页面时，需要通过页保护检查，而特权级为0的进程就可以绕过页保护。</li>
<li>第3位是PWT（Page Write-Through）位，表示是否采用写透方式，写透方式就是既写内存（RAM）也写高速缓存,该位为1表示采用写透方式</li>
<li>第4位是PCD（Page Cache Disable）位，表示是否启用高速缓存,该位为1表示启用高速缓存。</li>
<li>第5位是访问位，当对页目录项进行访问时，A位=1。</li>
<li>第7位是Page Size标志，只适用于页目录项。如果置为1，页目录项指的是4MB的页面，请看后面的扩展分页。</li>
<li>第9~11位由操作系统专用，Linux也没有做特殊之用。</li>
</ul>
<h3 id="u9875_u9762_u9879"><a href="#u9875_u9762_u9879" class="headerlink" title="页面项"></a>页面项</h3><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/image008.gif" alt="页面项结构"><br>80386的每个页目录项指向一个页表，页表最多含有1024个页面项，每项4个字节，包含页面的起始地址和有关该页面的信息。页面的起始地址也是4K的整数倍，所以页面的低12位也留作它用。<br>第31~12位是20位物理页面地址，除第6位外第0～5位及9~11位的用途和页目录项一样，第6位是页面项独有的，当对涉及的页面进行写操作时，D位被置1。<br>4GB的内存只有一个页目录，它最多有1024个页目录项，每个页目录项又含有1024个页面项，因此，内存一共可以分成1024×1024=1M个页面。由于每个页面为4K个字节，所以，存储器的大小正好最多为4GB。</p>
<h3 id="u7EBF_u6027_u5730_u5740_u5230_u7269_u7406_u5730_u5740_u7684_u8F6C_u6362"><a href="#u7EBF_u6027_u5730_u5740_u5230_u7269_u7406_u5730_u5740_u7684_u8F6C_u6362" class="headerlink" title="线性地址到物理地址的转换"></a>线性地址到物理地址的转换</h3><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/image010.gif" alt="32位线性地址到物理地址的转换"></p>
<ol>
<li>CR3包含着页目录的起始地址，用32位线性地址的最高10位A31~A22作为页目录的页目录项的索引，将它乘以4，与CR3中的页目录的起始地址相加，形成相应页表的地址。</li>
<li>从指定的地址中取出32位页目录项，它的低12位为0，这32位是页表的起始地址。用32位线性地址中的A21~A12位作为页表中的页面的索引，将它乘以4，与页表的起始地址相加，形成32位页面地址。</li>
<li>将A11~A0作为相对于页面地址的偏移量，与32位页面地址相加，形成32位物理地址。</li>
</ol>
<h3 id="u6269_u5C55_u5206_u9875"><a href="#u6269_u5C55_u5206_u9875" class="headerlink" title="扩展分页"></a>扩展分页</h3><p>从奔腾处理器开始,Intel微处理器引进了扩展分页,它允许页的大小为4MB。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/image012.gif" alt="扩展分页"><br>在扩展分页的情况下,分页机制把32位线性地址分成两个域：最高10位的目录域和其余22位的偏移量。</p>
<h3 id="u9875_u9762_u9AD8_u901F_u7F13_u5B58"><a href="#u9875_u9762_u9AD8_u901F_u7F13_u5B58" class="headerlink" title="页面高速缓存"></a>页面高速缓存</h3><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/image013.gif" alt="页面高速缓存"><br>由于在分页情况下，每次存储器访问都要存取两级页表，这就大大降低了访问速度。所以，为了提高速度，在386中设置一个最近存取页面的高速缓存硬件机制，它自动保持32项处理器最近使用的页面地址，因此，可以覆盖128K字节的存储器地址。当进行存储器访问时，先检查要访问的页面是否在高速缓存中，如果在，就不必经过两级访问了，如果不在，再进行两级访问。平均来说，页面高速缓存大约有98%的命中率，也就是说每次访问存储器时，只有2%的情况必须访问两级分页机构。这就大大加快了速度。</p>
<h2 id="Linux_u4E2D_u7684_u5206_u9875_u673A_u5236"><a href="#Linux_u4E2D_u7684_u5206_u9875_u673A_u5236" class="headerlink" title="Linux中的分页机制"></a>Linux中的分页机制</h2><p>Linux使用了一个适合32位和64位系统的分页机制。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/four-level.png" alt="Linux分页模型"></p>
<ul>
<li>页全局目录</li>
<li>页顶级目录</li>
<li>页中间目录</li>
<li>页表</li>
</ul>
<p>页全局目录包含若干页上级目录的地址，页上级目录又依次包含若干页中间目录的地址，而页中间目录又包含若干页表的地址。每一个页表项指向一个页框。线性地址因此被分成五个部分。图中没有显示位数，因为每一部分的大小与具体的计算机体系结构有关。</p>
<p>对于没有启用物理地址扩展的32位系统，两级页表已经足够了。从本质上说Linux通过使“页上级目录”位和“页中间目录”位全为0，彻底取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在32位系统和64位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为1，并把这两个目录项映射到页全局目录的一个合适的目录项而实现的。</p>
<p>启用了物理地址扩展的32 位系统使用了三级页表。Linux的页全局目录对应80×86 的页目录指针表（PDPT），取消了页上级目录，页中间目录对应80×86的页目录，Linux的页表对应80×86的页表。</p>
<p>最后，64位系统使用三级还是四级分页取决于硬件对线性地址的位的划分。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这里我们不讨论代码实现，只关注原理。从上面的讨论可以看到分页机制主要依赖硬件的实现。Linux采用的四级页表只是为了最大化兼容不同的硬件实现，单就IA32架构的CPU来说，就有多种分页实现，常规分页机制，PAE机制等。</p>
<p>我们虽然讨论的是Linux的分页机制，实际上我们用了大部分篇幅来讨论Intel CPU的分页机制实现。因为Linux的分页机制是建立在硬件基础之上的，不同的平台需要有不同的实现。Linux在软件层面构造的虚拟地址，最终还是要通过MMU转换为物理地址，也就是说，不管Linux的分页机制是怎样实现的，CPU只按照它的分页实现来解读线性地址，所以Linux传给CPU的线性地址必然是满足硬件实现的。例如说：Linux在32位CPU上，它的四级页表结构就会兼容到硬件的两级页表结构。可见，Linux在软件层面上做了一层抽象，用四级页表的方式兼容32位和64位CPU内存寻址的不同硬件实现。</p>
<p>最后分享两篇linux内存寻址的实验文档，结合实例更容易理解。<br><a href="http://ilinuxkernel.com/?p=1276" target="_blank" rel="external">Linux内存地址映射</a><br><a href="http://ilinuxkernel.com/?p=1303" target="_blank" rel="external">Linux内核在x86_64 CPU中地址映射</a></p>
<p><em>参考资料</em><br>《深入理解Linux内核》<br>《深入分析Linux内核源码》</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇文章<a href="http://blog.xiaohansong.com/2015/10/03/Linux%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80%E4%B9%8B%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88]]>
    </summary>
    
      <category term="Linux" scheme="http://blog.xiaohansong.com/tags/Linux/"/>
    
      <category term="Linux内核" scheme="http://blog.xiaohansong.com/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内存寻址之分段机制]]></title>
    <link href="http://blog.xiaohansong.com/2015/10/03/Linux%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80%E4%B9%8B%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.xiaohansong.com/2015/10/03/Linux内存寻址之分段机制/</id>
    <published>2015-10-03T05:56:31.000Z</published>
    <updated>2016-04-26T03:16:55.042Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>最近在学习Linux内核，读到《深入理解Linux内核》的内存寻址一章。原本以为自己对分段分页机制已经理解了，结果发现其实是一知半解。于是，查找了很多资料，最终理顺了内存寻址的知识。现在把我的理解记录下来，希望对内核学习者有一定帮助，也希望大家指出错误之处。</p>
<h2 id="u5206_u6BB5_u5230_u5E95_u662F_u600E_u4E48_u56DE_u4E8B"><a href="#u5206_u6BB5_u5230_u5E95_u662F_u600E_u4E48_u56DE_u4E8B" class="headerlink" title="分段到底是怎么回事"></a>分段到底是怎么回事</h2><p>相信学过操作系统课程的人都知道分段分页，但是奇怪的是书上基本没提分段分页是怎么产生的，这就导致我们知其然不知其所以然。下面我们先扒一下分段机制产生的历史。</p>
<h3 id="u5B9E_u6A21_u5F0F_u7684_u8BDE_u751F_uFF0816_u4F4D_u5904_u7406_u5668_u53CA_u5BFB_u5740_uFF09"><a href="#u5B9E_u6A21_u5F0F_u7684_u8BDE_u751F_uFF0816_u4F4D_u5904_u7406_u5668_u53CA_u5BFB_u5740_uFF09" class="headerlink" title="实模式的诞生（16位处理器及寻址）"></a>实模式的诞生（16位处理器及寻址）</h3><p>在8086处理器诞生之前，内存寻址方式就是直接访问物理地址。8086处理器为了寻址1M的内存空间，把地址总线扩展到了20位。但是，一个尴尬的问题出现了，ALU的宽度只有16位，也就是说，ALU不能计算20位的地址。为了解决这个问题，分段机制被引入，登上了历史舞台。</p>
<p>为了支持分段，8086处理器设置了四个段寄存器：CS, DS, SS, ES.每个段寄存器都是16位的，同时访问内存的指令中的地址也是16位的。但是，在送入地址总线之前，CPU先把它与某个段寄存器内的值相加。这里要注意：段寄存器的值对应于20位地址总线的中的高16位，所以相加时实际上是16位内存地址（即段内偏移值）的高12位与段寄存器中的16位相加，而低4位保留不变，这样就形成一个20位的实际地址，也就实现了从16位内存地址到20位实际地址的转换，或者叫“映射”。</p>
<p><em>上面关于分段机制计算内存地址的描述比较难理解，画了一个图帮助理解</em></p>
<pre><code>+-----------------+
|       20        |  20位地址总线
+-----------------+
+------------+
|      16    |       16位段地址
+------------+
    +-------------+
    |    12  | 4  |  16位内存地址（段内偏移量）
    +--------+----+

实际物理地址 = （段寄存器地址 &lt;&lt; 4） + （CPU 提交的访存地址）
</code></pre><h3 id="u4FDD_u62A4_u6A21_u5F0F_u7684_u8BDE_u751F_uFF0832_u4F4D_u5904_u7406_u5668_u53CA_u5BFB_u5740_uFF09"><a href="#u4FDD_u62A4_u6A21_u5F0F_u7684_u8BDE_u751F_uFF0832_u4F4D_u5904_u7406_u5668_u53CA_u5BFB_u5740_uFF09" class="headerlink" title="保护模式的诞生（32位处理器及寻址）"></a>保护模式的诞生（32位处理器及寻址）</h3><ul>
<li>80286处理器的地址总线为24位，寻址空间达16M，同时引入了保护模式（内存段的访问受到限制）</li>
<li>80386处理器是一个32位处理器，ALU和地址总线都是32位的，寻址空间达 4G。也就是说它可以不通过分段机制，直接访问4G的内存空间。虽然它是新时代的小王子，超越它的无数前辈，然而，它需要背负家族的使命–兼容前代的处理器。也就是说，它必须支持实模式和保护模式。所以，80386在段寄存器的基础上构筑保护模式，并且保留16位的段寄存器。</li>
<li>从80386之后的处理器，架构基本相似，统称为IA32（32 Bit Intel Architecture）。</li>
</ul>
<h2 id="IA32_u7684_u5185_u5B58_u5BFB_u5740_u673A_u5236"><a href="#IA32_u7684_u5185_u5B58_u5BFB_u5740_u673A_u5236" class="headerlink" title="IA32的内存寻址机制"></a>IA32的内存寻址机制</h2><h3 id="u5BFB_u5740_u786C_u4EF6"><a href="#u5BFB_u5740_u786C_u4EF6" class="headerlink" title="寻址硬件"></a>寻址硬件</h3><p>在 8086 的实模式下，把某一段寄存器左移4位，然后与地址ADDR相加后被直接送到内存总线上，这个相加后的地址就是内存单元的物理地址，而程序中的这个地址就叫逻辑地址（或叫虚地址）。在IA32的保护模式下，这个逻辑地址不是被直接送到内存总线而是被送到内存管理单元（MMU）。MMU由一个或一组芯片组成，其功能是把逻辑地址映射为物理地址，即进行地址转换，如图所示。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/mmu.png" alt="MMU"></p>
<h3 id="IA32_u7684_u4E09_u79CD_u5730_u5740"><a href="#IA32_u7684_u4E09_u79CD_u5730_u5740" class="headerlink" title="IA32的三种地址"></a>IA32的三种地址</h3><ul>
<li>逻辑地址:<br>  机器语言指令仍用这种地址指定一个操作数的地址或一条指令的地址。 这种寻址方式在Intel的分段结构中表现得尤为具体，它使得MS-DOS或Windows程序员把程序分为若干段。每个逻辑地址都由一个段和偏移量组成。</li>
<li>线性地址：<br>  线性地址是一个32位的无符号整数，可以表达高达232（4GB）的地址。通常用16进制表示线性地址，其取值范围为0x00000000～0xffffffff。</li>
<li>物理地址：<br>  也就是内存单元的实际地址，用于芯片级内存单元寻址。 物理地址也由32位无符号整数表示。</li>
</ul>
<h3 id="MMU_u5730_u5740_u8F6C_u5316_u8FC7_u7A0B"><a href="#MMU_u5730_u5740_u8F6C_u5316_u8FC7_u7A0B" class="headerlink" title="MMU地址转化过程"></a>MMU地址转化过程</h3><p>MMU是一种硬件电路，它包含两个部件，一个是分段部件，一个是分页部件，在此，我们把它们分别叫做分段机制和分页机制，以利于从逻辑的角度来理解硬件的实现机制。分段机制把一个逻辑地址转换为线性地址；接着，分页机制把一个线性地址转换为物理地址。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/mmu_translate.png" alt="MMU_translate"></p>
<h3 id="IA32_u7684_u6BB5_u5BC4_u5B58_u5668"><a href="#IA32_u7684_u6BB5_u5BC4_u5B58_u5668" class="headerlink" title="IA32的段寄存器"></a>IA32的段寄存器</h3><p>IA32中有六个16位段寄存器：CS, DS, SS, ES，FS, GS.跟8086的段寄存器不同的是，这些寄存器存放的不再是某个段的基地址，而是某个段的选择符（Selector）。</p>
<h2 id="u5206_u6BB5_u673A_u5236_u7684_u5B9E_u73B0"><a href="#u5206_u6BB5_u673A_u5236_u7684_u5B9E_u73B0" class="headerlink" title="分段机制的实现"></a>分段机制的实现</h2><p>段是虚拟地址空间的基本单位，分段机制必须把虚拟地址空间的一个地址转换为线性地址空间的一个线性地址。</p>
<p>为了实现这种映射，仅仅用段寄存器来确定一个基地址是不够的，至少还得描述段的长度，并且还需要段的一些其他信息，比如访问权之类。所以，这里需要的是一个数据结构，这个结构包括三个方面的内容：</p>
<ol>
<li>段的基地址(Base Address)：在线性地址空间中段的起始地址。</li>
<li>段的界限(Limit)：在虚拟地址空间中，段内可以使用的最大偏移量。</li>
<li>段的保护属性(Attribute)：表示段的特性。例如，该段是否可被读出或写入，或者该段是否作为一个程序来执行，以及段的特权级等等。</li>
</ol>
<p>上面的数据结构我们称为<strong>段描述符</strong>，多个段描述符组成的表称为<strong>段描述符表</strong></p>
<h3 id="u6BB5_u63CF_u8FF0_u7B26"><a href="#u6BB5_u63CF_u8FF0_u7B26" class="headerlink" title="段描述符"></a>段描述符</h3><p>所谓描述符(Descriptor)，就是描述段的属性的一个8字节存储单元。在实模式下，段的属性不外乎是代码段、堆栈段、数据段、段的起始地址、段的长度等等，而在保护模式下则复杂一些。IA32将它们结合在一起用一个8字节的数表示，称为描述符 。<br><img src="http://7xjtfr.com1.z0.glb.clouddn.com/segment_descriptor.png" alt="IA32的一个通用的段描述符的结构"><br>从图可以看出，一个段描述符指出了段的32位基地址和20位段界限(即段长)。这里我们只关注基地址和段界限，其他的属性略过。</p>
<h3 id="u6BB5_u63CF_u8FF0_u7B26_u8868"><a href="#u6BB5_u63CF_u8FF0_u7B26_u8868" class="headerlink" title="段描述符表"></a>段描述符表</h3><p>各种各样的用户描述符和系统描述符，都放在对应的全局描述符表、局部描述符表和中断描述符表中。描述符表(即段表)定义了IA32系统的所有段的情况。所有的描述符表本身都占据一个字节为8的倍数的存储器空间，空间大小在8个字节(至少含一个描述符)到64K字节(至多含8K)个描述符之间。</p>
<ol>
<li>全局描述符表(GDT)<br> 全局描述符表GDT(Global Descriptor Table)，除了任务门，中断门和陷阱门描述符外，包含着系统中所有任务都共用的那些段的描述符。 它的第一个8字节位置没有使用。</li>
<li>中断描述符表IDT(Interrupt Descriptor Table)<br> 中断描述符表IDT(Interrupt Descriptor Table)，包含256个门描述符。IDT中只能包含任务门、中断门和陷阱门描述符，虽然IDT表最长也可以为64K字节，但只能存取2K字节以内的描述符，即256个描述符，这个数字是为了和8086保持兼容。</li>
<li>局部描述符表(LDT)<br> 局部描述符表LDT(local Descriptor Table)，包含了与一个给定任务有关的描述符，每个任务各自有一个的LDT。 有了LDT，就可以使给定任务的代码、 数据与别的任务相隔离。每一个任务的局部描述符表LDT本身也用一个描述符来表示，称为LDT描述符，它包含了有关局部描述符表的信息，被放在全局描述符表GDT中。</li>
</ol>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>IA32的内存寻址机制完成从逻辑地址–线性地址–物理地址的转换。其中，逻辑地址的段寄存器中的值提供段描述符，然后从段描述符中得到段基址和段界限，然后加上逻辑地址的偏移量，就得到了线性地址，线性地址通过分页机制得到物理地址。<br>首先，我们要明确，分段机制是IA32提供的寻址方式，这是硬件层面的。就是说，不管你是windows还是linux，只要使用IA32的CPU访问内存，都要经过MMU的转换流程才能得到物理地址，也就是说必须经过逻辑地址–线性地址–物理地址的转换。</p>
<h2 id="Linux_u4E2D_u5206_u6BB5_u7684_u5B9E_u73B0"><a href="#Linux_u4E2D_u5206_u6BB5_u7684_u5B9E_u73B0" class="headerlink" title="Linux中分段的实现"></a>Linux中分段的实现</h2><p>前面说了那么多关于分段机制的实现，其实，对于Linux来说，并没有什么卵用。因为，Linux基本不使用分段的机制，或者说，Linux中的分段机制只是为了兼容IA32的硬件而设计的。</p>
<p>Intel微处理器的段机制是从8086开始提出的， 那时引入的段机制解决了从CPU内部16位地址到20位实地址的转换。为了保持这种兼容性，386仍然使用段机制，但比以前复杂得多。因此，Linux内核的设计并没有全部采用Intel所提供的段方案，仅仅有限度地使用了一下分段机制。这不仅简化了Linux内核的设计，而且为把Linux移植到其他平台创造了条件，因为很多RISC处理器并不支持段机制。但是，对段机制相关知识的了解是进入Linux内核的必经之路。</p>
<p>从2.2版开始，Linux让所有的进程（或叫任务）都使用相同的逻辑地址空间，因此就没有必要使用局部描述符表LDT。但内核中也用到LDT，那只是在VM86模式中运行Wine，因为就是说在Linux上模拟运行Winodws软件或DOS软件的程序时才使用。</p>
<p>在 IA32 上任意给出的地址都是一个虚拟地址，即任意一个地址都是通过“选择符:偏移量”的方式给出的，这是段机制存访问模式的基本特点。所以在IA32上设计操作系统时无法回避使用段机制。一个虚拟地址最终会通过“段基地址＋偏移量”的方式转化为一个线性地址。 但是，由于绝大多数硬件平台都不支持段机制，只支持分页机制，所以为了让 Linux 具有更好的可移植性，我们需要去掉段机制而只使用分页机制。但不幸的是，IA32规定段机制是不可禁止的，因此不可能绕过它直接给出线性地址空间的地址。万般无奈之下，Linux的设计人员干脆让段的基地址为0，而段的界限为4GB，这时任意给出一个偏移量，则等式为“0+偏移量=线性地址”，也就是说“偏移量＝线性地址”。另外由于段机制规定“偏移量&lt;4GB”，所以偏移量的范围为0H～FFFFFFFFH，这恰好是线性地址空间范围，也就是说虚拟地址直接映射到了线性地址，我们以后所提到的虚拟地址和线性地址指的也就是同一地址。看来，Linux在没有回避段机制的情况下巧妙地把段机制给绕过去了。</p>
<p>另外，由于IA32段机制还规定，必须为代码段和数据段创建不同的段，所以Linux必须为代码段和数据段分别创建一个基地址为0，段界限为4GB的段描述符。不仅如此，由于Linux内核运行在特权级0，而用户程序运行在特权级别3，根据IA32段保护机制规定，特权级3的程序是无法访问特权级为0的段的，所以Linux必须为内核用户程序分别创建其代码段和数据段。这就意味着Linux必须创建4个段描述符——特权级0的代码段和数据段，特权级3的代码段和数据段。</p>
<h2 id="u603B_u7ED3-1"><a href="#u603B_u7ED3-1" class="headerlink" title="总结"></a>总结</h2><p>分段机制是IA32架构CPU的特色，并不是操作系统寻址方式的必然选择。Linux为了跨平台，巧妙的绕开段机制，主要使用分页机制来寻址。</p>
<p><em>参考资料</em><br>《深入分析Linux内核源码》</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>最近在学习Linux内核，读到《深入理解Linux内核》的内存寻址一章。原本以为自己对分段分页机制已经理]]>
    </summary>
    
      <category term="Linux" scheme="http://blog.xiaohansong.com/tags/Linux/"/>
    
      <category term="Linux内核" scheme="http://blog.xiaohansong.com/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ucore实验之操作系统启动流程]]></title>
    <link href="http://blog.xiaohansong.com/2015/10/02/ucore%E5%AE%9E%E9%AA%8C%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://blog.xiaohansong.com/2015/10/02/ucore实验之操作系统启动流程/</id>
    <published>2015-10-02T08:02:05.000Z</published>
    <updated>2016-01-02T17:39:28.899Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文基于 ucore 操作系统实验,简要分析操作系统的启动流程.</p>
<p>ucore 操作系统是清华大学用于操作系统教学实验的OS，参考了 MIT 的 JOS，哈佛的 OS161 以及 Linux 系统。我们可以通过这个迷你操作系统在代码层面上理解操作系统的思想。</p>
<blockquote>
<p><a href="https://github.com/chyyuu/ucore_os_lab" target="_blank" rel="external">ucore labs</a> was used as OS Experiments in OS Course Of Dept. of Computer Science &amp; Technology, Tsinghua University. ucore is a teaching OS which is derived from xv6&amp;jos in MIT, OS161 in Harvard and Linux.</p>
</blockquote>
<h2 id="u7269_u7406_u5185_u5B58_u7684_u5206_u5E03"><a href="#u7269_u7406_u5185_u5B58_u7684_u5206_u5E03" class="headerlink" title="物理内存的分布"></a>物理内存的分布</h2><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/pc_memory.png" alt="PC默认物理内存分布"></p>
<p>早期的 PC 是基于 16 位的 Intel 8088 的处理器的,因此只支持 1MB 的物理内存。早期的 PC 的物理内存是从 0x00000000 到 0x000FFFFF,而不是结束于 0xFFFFFFFF。</p>
<p>如图 3-1 所示,物理内存的前 640KB 被标记为了“LowMemory”,这一块内存区域是早期 PC 唯一可以使用的 RAM。事实上,非常早期的 PC 仅仅只能使用 16KB、 32KB 或者 64KB 的 RAM。<br>从 0x000A0000 到 0x000FFFFF 的 384kB的区域是被硬件保留着用于特殊通途的,比如<br>像作为 VGA 的显示输出的缓存或者是被当作保存系统固化指令的非易失性存储器。这一部分内存区域中最重要的应该是保存在 0x000F0000 到 0x00100000 处占据 64KB 的基本输入输出系统(BIOS)。在早期的 PC 中,BIOS 是被存储在真正的只读存储器(ROM)中,但然而如今的 PC 将 BIOS 存储在可以更新的闪存中。</p>
<p>BIOS 的作用是对系统进行初始化,比如像激活显卡、检查内存的总量。在进行完这些初始化后,BIOS 便将操作系统位置装载到内存,这些位置可以是软盘、硬盘、CD-ROM 或者是网络,在这之后,BIOS 便会将控制权交给操作系统。</p>
<p>当出现 80286 和 80386 处理器后,Intel 处理器终于打破了仅能访问 1MB 内存空间的限制,这两种处理器分别支持寻址 16MB 和 4GB 的内存空间。尽管如此,PC 架构还是保留了之前的物理内存低 1MB 空间的布局方式,这样做是为了保证和之前存在的软件相兼容,因此最新的 PC 会保留物理内存从 0x000A0000 到 0x00100000 的区域,这样便将系统可以使用的 RAM 分成了两个部分,一部分是低 640KB 的“LowMemory”,另一部分便是 1MB 以上部分的“扩展内存”。另外,32位物理地址空间的最高部分往往被 BIOS 保留供 32 位的 PCI 外设所使用。</p>
<p>如今的 x86 处理器能够支持多于 4GB 的物理内存，于是 RAM 的范围能够扩展到超过<br>0xFFFFFFFF。在这种情况下,BIOS 需要保留 32 位物理地址空间的最高部分,这是为了将<br>这个区域留给 32 位外设去匹配内存。在这里,由于设计的局限,ucore 操作系统仅仅会使用 PC 物理内存的前 256MB,所以我们只需考虑 PC 只支持 32 位物理地址空间。</p>
<h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p>在 PC 启动的时候,首先会在实模式下运行 BIOS。</p>
<blockquote>
<p>BIOS是英文”Basic Input Output System”的缩略词，直译过来后中文名称就是”基本输入输出系统”。其实，它是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从CMOS中读写系统设置的具体信息。 其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。</p>
</blockquote>
<p>在系统刚启动时,BIOS会被加载到物理内存中 0x000F0000 到 0x00100000  的位置处,CS 设置为 0xF000 ,将 IP 设置为 0xFFF0,物理地址为 0x000FFFF0,这样就保证了 BIOS 会在刚启动的时候得到控制权。BIOS 完成自检之后,就会把控制器交给 Boot Loader。</p>
<h2 id="Boot_Loader"><a href="#Boot_Loader" class="headerlink" title="Boot Loader"></a>Boot Loader</h2><p>我们已经知道 BIOS 在完成它的一系列初始化后便把控制权交给 Boot Loader 程序,Boot Loader 程序会在编译成可执行代码后被放在模拟硬盘的第一个扇区。</p>
<p>硬盘由于传统的原因被默认分割成了一个个大小为 512 字节的扇区,而扇区则是硬盘最小的读写单位,即每次对硬盘的读写操作只能够对一个或者多个扇区进行并且操作地址必须是 512 字节对齐的。</p>
<p>如果说操作系统是从磁盘启动的话,则磁盘的第一个扇区就被称作“启动扇区”,因为 Boot Loader 的可执行程序就存放在这个扇区。ucore 实验中,当 BIOS 找到启动的磁盘后,便将 512 字节的启动扇区的内容装载到物理内存的 0x7c00 到 0x7dff 的位置,紧接着再执行一个跳转指令将 CS 设置为 0x0000 ,IP设置为 0x7c00 ,这样便将控制权交给 Boot Loader 程序.</p>
<p>在 ucore 实验中,Boot Loader 由<code>bootasm.S</code>和<code>bootmain.c</code>编译而成.</p>
<ul>
<li><code>bootasm.S</code><br>  负责把处理器从实模式切换到保护模式(关于保护模式的相关知识请自行谷歌).然后调用<code>bootmain</code>函数.</li>
<li><code>bootmain.c</code><br>  把内核的可执行代码从硬盘中读取到内存中.这里的可执行代码指的是 ELF 文件.在 ucore 实验中,它从硬盘的第二个扇区开始存储,因为第一个扇区存的是 boot loader。</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/computer_open_flow.png" alt="计算机启动流程"></p>
<p>以上是计算机启动的一般流程,ucore 实验中的 boot loader 是比较简单的,不需要考虑硬盘分区等问题.但是我们从它的启动流程抽象出了一个本质的过程:操作系统的启动关键在于找到它的第一行可执行代码,至于是用什么方式,要视情况而定.</p>
<p><em>参考资料</em><br><a href="http://grid.hust.edu.cn/zyshao/OSEngineering.htm" target="_blank" rel="external">华中科技大学32位操作系统实践</a><br><a href="https://github.com/chyyuu/ucore_os_lab" target="_blank" rel="external">ucore_lab</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>本文基于 ucore 操作系统实验,简要分析操作系统的启动流程.</p>
<p>ucore 操作系统是清]]>
    </summary>
    
      <category term="ucore" scheme="http://blog.xiaohansong.com/tags/ucore/"/>
    
      <category term="操作系统" scheme="http://blog.xiaohansong.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="ucore" scheme="http://blog.xiaohansong.com/categories/ucore/"/>
    
  </entry>
  
</feed>
